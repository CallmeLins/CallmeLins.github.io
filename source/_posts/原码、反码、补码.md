---
title: 原码、反码、补码
categories: 
- C/C++
---

## 预备知识
&emsp; 由计算机的硬件决定，任何存储于计算机中的数据，其本质都是以二进制码存储，一个二进制称为1个Bit，而8个Bit组成一个字节，字节通常是数据存储的基本单位。
## 计算机中的数据存储
计算机中的存储通常以字节为单位，一个字节数8位，即1B（byte）=8b（bit），一个英文是一个字节，而一个汉字是两个字节。
假设有4个比特位：
&emsp;表示无符号正数，就是0 ~ 15
&emsp;表示有符号整数，那么其中一半给到+1 ~ +7，另一半给到-1 ~ -7
### 方法1：正数加上负号即对应负数
既然0010表示+2，那么如果最左边的bit位替换成1就表示对应的负数，即1010表示-2


| 0000 |  0   | 0100 |  4   | 1000 |  -0  | 1100 |  -4  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 0001 |  1   | 0101 |  5   | 1001 |  -1  | 1101 |  -5  |
| 0010 |  2   | 0110 |  6   | 1010 |  -2  | 1110 |  -6  |
| 0011 |  3   | 0111 |  7   | 1011 |  -3  | 1111 |  -7  |


这就是**原码**，但是此时会导致出现0和-0，这两个值在数学意义上的意思相同，二进制编码却不同
并且此时2+(-2)=0010+1010=1100=-4，是时候采用新的编码方法了
### 方法2：翻转
既然0010表示+2，那就将所有进制反转表示负数不就行了，即1101表示-2


| 0000 |  0   | 0100 |  4   | 1111 |  -0  | 1011 |  -4  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 0001 |  1   | 0101 |  5   | 1110 |  -1  | 1010 |  -5  |
| 0010 |  2   | 0110 |  6   | 1101 |  -2  | 1001 |  -6  |
| 0011 |  3   | 0111 |  7   | 1100 |  -3  | 1000 |  -7  |


这就是**反码**，此方法也会导致0和-0的二进制值不相同
此时2+(-2)=0010+1101=1111=-0，也勉强可用，但有没有更好的方法？
### 方法3：补码
在负数反码的基础上如-2(1101)加上(0001)得到(1110)
此时2+(-2)=0010+1110=10000此时我们可以放心的忽略掉该进位即变成0000=0
补码表为：


| 0000 |  0   | 0100 |  4   | 1000 |  -8  | 1100 |  -4  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 0001 |  1   | 0101 |  5   | 1111 |  -1  | 1011 |  -5  |
| 0010 |  2   | 0110 |  6   | 1110 |  -2  | 1010 |  -6  |
| 0011 |  3   | 0111 |  7   | 1101 |  -3  | 1001 |  -7  |
