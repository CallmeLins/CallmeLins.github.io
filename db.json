{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/next-reloaded/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/images/author.jpg","path":"images/author.jpg","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/js/algolia-search.js","path":"js/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/js/bookmark.js","path":"js/bookmark.js","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/lib/anime.min.js","path":"lib/anime.min.js","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1}],"Cache":[{"_id":"source/about/index.md","hash":"b42460bbcbd946df2ba75fb320d6b85c8fafe836","modified":1692104386950},{"_id":"source/_posts/CANoe系列教程-分析窗口-Graphic.md","hash":"f39eaeff8147b1463e1600f57143f006512de2ca","modified":1692104386926},{"_id":"source/_posts/CANoe系列教程-分析窗口-State Tracker.md","hash":"d505c585d2e88d35cd3de2a7f9379e796d17ed93","modified":1692104386914},{"_id":"source/_posts/CANoe系列教程-分析窗口-Trace.md","hash":"d63c6ca2eda88fd1560c95a383ea2a4f0b3b38c3","modified":1692104386898},{"_id":"source/_posts/CANoe系列教程-工程创建与通道配置.md","hash":"210ef00c72ccf265c19c58196b1fcb0d57c1fcca","modified":1692104386882},{"_id":"source/_posts/CAN总线基本知识.md","hash":"34306feb41734b60c29525bb547e8447803202f6","modified":1692104386862},{"_id":"source/_posts/CAN总线知识串联.md","hash":"582cae350e2e9cd18a990aec464e86f3bf43581f","modified":1692104386850},{"_id":"source/_posts/Github Page + Hexo 搭建个人博客.md","hash":"c027f4115bf1aa103618dbf7a067e985ac121faf","modified":1692107772854},{"_id":"source/_posts/Linux下配置Selenium.md","hash":"b0276d902a936c8f96c061c4deb7873d379e757b","modified":1692104386754},{"_id":"source/_posts/Linux安装Jupyter并且远程访问.md","hash":"8a89fb7b7e6e3c9dfdceec08603fb266f90f2a1f","modified":1692104386738},{"_id":"source/_posts/Linux系统编程-守护进程.md","hash":"ef0fe6020fdf43f97d749b8fba52dc068153a4e1","modified":1692104386722},{"_id":"source/_posts/Linux系统编程-进程控制.md","hash":"299a4ea4a77ce67998afd6f9411c7d73a68ea272","modified":1692104386706},{"_id":"source/_posts/Linux系统编程-进程间通讯.md","hash":"f9238fefd6bdfd84c8ed098f08ff2bd3c04bad7c","modified":1692104386690},{"_id":"source/_posts/Python学习-从面向对象开始.md","hash":"856ab6e1f6df0056b5f062aba21342960ad4468b","modified":1692104386674},{"_id":"source/_posts/Python学习-多线程和多进程.md","hash":"c2f465e02fe01d134053da37af11573c57dc6bbe","modified":1692104386654},{"_id":"source/_posts/Python学习-网络编程.md","hash":"a213bc5e695b82e42af9293ca177f19ce2b7ebf1","modified":1692104386638},{"_id":"source/_posts/Selenium的使用.md","hash":"3792715a92f3d0cf4a59518f353f4c5fc65ebdff","modified":1692104386622},{"_id":"source/_posts/Ubuntu配置Git并利用Gitee（码云）进行项目及代码的管理.md","hash":"d5509c697876d2167cbff35d32ae6569278fc16b","modified":1692104386606},{"_id":"source/_posts/gdb调试方法.md","hash":"f6f8e7717553cb08b2fb9e42cd6227f0277ad316","modified":1692104386830},{"_id":"source/_posts/数据结构（C语言版）.md","hash":"f8abd04d2cb9187f358366d4354cd9e96dd4466b","modified":1692104386582},{"_id":"source/_posts/新安装Ubuntu配置过程.md","hash":"3d4f2b87d60d6efd30feac733335bd2bfe30e6e6","modified":1692104386566},{"_id":"source/_posts/自动驾驶基础-AEB.md","hash":"18a0e9e2717f77844fccf2cb10268a422b7d1f11","modified":1692104386550},{"_id":"source/_posts/虚拟机安装Ubuntu，关闭动画精简软件等.md","hash":"9629d194a32985d5adaa14919d696cd86c7e83db","modified":1692104386534},{"_id":"source/categories/index.md","hash":"45cbaeb4363ce26f0a4a5a00cda8edbba791c1b0","modified":1692104386938},{"_id":"themes/next-reloaded/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1692104385002},{"_id":"themes/next-reloaded/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1692104385014},{"_id":"themes/next-reloaded/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1692104384990},{"_id":"themes/next-reloaded/.gitignore","hash":"7b68ca7a46104cf9aa84ec0541a4856ab1836eca","modified":1692104384718},{"_id":"themes/next-reloaded/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1692104384706},{"_id":"themes/next-reloaded/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1692104384694},{"_id":"themes/next-reloaded/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1692104382718},{"_id":"themes/next-reloaded/README.md","hash":"9b4b7d66aca47f9c65d6321b14eef48d95c4dff1","modified":1692104382686},{"_id":"themes/next-reloaded/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1692104384682},{"_id":"themes/next-reloaded/gulpfile.js","hash":"1b4fc262b89948937b9e3794de812a7c1f2f3592","modified":1692104384318},{"_id":"themes/next-reloaded/package.json","hash":"62fad6de02adbbba9fb096cbe2dcc15fe25f2435","modified":1692104382698},{"_id":"themes/next-reloaded/.github/PULL_REQUEST_TEMPLATE.md","hash":"1a435c20ae8fa183d49bbf96ac956f7c6c25c8af","modified":1692104384814},{"_id":"themes/next-reloaded/.github/CODE_OF_CONDUCT.md","hash":"aa4cb7aff595ca628cb58160ee1eee117989ec4e","modified":1692104384974},{"_id":"themes/next-reloaded/.github/config.yml","hash":"1d3f4e8794986817c0fead095c74f756d45f91ed","modified":1692104384958},{"_id":"themes/next-reloaded/_config.yml","hash":"0c2516b6c1551b7dffe9e6a708a22fbf845ada20","modified":1692104379922},{"_id":"themes/next-reloaded/.github/issue-close-app.yml","hash":"7cba457eec47dbfcfd4086acd1c69eaafca2f0cd","modified":1692104384926},{"_id":"themes/next-reloaded/.github/CONTRIBUTING.md","hash":"e554931b98f251fd49ff1d2443006d9ea2c20461","modified":1692104384942},{"_id":"themes/next-reloaded/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1692104384910},{"_id":"themes/next-reloaded/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1692104384826},{"_id":"themes/next-reloaded/.github/lock.yml","hash":"61173b9522ebac13db2c544e138808295624f7fd","modified":1692104384842},{"_id":"themes/next-reloaded/.github/stale.yml","hash":"fdf82de9284f8bc8e0b0712b4cc1cb081a94de59","modified":1692104384786},{"_id":"themes/next-reloaded/.github/release-drafter.yml","hash":"3cc10ce75ecc03a5ce86b00363e2a17eb65d15ea","modified":1692104384802},{"_id":"themes/next-reloaded/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1692104384730},{"_id":"themes/next-reloaded/docs/ALGOLIA-SEARCH.md","hash":"c7a994b9542040317d8f99affa1405c143a94a38","modified":1692104384650},{"_id":"themes/next-reloaded/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1692104384634},{"_id":"themes/next-reloaded/docs/DATA-FILES.md","hash":"cddbdc91ee9e65c37a50bec12194f93d36161616","modified":1692104384618},{"_id":"themes/next-reloaded/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1692104384666},{"_id":"themes/next-reloaded/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1692104384566},{"_id":"themes/next-reloaded/docs/UPDATE-FROM-5.1.X.md","hash":"8b6e4b2c9cfcb969833092bdeaed78534082e3e6","modified":1692104384466},{"_id":"themes/next-reloaded/layout/_layout.swig","hash":"6a6e92a4664cdb981890a27ac11fd057f44de1d5","modified":1692104383906},{"_id":"themes/next-reloaded/layout/archive.swig","hash":"e4e31317a8df68f23156cfc49e9b1aa9a12ad2ed","modified":1692104383998},{"_id":"themes/next-reloaded/layout/category.swig","hash":"1bde61cf4d2d171647311a0ac2c5c7933f6a53b0","modified":1692104383982},{"_id":"themes/next-reloaded/layout/index.swig","hash":"7f403a18a68e6d662ae3e154b2c1d3bbe0801a23","modified":1692104383966},{"_id":"themes/next-reloaded/layout/page.swig","hash":"db581bdeac5c75fabb0f17d7c5e746e47f2a9168","modified":1692104383950},{"_id":"themes/next-reloaded/layout/post.swig","hash":"2f6d992ced7e067521fdce05ffe4fd75481f41c5","modified":1692104383934},{"_id":"themes/next-reloaded/layout/tag.swig","hash":"0dfb653bd5de980426d55a0606d1ab122bd8c017","modified":1692104383922},{"_id":"themes/next-reloaded/languages/ar.yml","hash":"9815e84e53d750c8bcbd9193c2d44d8d910e3444","modified":1692104384298},{"_id":"themes/next-reloaded/languages/de.yml","hash":"74c59f2744217003b717b59d96e275b54635abf5","modified":1692104384286},{"_id":"themes/next-reloaded/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1692104384270},{"_id":"themes/next-reloaded/languages/en.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1692104384258},{"_id":"themes/next-reloaded/languages/es.yml","hash":"c64cf05f356096f1464b4b1439da3c6c9b941062","modified":1692104384242},{"_id":"themes/next-reloaded/languages/id.yml","hash":"572ed855d47aafe26f58c73b1394530754881ec2","modified":1692104384190},{"_id":"themes/next-reloaded/languages/hu.yml","hash":"b1ebb77a5fd101195b79f94de293bcf9001d996f","modified":1692104384202},{"_id":"themes/next-reloaded/languages/fr.yml","hash":"752bf309f46a2cd43890b82300b342d7218d625f","modified":1692104384218},{"_id":"themes/next-reloaded/languages/ja.yml","hash":"0cf0baa663d530f22ff380a051881216d6adcdd8","modified":1692104384162},{"_id":"themes/next-reloaded/languages/it.yml","hash":"44759f779ce9c260b895532de1d209ad4bd144bf","modified":1692104384178},{"_id":"themes/next-reloaded/languages/ko.yml","hash":"0feea9e43cd399f3610b94d755a39fff1d371e97","modified":1692104384150},{"_id":"themes/next-reloaded/languages/nl.yml","hash":"5af3473d9f22897204afabc08bb984b247493330","modified":1692104384138},{"_id":"themes/next-reloaded/languages/pt.yml","hash":"718d131f42f214842337776e1eaddd1e9a584054","modified":1692104384110},{"_id":"themes/next-reloaded/languages/pt-BR.yml","hash":"67555b1ba31a0242b12fc6ce3add28531160e35b","modified":1692104384126},{"_id":"themes/next-reloaded/languages/uk.yml","hash":"3a6d635b1035423b22fc86d9455dba9003724de9","modified":1692104384070},{"_id":"themes/next-reloaded/languages/tr.yml","hash":"fe793f4c2608e3f85f0b872fd0ac1fb93e6155e2","modified":1692104384082},{"_id":"themes/next-reloaded/languages/vi.yml","hash":"93393b01df148dcbf0863f6eee8e404e2d94ef9e","modified":1692104384054},{"_id":"themes/next-reloaded/languages/ru.yml","hash":"e993d5ca072f7f6887e30fc0c19b4da791ca7a88","modified":1692104384098},{"_id":"themes/next-reloaded/languages/zh-HK.yml","hash":"3789f94010f948e9f23e21235ef422a191753c65","modified":1692104384030},{"_id":"themes/next-reloaded/languages/zh-TW.yml","hash":"8c09da7c4ec3fca2c6ee897b2eea260596a2baa1","modified":1692104384014},{"_id":"themes/next-reloaded/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1692104384602},{"_id":"themes/next-reloaded/languages/zh-CN.yml","hash":"a1f15571ee7e1e84e3cc0985c3ec4ba1a113f6f8","modified":1692104384042},{"_id":"themes/next-reloaded/.github/ISSUE_TEMPLATE/feature-request.md","hash":"12d99fb8b62bd9e34d9672f306c9ae4ace7e053e","modified":1692104384882},{"_id":"themes/next-reloaded/.github/ISSUE_TEMPLATE/bug-report.md","hash":"c3e6b8196c983c40fd140bdeca012d03e6e86967","modified":1692104384898},{"_id":"themes/next-reloaded/.github/ISSUE_TEMPLATE/question.md","hash":"53df7d537e26aaf062d70d86835c5fd8f81412f3","modified":1692104384854},{"_id":"themes/next-reloaded/.github/ISSUE_TEMPLATE/other.md","hash":"d3efc0df0275c98440e69476f733097916a2d579","modified":1692104384870},{"_id":"themes/next-reloaded/languages/fa.yml","hash":"3676b32fda37e122f3c1a655085a1868fb6ad66b","modified":1692104384230},{"_id":"themes/next-reloaded/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1692104384514},{"_id":"themes/next-reloaded/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"94dc3404ccb0e5f663af2aa883c1af1d6eae553d","modified":1692104384586},{"_id":"themes/next-reloaded/docs/ru/README.md","hash":"85dd68ed1250897a8e4a444a53a68c1d49eb7e11","modified":1692104384498},{"_id":"themes/next-reloaded/docs/ru/UPDATE-FROM-5.1.X.md","hash":"5237a368ab99123749d724b6c379415f2c142a96","modified":1692104384482},{"_id":"themes/next-reloaded/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1692104382250},{"_id":"themes/next-reloaded/docs/zh-CN/DATA-FILES.md","hash":"ca1030efdfca5e20f9db2e7a428998e66a24c0d0","modified":1692104384402},{"_id":"themes/next-reloaded/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"fb23b85db6f7d8279d73ae1f41631f92f64fc864","modified":1692104384430},{"_id":"themes/next-reloaded/docs/MATH.md","hash":"d645b025ec7fb9fbf799b9bb76af33b9f5b9ed93","modified":1692104384546},{"_id":"themes/next-reloaded/docs/ru/DATA-FILES.md","hash":"0bd2d696f62a997a11a7d84fec0130122234174e","modified":1692104384530},{"_id":"themes/next-reloaded/docs/zh-CN/README.md","hash":"c038629ff8f3f24e8593c4c8ecf0bef3a35c750d","modified":1692104384346},{"_id":"themes/next-reloaded/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1692104384390},{"_id":"themes/next-reloaded/docs/zh-CN/CONTRIBUTING.md","hash":"d3f03be036b75dc71cf3c366cd75aee7c127c874","modified":1692104384418},{"_id":"themes/next-reloaded/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"d9ce7331c1236bbe0a551d56cef2405e47e65325","modified":1692104384330},{"_id":"themes/next-reloaded/layout/_macro/post.swig","hash":"71e4dc5a56cbc403d9785526f7719d824f4c8911","modified":1692104383870},{"_id":"themes/next-reloaded/layout/_macro/post-collapse.swig","hash":"c4ec5822d644ddcedf2401837e6f6e6d3b63fbcd","modified":1692104383890},{"_id":"themes/next-reloaded/layout/_partials/comments.swig","hash":"db6ab5421b5f4b7cb32ac73ad0e053fdf065f83e","modified":1692104383838},{"_id":"themes/next-reloaded/layout/_macro/sidebar.swig","hash":"71655ca21907e9061b6e8ac52d0d8fbf54d0062b","modified":1692104383854},{"_id":"themes/next-reloaded/layout/_partials/footer.swig","hash":"af2d688f688923080aaf8f20be33cfda629797ea","modified":1692104383814},{"_id":"themes/next-reloaded/layout/_partials/languages.swig","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1692104383642},{"_id":"themes/next-reloaded/docs/zh-CN/MATH.md","hash":"b92585d251f1f9ebe401abb5d932cb920f9b8b10","modified":1692104384362},{"_id":"themes/next-reloaded/layout/_partials/pagination.swig","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1692104383602},{"_id":"themes/next-reloaded/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1692104383470},{"_id":"themes/next-reloaded/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1692104383454},{"_id":"themes/next-reloaded/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1692104383346},{"_id":"themes/next-reloaded/layout/_scripts/pjax.swig","hash":"4d2c93c66e069852bb0e3ea2e268d213d07bfa3f","modified":1692104383406},{"_id":"themes/next-reloaded/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1692104383442},{"_id":"themes/next-reloaded/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"8b18f84503a361fc712b0fe4d4568e2f086ca97d","modified":1692104384374},{"_id":"themes/next-reloaded/layout/_third-party/baidu-push.swig","hash":"8627c8c8b031ecee16c522433b66fa4d6979b8ea","modified":1692104383234},{"_id":"themes/next-reloaded/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1692104383330},{"_id":"themes/next-reloaded/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1692104383038},{"_id":"themes/next-reloaded/scripts/helpers/engine.js","hash":"22d77bd511fc7c1bbd12339d65004ed5bfb0713c","modified":1692104382330},{"_id":"themes/next-reloaded/layout/_third-party/quicklink.swig","hash":"311e5eceec9e949f1ea8d623b083cec0b8700ff2","modified":1692104382978},{"_id":"themes/next-reloaded/scripts/events/index.js","hash":"bf5e93f9209d111a014a7a6a17e86c05be552d13","modified":1692104382666},{"_id":"themes/next-reloaded/scripts/helpers/font.js","hash":"40cf00e9f2b7aa6e5f33d412e03ed10304b15fd7","modified":1692104382310},{"_id":"themes/next-reloaded/scripts/helpers/next-url.js","hash":"958e86b2bd24e4fdfcbf9ce73e998efe3491a71f","modified":1692104382266},{"_id":"themes/next-reloaded/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1692104382426},{"_id":"themes/next-reloaded/scripts/filters/locals.js","hash":"b193a936ee63451f09f8886343dcfdca577c0141","modified":1692104382386},{"_id":"themes/next-reloaded/scripts/helpers/next-config.js","hash":"5e11f30ddb5093a88a687446617a46b048fa02e5","modified":1692104382290},{"_id":"themes/next-reloaded/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1692104382406},{"_id":"themes/next-reloaded/scripts/tags/button.js","hash":"946dd7beede408d1f090d5e9774d74763828b97c","modified":1692104382226},{"_id":"themes/next-reloaded/layout/_third-party/rating.swig","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1692104382958},{"_id":"themes/next-reloaded/scripts/filters/post.js","hash":"d86849559ae54a4098aef4e2ab9dc8f99a1d186c","modified":1692104382350},{"_id":"themes/next-reloaded/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1692104382370},{"_id":"themes/next-reloaded/scripts/tags/caniuse.js","hash":"94e0bbc7999b359baa42fa3731bdcf89c79ae2b3","modified":1692104382206},{"_id":"themes/next-reloaded/scripts/tags/pdf.js","hash":"8c613b39e7bff735473e35244b5629d02ee20618","modified":1692104382086},{"_id":"themes/next-reloaded/scripts/tags/tabs.js","hash":"00ca6340d4fe0ccdae7525373e4729117775bbfa","modified":1692104382066},{"_id":"themes/next-reloaded/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1692104382102},{"_id":"themes/next-reloaded/scripts/tags/center-quote.js","hash":"0f133f27b61e8351cfd0959ba8a1b8551a9a8cc6","modified":1692104382186},{"_id":"themes/next-reloaded/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1692104382046},{"_id":"themes/next-reloaded/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1692104382122},{"_id":"themes/next-reloaded/source/css/_mixins.styl","hash":"b79ff3debd5709397b122292fc7e551ae9d40782","modified":1692104380962},{"_id":"themes/next-reloaded/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1692104380546},{"_id":"themes/next-reloaded/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"34b88784ec120dfdc20fa82aadeb5f64ef614d14","modified":1692104384446},{"_id":"themes/next-reloaded/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1692104380538},{"_id":"themes/next-reloaded/source/css/main.styl","hash":"a3a3bbb5a973052f0186b3523911cb2539ff7b88","modified":1692104382026},{"_id":"themes/next-reloaded/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1692104380510},{"_id":"themes/next-reloaded/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1692104380502},{"_id":"themes/next-reloaded/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1692104380474},{"_id":"themes/next-reloaded/source/css/_colors.styl","hash":"19c836f367977fb712b9868f3281ff5d757a8d5c","modified":1692104382010},{"_id":"themes/next-reloaded/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1692104380490},{"_id":"themes/next-reloaded/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1692104380458},{"_id":"themes/next-reloaded/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1692104380442},{"_id":"themes/next-reloaded/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1692104380398},{"_id":"themes/next-reloaded/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1692104380426},{"_id":"themes/next-reloaded/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1692104380414},{"_id":"themes/next-reloaded/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1692104382142},{"_id":"themes/next-reloaded/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1692104380386},{"_id":"themes/next-reloaded/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1692104380370},{"_id":"themes/next-reloaded/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1692104380358},{"_id":"themes/next-reloaded/source/js/algolia-search.js","hash":"23cc3c013185eb97ef347c3b4c92d928f2f3398f","modified":1692104380326},{"_id":"themes/next-reloaded/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1692104380346},{"_id":"themes/next-reloaded/source/js/bookmark.js","hash":"a00945ff886e9f6f835731cdaf29a3a3727c8877","modified":1692104380310},{"_id":"themes/next-reloaded/source/js/next-boot.js","hash":"a22eeb6048ddd6b9224c8a671cbcfa303a2f7a1a","modified":1692104380250},{"_id":"themes/next-reloaded/source/js/local-search.js","hash":"b42bd1c883ce91db8632d96e0f0e062cb6b73adc","modified":1692104380294},{"_id":"themes/next-reloaded/source/images/author.jpg","hash":"5a516e4fb2200dfd03fe7811e57ce04f911acc8a","modified":1692104380526},{"_id":"themes/next-reloaded/source/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1692104380270},{"_id":"themes/next-reloaded/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1692104380174},{"_id":"themes/next-reloaded/layout/_partials/head/head-unique.swig","hash":"000bad572d76ee95d9c0a78f9ccdc8d97cc7d4b4","modified":1692104383750},{"_id":"themes/next-reloaded/layout/_partials/header/menu-item.swig","hash":"12aeb9ee0d1d49d347f82a91e6bab568e1b59037","modified":1692104383686},{"_id":"themes/next-reloaded/source/js/utils.js","hash":"95c5d37aa06521675afcf8619cfc5dbba3d2e18a","modified":1692104380202},{"_id":"themes/next-reloaded/layout/_partials/head/head.swig","hash":"1ea12d4b9490d9065ebf1b8739b90ce5defd6398","modified":1692104383726},{"_id":"themes/next-reloaded/layout/_partials/header/menu.swig","hash":"958e097790551c9520426a1233add03515034f35","modified":1692104383670},{"_id":"themes/next-reloaded/layout/_partials/header/index.swig","hash":"7dbe93b8297b746afb89700b4d29289556e85267","modified":1692104383698},{"_id":"themes/next-reloaded/layout/_partials/page/page-header.swig","hash":"9b7a66791d7822c52117fe167612265356512477","modified":1692104383614},{"_id":"themes/next-reloaded/layout/_partials/header/sub-menu.swig","hash":"ae2261bea836581918a1c2b0d1028a78718434e0","modified":1692104383658},{"_id":"themes/next-reloaded/layout/_partials/header/brand.swig","hash":"c70f8e71e026e878a4e9d5ab3bbbf9b0b23c240c","modified":1692104383710},{"_id":"themes/next-reloaded/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1692104383562},{"_id":"themes/next-reloaded/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1692104383630},{"_id":"themes/next-reloaded/layout/_partials/post/post-copyright.swig","hash":"94d54b0c65d504f772af1e62424952e092b6c21d","modified":1692104383590},{"_id":"themes/next-reloaded/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1692104383550},{"_id":"themes/next-reloaded/layout/_partials/search/index.swig","hash":"2be50f9bfb1c56b85b3b6910a7df27f51143632c","modified":1692104383510},{"_id":"themes/next-reloaded/layout/_partials/search/algolia-search.swig","hash":"48430bd03b8f19c9b8cdb2642005ed67d56c6e0b","modified":1692104383522},{"_id":"themes/next-reloaded/layout/_partials/post/post-followme.swig","hash":"12cd9adb0c33adc484201f9e8a4e64ccf3011bae","modified":1692104383574},{"_id":"themes/next-reloaded/layout/_partials/post/post-reward.swig","hash":"2b1a73556595c37951e39574df5a3f20b2edeaef","modified":1692104383538},{"_id":"themes/next-reloaded/layout/_partials/search/localsearch.swig","hash":"f48a6a8eba04eb962470ce76dd731e13074d4c45","modified":1692104383498},{"_id":"themes/next-reloaded/layout/_partials/sidebar/site-overview.swig","hash":"ec20ff43845723e0ac2a245047c7a7e5aead6e88","modified":1692104383482},{"_id":"themes/next-reloaded/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1692104383370},{"_id":"themes/next-reloaded/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1692104383378},{"_id":"themes/next-reloaded/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1692104383358},{"_id":"themes/next-reloaded/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1692104383382},{"_id":"themes/next-reloaded/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1692104383314},{"_id":"themes/next-reloaded/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1692104383266},{"_id":"themes/next-reloaded/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1692104383246},{"_id":"themes/next-reloaded/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1692104383294},{"_id":"themes/next-reloaded/layout/_third-party/chat/chatra.swig","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1692104383214},{"_id":"themes/next-reloaded/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1692104383190},{"_id":"themes/next-reloaded/layout/_scripts/pages/schedule.swig","hash":"077b5d66f6309f2e7dcf08645058ff2e03143e6c","modified":1692104383430},{"_id":"themes/next-reloaded/layout/_third-party/comments/disqusjs.swig","hash":"82f5b6822aa5ec958aa987b101ef860494c6cf1f","modified":1692104383122},{"_id":"themes/next-reloaded/layout/_third-party/comments/changyan.swig","hash":"f39a5bf3ce9ee9adad282501235e0c588e4356ec","modified":1692104383178},{"_id":"themes/next-reloaded/layout/_third-party/comments/disqus.swig","hash":"b14908644225d78c864cd0a9b60c52407de56183","modified":1692104383150},{"_id":"themes/next-reloaded/layout/_third-party/comments/valine.swig","hash":"be0a8eccf1f6dc21154af297fc79555343031277","modified":1692104383058},{"_id":"themes/next-reloaded/layout/_third-party/comments/gitalk.swig","hash":"d6ceb70648555338a80ae5724b778c8c58d7060d","modified":1692104383102},{"_id":"themes/next-reloaded/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1692104383026},{"_id":"themes/next-reloaded/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1692104383014},{"_id":"themes/next-reloaded/layout/_third-party/comments/livere.swig","hash":"f7a9eca599a682479e8ca863db59be7c9c7508c8","modified":1692104383082},{"_id":"themes/next-reloaded/layout/_third-party/search/algolia-search.swig","hash":"d35a999d67f4c302f76fdf13744ceef3c6506481","modified":1692104382942},{"_id":"themes/next-reloaded/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1692104382914},{"_id":"themes/next-reloaded/layout/_third-party/math/mathjax.swig","hash":"ecf751321e799f0fb3bf94d049e535130e2547aa","modified":1692104382998},{"_id":"themes/next-reloaded/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1692104382926},{"_id":"themes/next-reloaded/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1692104382838},{"_id":"themes/next-reloaded/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1692104382878},{"_id":"themes/next-reloaded/layout/_third-party/statistics/lean-analytics.swig","hash":"d56d5af427cdfecc33a0f62ee62c056b4e33d095","modified":1692104382822},{"_id":"themes/next-reloaded/layout/_third-party/statistics/firestore.swig","hash":"b26ac2bfbe91dd88267f8b96aee6bb222b265b7a","modified":1692104382862},{"_id":"themes/next-reloaded/layout/_third-party/statistics/busuanzi-counter.swig","hash":"d7258d02bcf0dac6c0fd8377c0909ddecb09d1d4","modified":1692104382894},{"_id":"themes/next-reloaded/layout/_third-party/tags/pdf.swig","hash":"d30b0e255a8092043bac46441243f943ed6fb09b","modified":1692104382774},{"_id":"themes/next-reloaded/layout/_third-party/tags/mermaid.swig","hash":"f3c43664a071ff3c0b28bd7e59b5523446829576","modified":1692104382798},{"_id":"themes/next-reloaded/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1692104382606},{"_id":"themes/next-reloaded/scripts/events/lib/config.js","hash":"d34c6040b13649714939f59be5175e137de65ede","modified":1692104382646},{"_id":"themes/next-reloaded/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1692104382626},{"_id":"themes/next-reloaded/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1692104382546},{"_id":"themes/next-reloaded/scripts/filters/comment/changyan.js","hash":"1f20213af8da3127701e6bb9da995e5c91be2051","modified":1692104382586},{"_id":"themes/next-reloaded/scripts/filters/comment/common.js","hash":"0803d4f4d3d02c24417c163ad0b27b60fda79250","modified":1692104382566},{"_id":"themes/next-reloaded/scripts/filters/comment/disqus.js","hash":"19cbd24880d0fbbd4d5698cd54da598f03b942da","modified":1692104382526},{"_id":"themes/next-reloaded/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1692104382486},{"_id":"themes/next-reloaded/scripts/filters/comment/valine.js","hash":"6a72b5928cdab9526a288177991e4b2aedd028cf","modified":1692104382450},{"_id":"themes/next-reloaded/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1692104380610},{"_id":"themes/next-reloaded/source/css/_variables/Mist.styl","hash":"f70be8e229da7e1715c11dd0e975a2e71e453ac8","modified":1692104380594},{"_id":"themes/next-reloaded/source/css/_variables/Pisces.styl","hash":"799fdf4f258a51d45d1e2b02fb59b337e46b5b3c","modified":1692104380562},{"_id":"themes/next-reloaded/source/css/_variables/Muse.styl","hash":"62df49459d552bbf73841753da8011a1f5e875c8","modified":1692104380578},{"_id":"themes/next-reloaded/scripts/filters/comment/disqusjs.js","hash":"7f8b92913d21070b489457fa5ed996d2a55f2c32","modified":1692104382502},{"_id":"themes/next-reloaded/source/js/schemes/muse.js","hash":"47c4f60eb7f7dc3303e84914b611dc34827069e1","modified":1692104380230},{"_id":"themes/next-reloaded/source/js/schemes/pisces.js","hash":"3d9d3c14b77044d66be1898a9a934696e9127c82","modified":1692104380222},{"_id":"themes/next-reloaded/scripts/filters/comment/livere.js","hash":"d5fefc31fba4ab0188305b1af1feb61da49fdeb0","modified":1692104382466},{"_id":"themes/next-reloaded/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1692104380134},{"_id":"themes/next-reloaded/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1692104380122},{"_id":"themes/next-reloaded/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1692104380002},{"_id":"themes/next-reloaded/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1692104380110},{"_id":"themes/next-reloaded/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1692104380146},{"_id":"themes/next-reloaded/source/css/_common/components/back-to-top-sidebar.styl","hash":"ca5e70662dcfb261c25191cc5db5084dcf661c76","modified":1692104381994},{"_id":"themes/next-reloaded/source/css/_variables/base.styl","hash":"dae390efcb5da9c021ad7f25fe2d39ff36938cc6","modified":1692104380626},{"_id":"themes/next-reloaded/source/css/_common/components/back-to-top.styl","hash":"a47725574e1bee3bc3b63b0ff2039cc982b17eff","modified":1692104381982},{"_id":"themes/next-reloaded/source/css/_common/components/components.styl","hash":"8e7b57a72e757cf95278239641726bb2d5b869d1","modified":1692104381966},{"_id":"themes/next-reloaded/source/css/_common/outline/outline.styl","hash":"a1690e035b505d28bdef2b4424c13fc6312ab049","modified":1692104381418},{"_id":"themes/next-reloaded/source/css/_common/components/reading-progress.styl","hash":"2e3bf7baf383c9073ec5e67f157d3cb3823c0957","modified":1692104381650},{"_id":"themes/next-reloaded/source/css/_common/outline/mobile.styl","hash":"681d33e3bc85bdca407d93b134c089264837378c","modified":1692104381438},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1692104379950},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/comments.styl","hash":"b1f0fab7344a20ed6748b04065b141ad423cf4d9","modified":1692104381218},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1692104381130},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/base.styl","hash":"220da37051ed5dac9cf7bd126451f6aba4f94d21","modified":1692104381254},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/buttons.styl","hash":"a2e9e00962e43e98ec2614d6d248ef1773bb9b78","modified":1692104381234},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1692104381150},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1692104381118},{"_id":"themes/next-reloaded/scripts/tags/group-pictures.js","hash":"d902fd313e8d35c3cc36f237607c2a0536c9edf1","modified":1692104382166},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/tables.styl","hash":"b3bea92eef0e1fe2e7e294dac2184d16b5b8d666","modified":1692104381102},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/_layout.styl","hash":"bb7ace23345364eb14983e860a7172e1683a4c94","modified":1692104380886},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/_header.styl","hash":"f6516d0f7d89dc7b6c6e143a5af54b926f585d82","modified":1692104380906},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/_posts-expand.styl","hash":"6136da4bbb7e70cec99f5c7ae8c7e74f5e7c261a","modified":1692104380850},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/_header.styl","hash":"f0131db6275ceaecae7e1a6a3798b8f89f6c850d","modified":1692104380826},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1692104380922},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/_menu.styl","hash":"7104b9cef90ca3b140d7a7afcf15540a250218fc","modified":1692104380870},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1692104380978},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1692104379986},{"_id":"themes/next-reloaded/source/css/_schemes/Gemini/index.styl","hash":"7785bd756e0c4acede3a47fec1ed7b55988385a5","modified":1692104380942},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/_sidebar.styl","hash":"2b2e7b5cea7783c9c8bb92655e26a67c266886f0","modified":1692104380790},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1692104380834},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_header.styl","hash":"e282df938bd029f391c466168d0e68389978f120","modified":1692104380698},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_layout.styl","hash":"70a4324b70501132855b5e59029acfc5d3da1ebd","modified":1692104380686},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_menu.styl","hash":"ccb71d732b12acd02ac26ed6bbda4861d027857d","modified":1692104380670},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_sidebar.styl","hash":"e4f958677a75de87ee1caf7e22ba46a0602f22dd","modified":1692104380658},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_sub-menu.styl","hash":"82025c3ad7af12e532e2e81be98deb0a74ff23ac","modified":1692104380642},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1692104380754},{"_id":"themes/next-reloaded/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1692104380098},{"_id":"themes/next-reloaded/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1692104380078},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1692104380774},{"_id":"themes/next-reloaded/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1692104380066},{"_id":"themes/next-reloaded/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1692104381950},{"_id":"themes/next-reloaded/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1692104381938},{"_id":"themes/next-reloaded/source/css/_common/components/pages/schedule.styl","hash":"c1daeb60c23945f745703ac2c3f4bf99d0ea3d95","modified":1692104381906},{"_id":"themes/next-reloaded/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1692104381926},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-collapse.styl","hash":"89f76380091f1be49936c69bac02e984dae5ff87","modified":1692104381882},{"_id":"themes/next-reloaded/source/css/_common/components/pages/tag-cloud.styl","hash":"7ddb7453bf9b85b01bff136e9d10a7f06baac9e8","modified":1692104381894},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-copyright.styl","hash":"f49ca072b5a800f735e8f01fc3518f885951dd8e","modified":1692104381866},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-eof.styl","hash":"902569a9dea90548bec21a823dd3efd94ff7c133","modified":1692104381854},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-expand.styl","hash":"ded41fd9d20a5e8db66aaff7cc50f105f5ef2952","modified":1692104381838},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-gallery.styl","hash":"72d495a88f7d6515af425c12cbc67308a57d88ea","modified":1692104381810},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-followme.styl","hash":"1e4190c10c9e0c9ce92653b0dbcec21754b0b69d","modified":1692104381826},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-header.styl","hash":"66211794e4ed47e779ca81150cef588e0b4f2fc5","modified":1692104381794},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-nav.styl","hash":"796eb941ba0ca03fd5ca6d15a1f6a56afd9aa174","modified":1692104381782},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1692104381706},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1692104381694},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1692104380814},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-reward.styl","hash":"eca4d80dd0df1c3b1bc06bd39e6a4bd6c56198df","modified":1692104381770},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1692104381682},{"_id":"themes/next-reloaded/source/css/_common/components/post/post.styl","hash":"a760ee83ba6216871a9f14c5e56dc9bd0d9e2103","modified":1692104381666},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1692104381634},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/math.styl","hash":"b49e9fbd3c182b8fc066b8c2caf248e3eb748619","modified":1692104381622},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1692104381606},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1692104381574},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/search.styl","hash":"9f0b93d109c9aec79450c8a0cf4a4eab717d674d","modified":1692104381590},{"_id":"themes/next-reloaded/source/css/_common/outline/footer/footer.styl","hash":"454a4aebfabb4469b92a8cbb49f46c49ac9bf165","modified":1692104381562},{"_id":"themes/next-reloaded/source/css/_common/outline/header/bookmark.styl","hash":"e02b1097a72a7d2ddc45ea8d53aa6d77c25ac407","modified":1692104381546},{"_id":"themes/next-reloaded/source/css/_common/outline/header/header.styl","hash":"a793cfff86ad4af818faef04c18013077873f8f0","modified":1692104381514},{"_id":"themes/next-reloaded/source/css/_common/outline/header/github-banner.styl","hash":"e7a9fdb6478b8674b1cdf94de4f8052843fb71d9","modified":1692104381530},{"_id":"themes/next-reloaded/source/css/_common/outline/header/menu.styl","hash":"555762730f1f31451113e8fdc84ec438ea738d90","modified":1692104381482},{"_id":"themes/next-reloaded/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1692104381498},{"_id":"themes/next-reloaded/source/css/_common/outline/header/site-meta.styl","hash":"45a239edca44acecf971d99b04f30a1aafbf6906","modified":1692104381466},{"_id":"themes/next-reloaded/source/css/_common/outline/header/site-nav.styl","hash":"b2fc519828fe89a1f8f03ff7b809ad68cd46f3d7","modified":1692104381454},{"_id":"themes/next-reloaded/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1692104381406},{"_id":"themes/next-reloaded/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"44487d9ab290dc97871fa8dd4487016deb56e123","modified":1692104381374},{"_id":"themes/next-reloaded/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"fa0222197b5eee47e18ac864cdc6eac75678b8fe","modified":1692104381390},{"_id":"themes/next-reloaded/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1692104381346},{"_id":"themes/next-reloaded/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"a960a2dd587b15d3b3fe1b59525d6fa971c6a6ec","modified":1692104381334},{"_id":"themes/next-reloaded/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"a05a4031e799bc864a4536f9ef61fe643cd421af","modified":1692104381314},{"_id":"themes/next-reloaded/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1692104381298},{"_id":"themes/next-reloaded/source/css/_common/outline/sidebar/site-state.styl","hash":"2a47f8a6bb589c2fb635e6c1e4a2563c7f63c407","modified":1692104381266},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/_menu.styl","hash":"5e644b1303ab6dcd1b65ee0fd6b91309b04ce64d","modified":1692104380802},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"f71a3e86c05ea668b008cf05a81f67d92b6d65e4","modified":1692104381206},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/highlight/highlight.styl","hash":"35c871a809afa8306c8cde13651010e282548bc6","modified":1692104381178},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1692104381162},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1692104381190},{"_id":"themes/next-reloaded/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"a237c290e8934d1a8cbbf22b3f30503d9663021d","modified":1692104381362},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"709d10f763e357e1472d6471f8be384ec9e2d983","modified":1692104381066},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/tags/label.styl","hash":"d7fce4b51b5f4b7c31d93a9edb6c6ce740aa0d6b","modified":1692104381050},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/tags/note.styl","hash":"9b3cce30c58e57b59e45d3f668a71a4129d3a8e4","modified":1692104381038},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1692104381022},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/tags/tabs.styl","hash":"f23670f1d8e749f3e83766d446790d8fd9620278","modified":1692104381010},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1692104380994},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"7213e3d0ad7c95717ecd4e701d6ee9248ef2bf9f","modified":1692104381086},{"_id":"themes/next-reloaded/source/css/_common/outline/sidebar/sidebar.styl","hash":"a9cd93c36bae5af9223e7804963096274e8a4f03","modified":1692104381282},{"_id":"themes/next-reloaded/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1692104380034},{"_id":"themes/next-reloaded/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1692104380018},{"_id":"themes/next-reloaded/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1692104380050},{"_id":"public/about/index.html","hash":"7659714071da20329967b9f4b0452cc628ce7493","modified":1692108025172},{"_id":"public/categories/index.html","hash":"a56ffc97e9af6747f854f294c0b42d4f618209ac","modified":1692108025172},{"_id":"public/archives/page/3/index.html","hash":"13e384ba3cc0301142d710a63213d328e841d1d7","modified":1692108025172},{"_id":"public/archives/2021/page/3/index.html","hash":"4d8bd01f3ab1fa4d8d564346e77bb1026477c0ee","modified":1692108025172},{"_id":"public/archives/2021/04/index.html","hash":"1b135ff29f611ed609aa479342c2d2020668baa1","modified":1692108025172},{"_id":"public/archives/2021/05/index.html","hash":"bc6cf100edde8e80b0d508e9b7daa1ef9dbe9fc2","modified":1692108025172},{"_id":"public/archives/2023/index.html","hash":"b751e54d058ee462d30d0b41b9e01710d861e253","modified":1692108025172},{"_id":"public/archives/2021/07/index.html","hash":"8de864faba9249448e406d3a77ae90af9fff252a","modified":1692108025172},{"_id":"public/archives/2021/06/index.html","hash":"fc4ba6620db1acf688cd82435e9ee741551fc5b8","modified":1692108025172},{"_id":"public/archives/2023/08/index.html","hash":"84aca333a3821444cc5eccfb13f41a48bdefd41a","modified":1692108025172},{"_id":"public/categories/汽车电子/index.html","hash":"30e877f8eb69674d5ba69d5b1683974b6b40eee1","modified":1692108025172},{"_id":"public/categories/Hexo/index.html","hash":"a5cddfaea30b21ca162c02fb34a3773aa6952ae1","modified":1692108025172},{"_id":"public/categories/Linux/index.html","hash":"2a1248ffde61649a975e241bd68babf0572b0ec9","modified":1692108025172},{"_id":"public/categories/Python/index.html","hash":"82c1bd1d1f659863de71eb379c88476f1b81de6d","modified":1692108025172},{"_id":"public/categories/C-C/index.html","hash":"1a5637b6fc33222468f3f050c85de8af219d9113","modified":1692108025172},{"_id":"public/tags/git-linux/index.html","hash":"e5f4373744fb3a1d1993ed75790a23768545c072","modified":1692108025172},{"_id":"public/tags/linux/index.html","hash":"e398bb45c3c1ad96ab888e21c0b4a4e7fcdc8f99","modified":1692108025172},{"_id":"public/2023/08/15/Github Page + Hexo 搭建个人博客/index.html","hash":"e35ea546298df460b07fb928456731448937530f","modified":1692108025172},{"_id":"public/2021/07/04/Selenium的使用/index.html","hash":"1450ad647fa4cb592841b7c9e976357db6ee15b2","modified":1692108025172},{"_id":"public/2021/07/04/Linux下配置Selenium/index.html","hash":"898770b8824b56dd446fb8387284601c725890d1","modified":1692108025172},{"_id":"public/2021/06/25/Python学习-网络编程/index.html","hash":"d74a9caf537b27e4c1fed7169eb7de7595ac95b5","modified":1692108025172},{"_id":"public/2021/06/23/Python学习-多线程和多进程/index.html","hash":"949006e26f2ab1bb614bda4f85add6deb3326f81","modified":1692108025172},{"_id":"public/2021/06/21/Python学习-从面向对象开始/index.html","hash":"a5e16a61854a426a6c54ba92a23034536f8d74e1","modified":1692108025172},{"_id":"public/2021/06/20/Linux安装Jupyter并且远程访问/index.html","hash":"3f3f8d3b975ec07620086a256bbb1111f6e4265a","modified":1692108025172},{"_id":"public/2021/06/18/自动驾驶基础-AEB/index.html","hash":"605237d31a3c98f5fd99ff0a6ed4aa91ba87632c","modified":1692108025172},{"_id":"public/2021/06/14/Linux系统编程-守护进程/index.html","hash":"68503b44e6b8cdc3eae8fb3b7c81c9c91aa2ba2d","modified":1692108025172},{"_id":"public/2021/06/10/Linux系统编程-进程控制/index.html","hash":"b364e92e09cfbb27e80fdcdc84746ee78dbbaaa9","modified":1692108025172},{"_id":"public/2021/06/13/Linux系统编程-进程间通讯/index.html","hash":"061f23c6bd874f7a3e44e6d6eed54aa499cd67e8","modified":1692108025172},{"_id":"public/2021/05/30/gdb调试方法/index.html","hash":"345e8a1322aad8a790bcc14b585c5d0e8dac6379","modified":1692108025172},{"_id":"public/2021/06/06/数据结构（C语言版）/index.html","hash":"74a4a5f479414baa476f9e19b5280f904c895657","modified":1692108025172},{"_id":"public/2021/05/29/CANoe系列教程-分析窗口-State Tracker/index.html","hash":"5a88c1994cdb4fe32cf40fa43ab6413ba699be6a","modified":1692108025172},{"_id":"public/2021/05/29/CAN总线知识串联/index.html","hash":"9e8e7841bda716f99491c66a882dd84d15140fe9","modified":1692108025172},{"_id":"public/2021/05/28/CANoe系列教程-分析窗口-Graphic/index.html","hash":"16c8d27ff3066a64714c95afa182492769cbc8bd","modified":1692108025172},{"_id":"public/2021/05/27/CANoe系列教程-分析窗口-Trace/index.html","hash":"f00747c07be1e82517b100fc9e258342c0c53bbc","modified":1692108025172},{"_id":"public/2021/05/27/CANoe系列教程-工程创建与通道配置/index.html","hash":"27bbee267061c7f95d351777a41be199da1278e4","modified":1692108025172},{"_id":"public/2021/05/25/CAN总线基本知识/index.html","hash":"19741c261f8e402d046b69a43fd04259dbe004bc","modified":1692108025172},{"_id":"public/2021/05/01/Ubuntu配置Git并利用Gitee（码云）进行项目及代码的管理/index.html","hash":"819a39511644c754bbd70365613f6d978f400ecf","modified":1692108025172},{"_id":"public/2021/04/26/新安装Ubuntu配置过程/index.html","hash":"632430c1308863bab6b5563b7f3e60b133a18b89","modified":1692108025172},{"_id":"public/2021/04/26/虚拟机安装Ubuntu，关闭动画精简软件等/index.html","hash":"c48cf48beb6153be226771507b47860489481060","modified":1692108025172},{"_id":"public/archives/page/2/index.html","hash":"475e3a7a18094876eed92a77d7a3c4762dde832c","modified":1692108025172},{"_id":"public/archives/index.html","hash":"62b1520074d08df381cb2a44cf0a6557b86a07db","modified":1692108025172},{"_id":"public/archives/2021/index.html","hash":"01d78c87c54d1907f506d3f13b8ebf67808ad7fc","modified":1692108025172},{"_id":"public/archives/2021/page/2/index.html","hash":"8a1716dc2a986fdf84b73f56a69103f0bd5162ce","modified":1692108025172},{"_id":"public/index.html","hash":"61fb6d6d177c94881061489607e13ab7eeb92349","modified":1692108025172},{"_id":"public/page/2/index.html","hash":"b595336f7c1d5a10d6a4a260df442cb9ba621c92","modified":1692108025172},{"_id":"public/page/3/index.html","hash":"27d565a561297e01ad2b384f2684d6e954644378","modified":1692108025172},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1692108025172},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1692108025172},{"_id":"public/images/author.jpg","hash":"5a516e4fb2200dfd03fe7811e57ce04f911acc8a","modified":1692108025172},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1692108025172},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1692108025172},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1692108025172},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1692108025172},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1692108025172},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1692108025172},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1692108025172},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1692108025172},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1692108025172},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1692108025172},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1692108025172},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1692108025172},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1692108025172},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1692108025172},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1692108025172},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1692108025172},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1692108025172},{"_id":"public/js/algolia-search.js","hash":"23cc3c013185eb97ef347c3b4c92d928f2f3398f","modified":1692108025172},{"_id":"public/js/bookmark.js","hash":"a00945ff886e9f6f835731cdaf29a3a3727c8877","modified":1692108025172},{"_id":"public/js/local-search.js","hash":"b42bd1c883ce91db8632d96e0f0e062cb6b73adc","modified":1692108025172},{"_id":"public/js/next-boot.js","hash":"a22eeb6048ddd6b9224c8a671cbcfa303a2f7a1a","modified":1692108025172},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1692108025172},{"_id":"public/js/utils.js","hash":"95c5d37aa06521675afcf8619cfc5dbba3d2e18a","modified":1692108025172},{"_id":"public/js/schemes/muse.js","hash":"47c4f60eb7f7dc3303e84914b611dc34827069e1","modified":1692108025172},{"_id":"public/js/schemes/pisces.js","hash":"3d9d3c14b77044d66be1898a9a934696e9127c82","modified":1692108025172},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1692108025172},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1692108025172},{"_id":"public/css/main.css","hash":"22efb7852e4583aa1241afdb364d8d473491dee0","modified":1692108025172},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1692108025172},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1692108025172},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1692108025172},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1692108025172},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1692108025172}],"Category":[{"name":"汽车电子","_id":"cllcdfgk30004i7jxdk7m4uod"},{"name":"Hexo","_id":"cllcdfgkd000hi7jx1lxi84qx"},{"name":"Linux","_id":"cllcdfgkf000mi7jx007u59c1"},{"name":"Python","_id":"cllcdfgkm000zi7jx0hvz0qlg"},{"name":"C/C++","_id":"cllcdfgks001li7jx8cif4d66"}],"Data":[],"Page":[{"title":"About","date":"2021-10-05T07:24:53.000Z","_content":"\n一个兴趣使然的无名小站\n","source":"about/index.md","raw":"---\ntitle: About\ndate: 2021-10-05 15:24:53\n---\n\n一个兴趣使然的无名小站\n","updated":"2023-08-15T12:59:46.950Z","path":"about/index.html","comments":1,"layout":"page","_id":"cllcdfgjw0000i7jxhkamfv5o","content":"<p>一个兴趣使然的无名小站</p>\n","site":{"data":{}},"excerpt":"","more":"<p>一个兴趣使然的无名小站</p>\n"},{"title":"categories","date":"2021-10-05T07:08:58.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2021-10-05 15:08:58\ntype: \"categories\"\n---\n","updated":"2023-08-15T12:59:46.938Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cllcdfgk20002i7jx56efgvbv","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"CANoe系列教程-分析窗口-Graphic","date":"2021-05-28T13:25:16.000Z","_content":"\n\nGraphic窗口是以信号为导向展示和分析曲线的窗口\n\n## Graphic窗口的打开\n\n1、从主菜单栏中的 Analysis \\-> Graphics新建  \n2、从Measurement Setup中的Graphics模块打开即可\n<!--more-->\n\n## 添加信号\n\n1、从Symbol Explorer将信号拖拽至Graphics中  \n2、从Trace窗口中将信号拖拽至Graphics中  \n3、在Graphics窗口左侧信号栏中右键选择Add Signals添加  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210528211953578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)\n\n## Graphic工具栏中常用工具的使用\n\n如测量光标、差分光标、比例调整、日志导入导出等  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210528212356484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)","source":"_posts/CANoe系列教程-分析窗口-Graphic.md","raw":"---\ntitle: CANoe系列教程-分析窗口-Graphic\ndate: 2021-05-28 21:25:16\ntags: \ncategories: 汽车电子\n---\n\n\nGraphic窗口是以信号为导向展示和分析曲线的窗口\n\n## Graphic窗口的打开\n\n1、从主菜单栏中的 Analysis \\-> Graphics新建  \n2、从Measurement Setup中的Graphics模块打开即可\n<!--more-->\n\n## 添加信号\n\n1、从Symbol Explorer将信号拖拽至Graphics中  \n2、从Trace窗口中将信号拖拽至Graphics中  \n3、在Graphics窗口左侧信号栏中右键选择Add Signals添加  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210528211953578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)\n\n## Graphic工具栏中常用工具的使用\n\n如测量光标、差分光标、比例调整、日志导入导出等  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210528212356484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)","slug":"CANoe系列教程-分析窗口-Graphic","published":1,"updated":"2023-08-15T12:59:46.926Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllcdfgjz0001i7jx1szg280h","content":"<p>Graphic窗口是以信号为导向展示和分析曲线的窗口</p>\n<h2 id=\"Graphic窗口的打开\"><a href=\"#Graphic窗口的打开\" class=\"headerlink\" title=\"Graphic窗口的打开\"></a>Graphic窗口的打开</h2><p>1、从主菜单栏中的 Analysis -&gt; Graphics新建<br>2、从Measurement Setup中的Graphics模块打开即可</p>\n<span id=\"more\"></span>\n\n<h2 id=\"添加信号\"><a href=\"#添加信号\" class=\"headerlink\" title=\"添加信号\"></a>添加信号</h2><p>1、从Symbol Explorer将信号拖拽至Graphics中<br>2、从Trace窗口中将信号拖拽至Graphics中<br>3、在Graphics窗口左侧信号栏中右键选择Add Signals添加<br><img src=\"https://img-blog.csdnimg.cn/20210528211953578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"Graphic工具栏中常用工具的使用\"><a href=\"#Graphic工具栏中常用工具的使用\" class=\"headerlink\" title=\"Graphic工具栏中常用工具的使用\"></a>Graphic工具栏中常用工具的使用</h2><p>如测量光标、差分光标、比例调整、日志导入导出等<br><img src=\"https://img-blog.csdnimg.cn/20210528212356484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n","site":{"data":{}},"excerpt":"<p>Graphic窗口是以信号为导向展示和分析曲线的窗口</p>\n<h2 id=\"Graphic窗口的打开\"><a href=\"#Graphic窗口的打开\" class=\"headerlink\" title=\"Graphic窗口的打开\"></a>Graphic窗口的打开</h2><p>1、从主菜单栏中的 Analysis -&gt; Graphics新建<br>2、从Measurement Setup中的Graphics模块打开即可</p>","more":"<h2 id=\"添加信号\"><a href=\"#添加信号\" class=\"headerlink\" title=\"添加信号\"></a>添加信号</h2><p>1、从Symbol Explorer将信号拖拽至Graphics中<br>2、从Trace窗口中将信号拖拽至Graphics中<br>3、在Graphics窗口左侧信号栏中右键选择Add Signals添加<br><img src=\"https://img-blog.csdnimg.cn/20210528211953578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"Graphic工具栏中常用工具的使用\"><a href=\"#Graphic工具栏中常用工具的使用\" class=\"headerlink\" title=\"Graphic工具栏中常用工具的使用\"></a>Graphic工具栏中常用工具的使用</h2><p>如测量光标、差分光标、比例调整、日志导入导出等<br><img src=\"https://img-blog.csdnimg.cn/20210528212356484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>"},{"title":"CANoe系列教程-分析窗口-State Tracker","date":"2021-05-29T14:13:37.000Z","_content":"\n\nState Tracker（状态追踪）窗口是用来显示比特值和一些状态值，特別适合显示数字输入和输出量，以及状态信息。它可以用来分析系统状态的转换相关的信号和变量，也可以将一些离散的状态如报文的发送、总线的负载等等进行可视化。\n\n## State Tracker窗口的添加\n\n1、状态栏中Analysis \\-> State Tracker添加  \n2、从Measurement Setup中右键Insert State Tracker Window添加  \n<!--more-->\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210529220836964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)\n\n## 添加信号\n\n如Graphic窗口的介绍一样可以通过拖拽和右键的方式添加信号\n\n## 工具栏的使用\n\n如触发条件、颜色高亮等  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210529221153166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)","source":"_posts/CANoe系列教程-分析窗口-State Tracker.md","raw":"---\ntitle: CANoe系列教程-分析窗口-State Tracker\ndate: 2021-05-29 22:13:37\ntags: \ncategories: 汽车电子\n---\n\n\nState Tracker（状态追踪）窗口是用来显示比特值和一些状态值，特別适合显示数字输入和输出量，以及状态信息。它可以用来分析系统状态的转换相关的信号和变量，也可以将一些离散的状态如报文的发送、总线的负载等等进行可视化。\n\n## State Tracker窗口的添加\n\n1、状态栏中Analysis \\-> State Tracker添加  \n2、从Measurement Setup中右键Insert State Tracker Window添加  \n<!--more-->\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210529220836964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)\n\n## 添加信号\n\n如Graphic窗口的介绍一样可以通过拖拽和右键的方式添加信号\n\n## 工具栏的使用\n\n如触发条件、颜色高亮等  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210529221153166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)","slug":"CANoe系列教程-分析窗口-State Tracker","published":1,"updated":"2023-08-15T12:59:46.914Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllcdfgk20003i7jx4mf87130","content":"<p>State Tracker（状态追踪）窗口是用来显示比特值和一些状态值，特別适合显示数字输入和输出量，以及状态信息。它可以用来分析系统状态的转换相关的信号和变量，也可以将一些离散的状态如报文的发送、总线的负载等等进行可视化。</p>\n<h2 id=\"State-Tracker窗口的添加\"><a href=\"#State-Tracker窗口的添加\" class=\"headerlink\" title=\"State Tracker窗口的添加\"></a>State Tracker窗口的添加</h2><p>1、状态栏中Analysis -&gt; State Tracker添加<br>2、从Measurement Setup中右键Insert State Tracker Window添加  </p>\n<span id=\"more\"></span>\n<p><img src=\"https://img-blog.csdnimg.cn/20210529220836964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"添加信号\"><a href=\"#添加信号\" class=\"headerlink\" title=\"添加信号\"></a>添加信号</h2><p>如Graphic窗口的介绍一样可以通过拖拽和右键的方式添加信号</p>\n<h2 id=\"工具栏的使用\"><a href=\"#工具栏的使用\" class=\"headerlink\" title=\"工具栏的使用\"></a>工具栏的使用</h2><p>如触发条件、颜色高亮等<br><img src=\"https://img-blog.csdnimg.cn/20210529221153166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n","site":{"data":{}},"excerpt":"<p>State Tracker（状态追踪）窗口是用来显示比特值和一些状态值，特別适合显示数字输入和输出量，以及状态信息。它可以用来分析系统状态的转换相关的信号和变量，也可以将一些离散的状态如报文的发送、总线的负载等等进行可视化。</p>\n<h2 id=\"State-Tracker窗口的添加\"><a href=\"#State-Tracker窗口的添加\" class=\"headerlink\" title=\"State Tracker窗口的添加\"></a>State Tracker窗口的添加</h2><p>1、状态栏中Analysis -&gt; State Tracker添加<br>2、从Measurement Setup中右键Insert State Tracker Window添加  </p>","more":"<p><img src=\"https://img-blog.csdnimg.cn/20210529220836964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"添加信号\"><a href=\"#添加信号\" class=\"headerlink\" title=\"添加信号\"></a>添加信号</h2><p>如Graphic窗口的介绍一样可以通过拖拽和右键的方式添加信号</p>\n<h2 id=\"工具栏的使用\"><a href=\"#工具栏的使用\" class=\"headerlink\" title=\"工具栏的使用\"></a>工具栏的使用</h2><p>如触发条件、颜色高亮等<br><img src=\"https://img-blog.csdnimg.cn/20210529221153166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>"},{"title":"CANoe系列教程-分析窗口-Trace","date":"2021-05-27T13:31:24.000Z","_content":"\n\nTrace窗口是我们做总线测试分析时最常用的窗口，它能实时显示总线上通信的数据，并且有多种辅助工具便于测试人员的查看分析，与报文的细节查看，过滤等功能\n\n## 创建并打开Trace窗口\n\n1、从主菜单栏中的Trace窗口进入  \n2、从Measurement Setup中的Trace模块打开即可  \n<!--more-->\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210527212047545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)\n\n## 工具栏使用\n\n需对Trace窗口工具栏中以及右键菜单中的选项熟练使用  \n包括细节查看、统计分析、过滤功能，导出保存功能等  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210527212621727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)","source":"_posts/CANoe系列教程-分析窗口-Trace.md","raw":"---\ntitle: CANoe系列教程-分析窗口-Trace\ndate: 2021-05-27 21:31:24\ntags: \ncategories: 汽车电子\n---\n\n\nTrace窗口是我们做总线测试分析时最常用的窗口，它能实时显示总线上通信的数据，并且有多种辅助工具便于测试人员的查看分析，与报文的细节查看，过滤等功能\n\n## 创建并打开Trace窗口\n\n1、从主菜单栏中的Trace窗口进入  \n2、从Measurement Setup中的Trace模块打开即可  \n<!--more-->\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210527212047545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)\n\n## 工具栏使用\n\n需对Trace窗口工具栏中以及右键菜单中的选项熟练使用  \n包括细节查看、统计分析、过滤功能，导出保存功能等  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210527212621727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)","slug":"CANoe系列教程-分析窗口-Trace","published":1,"updated":"2023-08-15T12:59:46.898Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllcdfgk50005i7jx892cetzv","content":"<p>Trace窗口是我们做总线测试分析时最常用的窗口，它能实时显示总线上通信的数据，并且有多种辅助工具便于测试人员的查看分析，与报文的细节查看，过滤等功能</p>\n<h2 id=\"创建并打开Trace窗口\"><a href=\"#创建并打开Trace窗口\" class=\"headerlink\" title=\"创建并打开Trace窗口\"></a>创建并打开Trace窗口</h2><p>1、从主菜单栏中的Trace窗口进入<br>2、从Measurement Setup中的Trace模块打开即可  </p>\n<span id=\"more\"></span>\n<p><img src=\"https://img-blog.csdnimg.cn/20210527212047545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"工具栏使用\"><a href=\"#工具栏使用\" class=\"headerlink\" title=\"工具栏使用\"></a>工具栏使用</h2><p>需对Trace窗口工具栏中以及右键菜单中的选项熟练使用<br>包括细节查看、统计分析、过滤功能，导出保存功能等<br><img src=\"https://img-blog.csdnimg.cn/20210527212621727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n","site":{"data":{}},"excerpt":"<p>Trace窗口是我们做总线测试分析时最常用的窗口，它能实时显示总线上通信的数据，并且有多种辅助工具便于测试人员的查看分析，与报文的细节查看，过滤等功能</p>\n<h2 id=\"创建并打开Trace窗口\"><a href=\"#创建并打开Trace窗口\" class=\"headerlink\" title=\"创建并打开Trace窗口\"></a>创建并打开Trace窗口</h2><p>1、从主菜单栏中的Trace窗口进入<br>2、从Measurement Setup中的Trace模块打开即可  </p>","more":"<p><img src=\"https://img-blog.csdnimg.cn/20210527212047545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"工具栏使用\"><a href=\"#工具栏使用\" class=\"headerlink\" title=\"工具栏使用\"></a>工具栏使用</h2><p>需对Trace窗口工具栏中以及右键菜单中的选项熟练使用<br>包括细节查看、统计分析、过滤功能，导出保存功能等<br><img src=\"https://img-blog.csdnimg.cn/20210527212621727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>"},{"title":"CANoe系列教程-工程创建与通道配置","date":"2021-05-27T12:04:18.000Z","_content":"\n\n# 工程创建与通道配置\n\n点击File中的New按钮选择相应的模板后点击Create Configuration，一个工程文件就创建完成了  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210526210840844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)\n\n# 通道数目和通信波特率配置\n<!--more-->\n\n选择Channel Usage 就可以对总线的通道数进行配置  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210526211036227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)  \n选择Network Hardware对CAN网络的通讯速率进行配置，通讯速率需和连接的ECU保持一致  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210527194905414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)\n\n# 软件通道与硬件通道的映射配置\n\n此步将物理通道和逻辑通道之间进行匹配和映射，选择Driver将物理通道分别分配给模板中的两路CAN网络，此时CANoe已经可以接收来自ECU的报文了  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210527195234173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)![在这里插入图片描述](https://img-blog.csdnimg.cn/20210527195326903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)\n\n# 添加总线通信数据库\n\n选择add时仅添加数据库，选择wizard时可以在添加数据库的同时将仿真节点导入到仿真框图中，此时CANoe就可以通过数据库对节点进行仿真  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210527195942723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)","source":"_posts/CANoe系列教程-工程创建与通道配置.md","raw":"---\ntitle: CANoe系列教程-工程创建与通道配置\ndate: 2021-05-27 20:04:18\ntags: \ncategories: 汽车电子\n---\n\n\n# 工程创建与通道配置\n\n点击File中的New按钮选择相应的模板后点击Create Configuration，一个工程文件就创建完成了  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210526210840844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)\n\n# 通道数目和通信波特率配置\n<!--more-->\n\n选择Channel Usage 就可以对总线的通道数进行配置  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210526211036227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)  \n选择Network Hardware对CAN网络的通讯速率进行配置，通讯速率需和连接的ECU保持一致  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210527194905414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)\n\n# 软件通道与硬件通道的映射配置\n\n此步将物理通道和逻辑通道之间进行匹配和映射，选择Driver将物理通道分别分配给模板中的两路CAN网络，此时CANoe已经可以接收来自ECU的报文了  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210527195234173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)![在这里插入图片描述](https://img-blog.csdnimg.cn/20210527195326903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)\n\n# 添加总线通信数据库\n\n选择add时仅添加数据库，选择wizard时可以在添加数据库的同时将仿真节点导入到仿真框图中，此时CANoe就可以通过数据库对节点进行仿真  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210527195942723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)","slug":"CANoe系列教程-工程创建与通道配置","published":1,"updated":"2023-08-15T12:59:46.882Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllcdfgk60006i7jxfdisgu72","content":"<h1 id=\"工程创建与通道配置\"><a href=\"#工程创建与通道配置\" class=\"headerlink\" title=\"工程创建与通道配置\"></a>工程创建与通道配置</h1><p>点击File中的New按钮选择相应的模板后点击Create Configuration，一个工程文件就创建完成了<br><img src=\"https://img-blog.csdnimg.cn/20210526210840844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"通道数目和通信波特率配置\"><a href=\"#通道数目和通信波特率配置\" class=\"headerlink\" title=\"通道数目和通信波特率配置\"></a>通道数目和通信波特率配置</h1><span id=\"more\"></span>\n\n<p>选择Channel Usage 就可以对总线的通道数进行配置<br><img src=\"https://img-blog.csdnimg.cn/20210526211036227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>选择Network Hardware对CAN网络的通讯速率进行配置，通讯速率需和连接的ECU保持一致<br><img src=\"https://img-blog.csdnimg.cn/20210527194905414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"软件通道与硬件通道的映射配置\"><a href=\"#软件通道与硬件通道的映射配置\" class=\"headerlink\" title=\"软件通道与硬件通道的映射配置\"></a>软件通道与硬件通道的映射配置</h1><p>此步将物理通道和逻辑通道之间进行匹配和映射，选择Driver将物理通道分别分配给模板中的两路CAN网络，此时CANoe已经可以接收来自ECU的报文了<br><img src=\"https://img-blog.csdnimg.cn/20210527195234173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><img src=\"https://img-blog.csdnimg.cn/20210527195326903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"添加总线通信数据库\"><a href=\"#添加总线通信数据库\" class=\"headerlink\" title=\"添加总线通信数据库\"></a>添加总线通信数据库</h1><p>选择add时仅添加数据库，选择wizard时可以在添加数据库的同时将仿真节点导入到仿真框图中，此时CANoe就可以通过数据库对节点进行仿真<br><img src=\"https://img-blog.csdnimg.cn/20210527195942723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"工程创建与通道配置\"><a href=\"#工程创建与通道配置\" class=\"headerlink\" title=\"工程创建与通道配置\"></a>工程创建与通道配置</h1><p>点击File中的New按钮选择相应的模板后点击Create Configuration，一个工程文件就创建完成了<br><img src=\"https://img-blog.csdnimg.cn/20210526210840844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"通道数目和通信波特率配置\"><a href=\"#通道数目和通信波特率配置\" class=\"headerlink\" title=\"通道数目和通信波特率配置\"></a>通道数目和通信波特率配置</h1>","more":"<p>选择Channel Usage 就可以对总线的通道数进行配置<br><img src=\"https://img-blog.csdnimg.cn/20210526211036227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>选择Network Hardware对CAN网络的通讯速率进行配置，通讯速率需和连接的ECU保持一致<br><img src=\"https://img-blog.csdnimg.cn/20210527194905414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"软件通道与硬件通道的映射配置\"><a href=\"#软件通道与硬件通道的映射配置\" class=\"headerlink\" title=\"软件通道与硬件通道的映射配置\"></a>软件通道与硬件通道的映射配置</h1><p>此步将物理通道和逻辑通道之间进行匹配和映射，选择Driver将物理通道分别分配给模板中的两路CAN网络，此时CANoe已经可以接收来自ECU的报文了<br><img src=\"https://img-blog.csdnimg.cn/20210527195234173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><img src=\"https://img-blog.csdnimg.cn/20210527195326903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"添加总线通信数据库\"><a href=\"#添加总线通信数据库\" class=\"headerlink\" title=\"添加总线通信数据库\"></a>添加总线通信数据库</h1><p>选择add时仅添加数据库，选择wizard时可以在添加数据库的同时将仿真节点导入到仿真框图中，此时CANoe就可以通过数据库对节点进行仿真<br><img src=\"https://img-blog.csdnimg.cn/20210527195942723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>"},{"title":"CAN总线基本知识","date":"2021-05-25T12:19:01.000Z","_content":"\n\n# CAN总线基本知识\n\n## 基本概念\n\nCAN 是Contoller Area Network 缩写，即控制域网络，简单来说就是用于汽车不同电子器件之间传输网络。  \nCAN 总线两个主要ISO国际标准是：ISO11898和ISO11519  \n<!--more-->\nISO11898 定义了通信速率为 125 kbps～1 Mbps 的**高速 CAN** 通信标准，属于闭环总线，传输速率可达1Mbps，总线长度 ≤ 40米。  \nISO11519 定义了通信速率为 10～125 kbps 的**低速 CAN**通信标准，属于开环总线，传输速率为40kbps时，总线长度可达1000米。\n\nCAN为了减少外部电磁场对内部点评的干扰，通常采用双绞线\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/8c4f412321d012aca6ec4f23efb4ce5b.png)\n\n### CAN的拓扑结构\n\n下图中，左边是高速CAN总线的拓扑结构，右边是低速CAN总线的拓扑结构。\n\n![[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-CVTFaKPI-1621944831661)(https://gitee.com/xiaolinzinvshen/article-pic/raw/master/2019071514355785.jpeg)]](https://img-blog.csdnimg.cn/20210525202118238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)\n\n### CAN信号表示\n\n在CAN总线上，利用CAN\\_H和CAN\\_L两根线上的电位差来表示CAN信号。CAN总线上的电位差分为显性电平和隐性电平。其中显性电平为逻辑0，隐性电平为逻辑1。  \nISO11898标准（125kbps \\~ 1Mbps）和ISO11519标准（10kbps \\~ 125kbps）中CAN信号的表示分别如下所示：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/5cbf37862a779c69d6737487a755c4d2.png)\n\n### CAN信号传输\n\n发送过程：CAN控制器将CPU传来的信号转为逻辑电平（即逻辑0-显性电平或者逻辑1-隐性电平）。CAN发射器接收逻辑电平之后，再将其转换为差分电平输出到CAN总线上。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/8d8c61b486a991f265908f2404fc03f9.png)\n\n接受过程则刚好相反。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/8b83142a7ce96e17755ee71390e74e39.png)\n\n## CAN通信网络结构\n\n### OSI基本参照模型\n\nOSI参考模型为7层，物理层、数据链路层、网络层、传输层、会话层、表示层和应用层，而CAN通信底层仅使用了物理层和数据链路层\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/e40676e4e27a71ab3ea8eb9418914cad.png)\n\n### CAN总线报文类型\n\nCAN总线的报文类型主要有五种，数据帧、远程帧、错误帧、过载帧、帧间隔  \n下面以数据帧为例进行简单介绍，其帧结构如下图所示，包含七个段：**帧起始、仲裁段、控制段、数据段、CRC段、ACK段、帧结束**\n\n![[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fHkSnbCs-1621944831669)(https://gitee.com/xiaolinzinvshen/article-pic/raw/master/20190715151924879.png)]](https://img-blog.csdnimg.cn/20210525201812946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)\n\n帧起始  \n仲裁域：通过11位标识符对报文优先级进行判断，RTR位判断为数据帧还是远程帧  \n控制域：描述数据域中的字节数  \n数据域：8个字节传递信息，如转速等  \nCRC域：循环冗余校验，避免因物理层传递出现丢失的情况  \nACK域：表明总线中至少有一个节点正确接收到发送的报文，没有发生干扰  \n帧结束","source":"_posts/CAN总线基本知识.md","raw":"---\ntitle: CAN总线基本知识\ndate: 2021-05-25 20:19:01\ntags: \ncategories: 汽车电子\n---\n\n\n# CAN总线基本知识\n\n## 基本概念\n\nCAN 是Contoller Area Network 缩写，即控制域网络，简单来说就是用于汽车不同电子器件之间传输网络。  \nCAN 总线两个主要ISO国际标准是：ISO11898和ISO11519  \n<!--more-->\nISO11898 定义了通信速率为 125 kbps～1 Mbps 的**高速 CAN** 通信标准，属于闭环总线，传输速率可达1Mbps，总线长度 ≤ 40米。  \nISO11519 定义了通信速率为 10～125 kbps 的**低速 CAN**通信标准，属于开环总线，传输速率为40kbps时，总线长度可达1000米。\n\nCAN为了减少外部电磁场对内部点评的干扰，通常采用双绞线\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/8c4f412321d012aca6ec4f23efb4ce5b.png)\n\n### CAN的拓扑结构\n\n下图中，左边是高速CAN总线的拓扑结构，右边是低速CAN总线的拓扑结构。\n\n![[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-CVTFaKPI-1621944831661)(https://gitee.com/xiaolinzinvshen/article-pic/raw/master/2019071514355785.jpeg)]](https://img-blog.csdnimg.cn/20210525202118238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)\n\n### CAN信号表示\n\n在CAN总线上，利用CAN\\_H和CAN\\_L两根线上的电位差来表示CAN信号。CAN总线上的电位差分为显性电平和隐性电平。其中显性电平为逻辑0，隐性电平为逻辑1。  \nISO11898标准（125kbps \\~ 1Mbps）和ISO11519标准（10kbps \\~ 125kbps）中CAN信号的表示分别如下所示：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/5cbf37862a779c69d6737487a755c4d2.png)\n\n### CAN信号传输\n\n发送过程：CAN控制器将CPU传来的信号转为逻辑电平（即逻辑0-显性电平或者逻辑1-隐性电平）。CAN发射器接收逻辑电平之后，再将其转换为差分电平输出到CAN总线上。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/8d8c61b486a991f265908f2404fc03f9.png)\n\n接受过程则刚好相反。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/8b83142a7ce96e17755ee71390e74e39.png)\n\n## CAN通信网络结构\n\n### OSI基本参照模型\n\nOSI参考模型为7层，物理层、数据链路层、网络层、传输层、会话层、表示层和应用层，而CAN通信底层仅使用了物理层和数据链路层\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/e40676e4e27a71ab3ea8eb9418914cad.png)\n\n### CAN总线报文类型\n\nCAN总线的报文类型主要有五种，数据帧、远程帧、错误帧、过载帧、帧间隔  \n下面以数据帧为例进行简单介绍，其帧结构如下图所示，包含七个段：**帧起始、仲裁段、控制段、数据段、CRC段、ACK段、帧结束**\n\n![[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fHkSnbCs-1621944831669)(https://gitee.com/xiaolinzinvshen/article-pic/raw/master/20190715151924879.png)]](https://img-blog.csdnimg.cn/20210525201812946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)\n\n帧起始  \n仲裁域：通过11位标识符对报文优先级进行判断，RTR位判断为数据帧还是远程帧  \n控制域：描述数据域中的字节数  \n数据域：8个字节传递信息，如转速等  \nCRC域：循环冗余校验，避免因物理层传递出现丢失的情况  \nACK域：表明总线中至少有一个节点正确接收到发送的报文，没有发生干扰  \n帧结束","slug":"CAN总线基本知识","published":1,"updated":"2023-08-15T12:59:46.862Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllcdfgk70007i7jx9a5o8eiv","content":"<h1 id=\"CAN总线基本知识\"><a href=\"#CAN总线基本知识\" class=\"headerlink\" title=\"CAN总线基本知识\"></a>CAN总线基本知识</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>CAN 是Contoller Area Network 缩写，即控制域网络，简单来说就是用于汽车不同电子器件之间传输网络。<br>CAN 总线两个主要ISO国际标准是：ISO11898和ISO11519  </p>\n<span id=\"more\"></span>\n<p>ISO11898 定义了通信速率为 125 kbps～1 Mbps 的<strong>高速 CAN</strong> 通信标准，属于闭环总线，传输速率可达1Mbps，总线长度 ≤ 40米。<br>ISO11519 定义了通信速率为 10～125 kbps 的<strong>低速 CAN</strong>通信标准，属于开环总线，传输速率为40kbps时，总线长度可达1000米。</p>\n<p>CAN为了减少外部电磁场对内部点评的干扰，通常采用双绞线</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/8c4f412321d012aca6ec4f23efb4ce5b.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"CAN的拓扑结构\"><a href=\"#CAN的拓扑结构\" class=\"headerlink\" title=\"CAN的拓扑结构\"></a>CAN的拓扑结构</h3><p>下图中，左边是高速CAN总线的拓扑结构，右边是低速CAN总线的拓扑结构。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210525202118238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-CVTFaKPI-1621944831661)(https://gitee.com/xiaolinzinvshen/article-pic/raw/master/2019071514355785.jpeg)]\"></p>\n<h3 id=\"CAN信号表示\"><a href=\"#CAN信号表示\" class=\"headerlink\" title=\"CAN信号表示\"></a>CAN信号表示</h3><p>在CAN总线上，利用CAN_H和CAN_L两根线上的电位差来表示CAN信号。CAN总线上的电位差分为显性电平和隐性电平。其中显性电平为逻辑0，隐性电平为逻辑1。<br>ISO11898标准（125kbps ~ 1Mbps）和ISO11519标准（10kbps ~ 125kbps）中CAN信号的表示分别如下所示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/5cbf37862a779c69d6737487a755c4d2.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"CAN信号传输\"><a href=\"#CAN信号传输\" class=\"headerlink\" title=\"CAN信号传输\"></a>CAN信号传输</h3><p>发送过程：CAN控制器将CPU传来的信号转为逻辑电平（即逻辑0-显性电平或者逻辑1-隐性电平）。CAN发射器接收逻辑电平之后，再将其转换为差分电平输出到CAN总线上。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/8d8c61b486a991f265908f2404fc03f9.png\" alt=\"在这里插入图片描述\"></p>\n<p>接受过程则刚好相反。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/8b83142a7ce96e17755ee71390e74e39.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"CAN通信网络结构\"><a href=\"#CAN通信网络结构\" class=\"headerlink\" title=\"CAN通信网络结构\"></a>CAN通信网络结构</h2><h3 id=\"OSI基本参照模型\"><a href=\"#OSI基本参照模型\" class=\"headerlink\" title=\"OSI基本参照模型\"></a>OSI基本参照模型</h3><p>OSI参考模型为7层，物理层、数据链路层、网络层、传输层、会话层、表示层和应用层，而CAN通信底层仅使用了物理层和数据链路层</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/e40676e4e27a71ab3ea8eb9418914cad.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"CAN总线报文类型\"><a href=\"#CAN总线报文类型\" class=\"headerlink\" title=\"CAN总线报文类型\"></a>CAN总线报文类型</h3><p>CAN总线的报文类型主要有五种，数据帧、远程帧、错误帧、过载帧、帧间隔<br>下面以数据帧为例进行简单介绍，其帧结构如下图所示，包含七个段：<strong>帧起始、仲裁段、控制段、数据段、CRC段、ACK段、帧结束</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210525201812946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fHkSnbCs-1621944831669)(https://gitee.com/xiaolinzinvshen/article-pic/raw/master/20190715151924879.png)]\"></p>\n<p>帧起始<br>仲裁域：通过11位标识符对报文优先级进行判断，RTR位判断为数据帧还是远程帧<br>控制域：描述数据域中的字节数<br>数据域：8个字节传递信息，如转速等<br>CRC域：循环冗余校验，避免因物理层传递出现丢失的情况<br>ACK域：表明总线中至少有一个节点正确接收到发送的报文，没有发生干扰<br>帧结束</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"CAN总线基本知识\"><a href=\"#CAN总线基本知识\" class=\"headerlink\" title=\"CAN总线基本知识\"></a>CAN总线基本知识</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>CAN 是Contoller Area Network 缩写，即控制域网络，简单来说就是用于汽车不同电子器件之间传输网络。<br>CAN 总线两个主要ISO国际标准是：ISO11898和ISO11519  </p>","more":"<p>ISO11898 定义了通信速率为 125 kbps～1 Mbps 的<strong>高速 CAN</strong> 通信标准，属于闭环总线，传输速率可达1Mbps，总线长度 ≤ 40米。<br>ISO11519 定义了通信速率为 10～125 kbps 的<strong>低速 CAN</strong>通信标准，属于开环总线，传输速率为40kbps时，总线长度可达1000米。</p>\n<p>CAN为了减少外部电磁场对内部点评的干扰，通常采用双绞线</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/8c4f412321d012aca6ec4f23efb4ce5b.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"CAN的拓扑结构\"><a href=\"#CAN的拓扑结构\" class=\"headerlink\" title=\"CAN的拓扑结构\"></a>CAN的拓扑结构</h3><p>下图中，左边是高速CAN总线的拓扑结构，右边是低速CAN总线的拓扑结构。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210525202118238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-CVTFaKPI-1621944831661)(https://gitee.com/xiaolinzinvshen/article-pic/raw/master/2019071514355785.jpeg)]\"></p>\n<h3 id=\"CAN信号表示\"><a href=\"#CAN信号表示\" class=\"headerlink\" title=\"CAN信号表示\"></a>CAN信号表示</h3><p>在CAN总线上，利用CAN_H和CAN_L两根线上的电位差来表示CAN信号。CAN总线上的电位差分为显性电平和隐性电平。其中显性电平为逻辑0，隐性电平为逻辑1。<br>ISO11898标准（125kbps ~ 1Mbps）和ISO11519标准（10kbps ~ 125kbps）中CAN信号的表示分别如下所示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/5cbf37862a779c69d6737487a755c4d2.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"CAN信号传输\"><a href=\"#CAN信号传输\" class=\"headerlink\" title=\"CAN信号传输\"></a>CAN信号传输</h3><p>发送过程：CAN控制器将CPU传来的信号转为逻辑电平（即逻辑0-显性电平或者逻辑1-隐性电平）。CAN发射器接收逻辑电平之后，再将其转换为差分电平输出到CAN总线上。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/8d8c61b486a991f265908f2404fc03f9.png\" alt=\"在这里插入图片描述\"></p>\n<p>接受过程则刚好相反。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/8b83142a7ce96e17755ee71390e74e39.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"CAN通信网络结构\"><a href=\"#CAN通信网络结构\" class=\"headerlink\" title=\"CAN通信网络结构\"></a>CAN通信网络结构</h2><h3 id=\"OSI基本参照模型\"><a href=\"#OSI基本参照模型\" class=\"headerlink\" title=\"OSI基本参照模型\"></a>OSI基本参照模型</h3><p>OSI参考模型为7层，物理层、数据链路层、网络层、传输层、会话层、表示层和应用层，而CAN通信底层仅使用了物理层和数据链路层</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/e40676e4e27a71ab3ea8eb9418914cad.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"CAN总线报文类型\"><a href=\"#CAN总线报文类型\" class=\"headerlink\" title=\"CAN总线报文类型\"></a>CAN总线报文类型</h3><p>CAN总线的报文类型主要有五种，数据帧、远程帧、错误帧、过载帧、帧间隔<br>下面以数据帧为例进行简单介绍，其帧结构如下图所示，包含七个段：<strong>帧起始、仲裁段、控制段、数据段、CRC段、ACK段、帧结束</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210525201812946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fHkSnbCs-1621944831669)(https://gitee.com/xiaolinzinvshen/article-pic/raw/master/20190715151924879.png)]\"></p>\n<p>帧起始<br>仲裁域：通过11位标识符对报文优先级进行判断，RTR位判断为数据帧还是远程帧<br>控制域：描述数据域中的字节数<br>数据域：8个字节传递信息，如转速等<br>CRC域：循环冗余校验，避免因物理层传递出现丢失的情况<br>ACK域：表明总线中至少有一个节点正确接收到发送的报文，没有发生干扰<br>帧结束</p>"},{"title":"CAN总线知识串联","date":"2021-05-29T05:48:48.000Z","_content":"\n\n## CAN Matrix定义\n\n通常主机厂在设计电气相关软件时，总是不可避免的要设计软件的输入和输出，而在汽车上各个电气部件之间都是通过CAN总线进行通信，因此在制定软件功能规范时往往第一步就是CAN Matrix的定义，如下图。  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210529135417253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)  \n一个完整的CAN Matrix通常应该包括以下信息  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210529135441416.png)\n<!--more-->\n\n## CAN Matrix转化为DBC\n\n通常主机厂提供的信号矩阵只是一个Excel文件，而要将信号矩阵应用于开发、模拟、测试等，就需要先将其转换成DBC\\(Database Can\\)文件，DBC文件是用来描述CAN网络通信信号的一种格式文件。它可以用来监测与分析CAN网络上的报文数据，也可以用来模拟某个CAN节点。\n\n简单来说，DBC文件可以理解为密码本，当车辆运行时，ECU的发送器根据密码本对外发送010101……消息，接收器将010101……消息根据密码本转换为相应的指令。  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210529135819155.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)\n\nDBC文件的转换规则可见：_https://blog.csdn.net/u010808702/article/details/104152745_","source":"_posts/CAN总线知识串联.md","raw":"---\ntitle: CAN总线知识串联\ndate: 2021-05-29 13:48:48\ntags: \ncategories: 汽车电子\n---\n\n\n## CAN Matrix定义\n\n通常主机厂在设计电气相关软件时，总是不可避免的要设计软件的输入和输出，而在汽车上各个电气部件之间都是通过CAN总线进行通信，因此在制定软件功能规范时往往第一步就是CAN Matrix的定义，如下图。  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210529135417253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)  \n一个完整的CAN Matrix通常应该包括以下信息  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210529135441416.png)\n<!--more-->\n\n## CAN Matrix转化为DBC\n\n通常主机厂提供的信号矩阵只是一个Excel文件，而要将信号矩阵应用于开发、模拟、测试等，就需要先将其转换成DBC\\(Database Can\\)文件，DBC文件是用来描述CAN网络通信信号的一种格式文件。它可以用来监测与分析CAN网络上的报文数据，也可以用来模拟某个CAN节点。\n\n简单来说，DBC文件可以理解为密码本，当车辆运行时，ECU的发送器根据密码本对外发送010101……消息，接收器将010101……消息根据密码本转换为相应的指令。  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210529135819155.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)\n\nDBC文件的转换规则可见：_https://blog.csdn.net/u010808702/article/details/104152745_","slug":"CAN总线知识串联","published":1,"updated":"2023-08-15T12:59:46.850Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllcdfgk90009i7jxauhig77j","content":"<h2 id=\"CAN-Matrix定义\"><a href=\"#CAN-Matrix定义\" class=\"headerlink\" title=\"CAN Matrix定义\"></a>CAN Matrix定义</h2><p>通常主机厂在设计电气相关软件时，总是不可避免的要设计软件的输入和输出，而在汽车上各个电气部件之间都是通过CAN总线进行通信，因此在制定软件功能规范时往往第一步就是CAN Matrix的定义，如下图。<br><img src=\"https://img-blog.csdnimg.cn/20210529135417253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>一个完整的CAN Matrix通常应该包括以下信息<br><img src=\"https://img-blog.csdnimg.cn/20210529135441416.png\" alt=\"在这里插入图片描述\"></p>\n<span id=\"more\"></span>\n\n<h2 id=\"CAN-Matrix转化为DBC\"><a href=\"#CAN-Matrix转化为DBC\" class=\"headerlink\" title=\"CAN Matrix转化为DBC\"></a>CAN Matrix转化为DBC</h2><p>通常主机厂提供的信号矩阵只是一个Excel文件，而要将信号矩阵应用于开发、模拟、测试等，就需要先将其转换成DBC(Database Can)文件，DBC文件是用来描述CAN网络通信信号的一种格式文件。它可以用来监测与分析CAN网络上的报文数据，也可以用来模拟某个CAN节点。</p>\n<p>简单来说，DBC文件可以理解为密码本，当车辆运行时，ECU的发送器根据密码本对外发送010101……消息，接收器将010101……消息根据密码本转换为相应的指令。<br><img src=\"https://img-blog.csdnimg.cn/20210529135819155.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>DBC文件的转换规则可见：<em><a href=\"https://blog.csdn.net/u010808702/article/details/104152745\">https://blog.csdn.net/u010808702/article/details/104152745</a></em></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"CAN-Matrix定义\"><a href=\"#CAN-Matrix定义\" class=\"headerlink\" title=\"CAN Matrix定义\"></a>CAN Matrix定义</h2><p>通常主机厂在设计电气相关软件时，总是不可避免的要设计软件的输入和输出，而在汽车上各个电气部件之间都是通过CAN总线进行通信，因此在制定软件功能规范时往往第一步就是CAN Matrix的定义，如下图。<br><img src=\"https://img-blog.csdnimg.cn/20210529135417253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>一个完整的CAN Matrix通常应该包括以下信息<br><img src=\"https://img-blog.csdnimg.cn/20210529135441416.png\" alt=\"在这里插入图片描述\"></p>","more":"<h2 id=\"CAN-Matrix转化为DBC\"><a href=\"#CAN-Matrix转化为DBC\" class=\"headerlink\" title=\"CAN Matrix转化为DBC\"></a>CAN Matrix转化为DBC</h2><p>通常主机厂提供的信号矩阵只是一个Excel文件，而要将信号矩阵应用于开发、模拟、测试等，就需要先将其转换成DBC(Database Can)文件，DBC文件是用来描述CAN网络通信信号的一种格式文件。它可以用来监测与分析CAN网络上的报文数据，也可以用来模拟某个CAN节点。</p>\n<p>简单来说，DBC文件可以理解为密码本，当车辆运行时，ECU的发送器根据密码本对外发送010101……消息，接收器将010101……消息根据密码本转换为相应的指令。<br><img src=\"https://img-blog.csdnimg.cn/20210529135819155.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>DBC文件的转换规则可见：<em><a href=\"https://blog.csdn.net/u010808702/article/details/104152745\">https://blog.csdn.net/u010808702/article/details/104152745</a></em></p>"},{"title":"Github Page + Hexo 搭建个人博客","_content":"\n## Github Page + Hexo 搭建个人博客\n\n### 准备环境\n\n首先查看环境是否安装，主要用到的工具有git，node，npm\n\n```bash\ngit version\nnode -v\nnpm -v\n```\n\n### 安装Hexo\n\n如果以上环境准备好了就可以使用 npm 开始安装 Hexo 了。也可查看 [Hexo](https://link.segmentfault.com/?url=https%3A%2F%2Fhexo.io%2Fzh-cn%2F) 的详细文档\n在命令行输入执行以下命令：\n\n`npm install -g hexo-cli`\n\n安装 Hexo 完成后，再执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件\n\n```bash\nhexo init myBlog\ncd myBlog\nnpm install\n```\n\n此时已安装完成，可以启动服务了\n\n`hexo s`\n\n在浏览器中输入 http://localhost:4000 回车就可以预览效果了\n\n### Hexo 部署\n\n安装 [hexo-deployer-git](https://github.com/hexojs/hexo-deployer-git)。\n\n`npm install hexo-deployer-git --save`\n\n修改配置。\n\n```bash\ndeploy:\n  type: git\n  repository: git@github.com:xxx/xxx.git,branchName\n  branch: master\n  message: update myblog\n```\n\n### Hexo 备份\n\n首先在 github 上 master 主分支下创建 hexo 空白分支\n安装 hexo-git-backup 插件\n\n`npm install hexo-git-backup --save`\n\n到 Hexo 博客根目录的 `_config.yml` 配置文件里添加以下配置：\n\n```bash\nbackup:\n    type: git\n    message: update myblog\n    repository:\n       github: git@github.com:xxx/xxx.git,branchName\n```\n\n然后使用命令即可\n\n`hexo b`\n\n### Hexo 文章显示摘要\n\n1：使用npm安装hexo-excerpt\n\n```bash\nnpm install hexo-excerpt --save\n```\n\n2：在站点配置文件中添加\n\n```bash\nexcerpt:\n  depth: 5  \n  excerpt_excludes: []\n  more_excludes: []\n  hideWholePostExcerpts: true\n```\n\n## 增加新文章\n\n将文章放入source/_posts/目录下即可\n因为hexo是静态博客，所以每次对博客做出改变后都需要清除原来的缓存重新生成一次\n\n```\nhexo clean\nhexo g\n\n```\n\n\n","source":"_posts/Github Page + Hexo 搭建个人博客.md","raw":"---\ntitle: Github Page + Hexo 搭建个人博客\ncategories: Hexo\n---\n\n## Github Page + Hexo 搭建个人博客\n\n### 准备环境\n\n首先查看环境是否安装，主要用到的工具有git，node，npm\n\n```bash\ngit version\nnode -v\nnpm -v\n```\n\n### 安装Hexo\n\n如果以上环境准备好了就可以使用 npm 开始安装 Hexo 了。也可查看 [Hexo](https://link.segmentfault.com/?url=https%3A%2F%2Fhexo.io%2Fzh-cn%2F) 的详细文档\n在命令行输入执行以下命令：\n\n`npm install -g hexo-cli`\n\n安装 Hexo 完成后，再执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件\n\n```bash\nhexo init myBlog\ncd myBlog\nnpm install\n```\n\n此时已安装完成，可以启动服务了\n\n`hexo s`\n\n在浏览器中输入 http://localhost:4000 回车就可以预览效果了\n\n### Hexo 部署\n\n安装 [hexo-deployer-git](https://github.com/hexojs/hexo-deployer-git)。\n\n`npm install hexo-deployer-git --save`\n\n修改配置。\n\n```bash\ndeploy:\n  type: git\n  repository: git@github.com:xxx/xxx.git,branchName\n  branch: master\n  message: update myblog\n```\n\n### Hexo 备份\n\n首先在 github 上 master 主分支下创建 hexo 空白分支\n安装 hexo-git-backup 插件\n\n`npm install hexo-git-backup --save`\n\n到 Hexo 博客根目录的 `_config.yml` 配置文件里添加以下配置：\n\n```bash\nbackup:\n    type: git\n    message: update myblog\n    repository:\n       github: git@github.com:xxx/xxx.git,branchName\n```\n\n然后使用命令即可\n\n`hexo b`\n\n### Hexo 文章显示摘要\n\n1：使用npm安装hexo-excerpt\n\n```bash\nnpm install hexo-excerpt --save\n```\n\n2：在站点配置文件中添加\n\n```bash\nexcerpt:\n  depth: 5  \n  excerpt_excludes: []\n  more_excludes: []\n  hideWholePostExcerpts: true\n```\n\n## 增加新文章\n\n将文章放入source/_posts/目录下即可\n因为hexo是静态博客，所以每次对博客做出改变后都需要清除原来的缓存重新生成一次\n\n```\nhexo clean\nhexo g\n\n```\n\n\n","slug":"Github Page + Hexo 搭建个人博客","published":1,"date":"2023-08-15T12:59:46.770Z","updated":"2023-08-15T13:56:12.854Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllcdfgka000ai7jxhddqbn7y","content":"<h2 id=\"Github-Page-Hexo-搭建个人博客\"><a href=\"#Github-Page-Hexo-搭建个人博客\" class=\"headerlink\" title=\"Github Page + Hexo 搭建个人博客\"></a>Github Page + Hexo 搭建个人博客</h2><h3 id=\"准备环境\"><a href=\"#准备环境\" class=\"headerlink\" title=\"准备环境\"></a>准备环境</h3><p>首先查看环境是否安装，主要用到的工具有git，node，npm</p>\n<pre><code class=\"bash\">git version\nnode -v\nnpm -v\n</code></pre>\n<h3 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h3><p>如果以上环境准备好了就可以使用 npm 开始安装 Hexo 了。也可查看 <a href=\"https://link.segmentfault.com/?url=https://hexo.io/zh-cn/\">Hexo</a> 的详细文档<br>在命令行输入执行以下命令：</p>\n<p><code>npm install -g hexo-cli</code></p>\n<p>安装 Hexo 完成后，再执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件</p>\n<pre><code class=\"bash\">hexo init myBlog\ncd myBlog\nnpm install\n</code></pre>\n<p>此时已安装完成，可以启动服务了</p>\n<p><code>hexo s</code></p>\n<p>在浏览器中输入 <a href=\"http://localhost:4000/\">http://localhost:4000</a> 回车就可以预览效果了</p>\n<h3 id=\"Hexo-部署\"><a href=\"#Hexo-部署\" class=\"headerlink\" title=\"Hexo 部署\"></a>Hexo 部署</h3><p>安装 <a href=\"https://github.com/hexojs/hexo-deployer-git\">hexo-deployer-git</a>。</p>\n<p><code>npm install hexo-deployer-git --save</code></p>\n<p>修改配置。</p>\n<pre><code class=\"bash\">deploy:\n  type: git\n  repository: git@github.com:xxx/xxx.git,branchName\n  branch: master\n  message: update myblog\n</code></pre>\n<h3 id=\"Hexo-备份\"><a href=\"#Hexo-备份\" class=\"headerlink\" title=\"Hexo 备份\"></a>Hexo 备份</h3><p>首先在 github 上 master 主分支下创建 hexo 空白分支<br>安装 hexo-git-backup 插件</p>\n<p><code>npm install hexo-git-backup --save</code></p>\n<p>到 Hexo 博客根目录的 <code>_config.yml</code> 配置文件里添加以下配置：</p>\n<pre><code class=\"bash\">backup:\n    type: git\n    message: update myblog\n    repository:\n       github: git@github.com:xxx/xxx.git,branchName\n</code></pre>\n<p>然后使用命令即可</p>\n<p><code>hexo b</code></p>\n<h3 id=\"Hexo-文章显示摘要\"><a href=\"#Hexo-文章显示摘要\" class=\"headerlink\" title=\"Hexo 文章显示摘要\"></a>Hexo 文章显示摘要</h3><p>1：使用npm安装hexo-excerpt</p>\n<pre><code class=\"bash\">npm install hexo-excerpt --save\n</code></pre>\n<p>2：在站点配置文件中添加</p>\n<pre><code class=\"bash\">excerpt:\n  depth: 5  \n  excerpt_excludes: []\n  more_excludes: []\n  hideWholePostExcerpts: true\n</code></pre>\n<h2 id=\"增加新文章\"><a href=\"#增加新文章\" class=\"headerlink\" title=\"增加新文章\"></a>增加新文章</h2><p>将文章放入source/_posts/目录下即可<br>因为hexo是静态博客，所以每次对博客做出改变后都需要清除原来的缓存重新生成一次</p>\n<pre><code>hexo clean\nhexo g\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Github-Page-Hexo-搭建个人博客\"><a href=\"#Github-Page-Hexo-搭建个人博客\" class=\"headerlink\" title=\"Github Page + Hexo 搭建个人博客\"></a>Github Page + Hexo 搭建个人博客</h2><h3 id=\"准备环境\"><a href=\"#准备环境\" class=\"headerlink\" title=\"准备环境\"></a>准备环境</h3><p>首先查看环境是否安装，主要用到的工具有git，node，npm</p>\n<pre><code class=\"bash\">git version\nnode -v\nnpm -v\n</code></pre>\n<h3 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h3><p>如果以上环境准备好了就可以使用 npm 开始安装 Hexo 了。也可查看 <a href=\"https://link.segmentfault.com/?url=https://hexo.io/zh-cn/\">Hexo</a> 的详细文档<br>在命令行输入执行以下命令：</p>\n<p><code>npm install -g hexo-cli</code></p>\n<p>安装 Hexo 完成后，再执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件</p>\n<pre><code class=\"bash\">hexo init myBlog\ncd myBlog\nnpm install\n</code></pre>\n<p>此时已安装完成，可以启动服务了</p>\n<p><code>hexo s</code></p>\n<p>在浏览器中输入 <a href=\"http://localhost:4000/\">http://localhost:4000</a> 回车就可以预览效果了</p>\n<h3 id=\"Hexo-部署\"><a href=\"#Hexo-部署\" class=\"headerlink\" title=\"Hexo 部署\"></a>Hexo 部署</h3><p>安装 <a href=\"https://github.com/hexojs/hexo-deployer-git\">hexo-deployer-git</a>。</p>\n<p><code>npm install hexo-deployer-git --save</code></p>\n<p>修改配置。</p>\n<pre><code class=\"bash\">deploy:\n  type: git\n  repository: git@github.com:xxx/xxx.git,branchName\n  branch: master\n  message: update myblog\n</code></pre>\n<h3 id=\"Hexo-备份\"><a href=\"#Hexo-备份\" class=\"headerlink\" title=\"Hexo 备份\"></a>Hexo 备份</h3><p>首先在 github 上 master 主分支下创建 hexo 空白分支<br>安装 hexo-git-backup 插件</p>\n<p><code>npm install hexo-git-backup --save</code></p>\n<p>到 Hexo 博客根目录的 <code>_config.yml</code> 配置文件里添加以下配置：</p>\n<pre><code class=\"bash\">backup:\n    type: git\n    message: update myblog\n    repository:\n       github: git@github.com:xxx/xxx.git,branchName\n</code></pre>\n<p>然后使用命令即可</p>\n<p><code>hexo b</code></p>\n<h3 id=\"Hexo-文章显示摘要\"><a href=\"#Hexo-文章显示摘要\" class=\"headerlink\" title=\"Hexo 文章显示摘要\"></a>Hexo 文章显示摘要</h3><p>1：使用npm安装hexo-excerpt</p>\n<pre><code class=\"bash\">npm install hexo-excerpt --save\n</code></pre>\n<p>2：在站点配置文件中添加</p>\n<pre><code class=\"bash\">excerpt:\n  depth: 5  \n  excerpt_excludes: []\n  more_excludes: []\n  hideWholePostExcerpts: true\n</code></pre>\n<h2 id=\"增加新文章\"><a href=\"#增加新文章\" class=\"headerlink\" title=\"增加新文章\"></a>增加新文章</h2><p>将文章放入source/_posts/目录下即可<br>因为hexo是静态博客，所以每次对博客做出改变后都需要清除原来的缓存重新生成一次</p>\n<pre><code>hexo clean\nhexo g\n</code></pre>\n"},{"title":"Linux下配置Selenium","date":"2021-07-04T02:23:01.000Z","_content":"\n\n### Linux下使用Selenium进行自动化测试\n\n- - [selenium的安装](#selenium_1)\n  - [安装chrome以及chrome driver](#chromechrome_driver_5)\n  - [Chrome driver 配置](#Chrome_driver__16)\n\n<!--more-->\n## selenium的安装\n\n```python\npip install selenium\n```\n\n## 安装chrome以及chrome driver\n\n简单点直接从官网下载deb安装包，此时双击直接用默认应用商店安装可能会出现如下错误  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210704092644914.png)  \n**解决方案**\n\n```python\nsudo apt-get install gdebi\n```\n\n接着在右击你要安装的 .deb 文件，选择 Open With —> GDebi Package Installer接着install package即可  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210704092759414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)\n\n## Chrome driver 配置\n\n[Chrome 浏览器驱动下载地址](https://chromedriver.storage.googleapis.com/index.html)  \n根据浏览器版本下载相应的driver版本，给文件赋予可执行权限\n\n```python\nchmod +x chromedriver\n```\n\n然后将文件放到系统环境变量PATH路径中\n\n```python\nsudo cp chromedriver /usr/bin/\n```\n\n查看chromedriver的版本号确认成功\n\n```python\nchromedriver --version\n```\n\n然后新建.py文件进行测试，此时已能自动打开chrome并访问百度\n\n```python\nfrom selenium import webdriver\n\nwd = webdriver.Chrome()\n\nwd.get('https://www.baidu.com')\n```","source":"_posts/Linux下配置Selenium.md","raw":"---\ntitle: Linux下配置Selenium\ndate: 2021-07-04 10:23:01\ntags: \ncategories: # Python\n---\n\n\n### Linux下使用Selenium进行自动化测试\n\n- - [selenium的安装](#selenium_1)\n  - [安装chrome以及chrome driver](#chromechrome_driver_5)\n  - [Chrome driver 配置](#Chrome_driver__16)\n\n<!--more-->\n## selenium的安装\n\n```python\npip install selenium\n```\n\n## 安装chrome以及chrome driver\n\n简单点直接从官网下载deb安装包，此时双击直接用默认应用商店安装可能会出现如下错误  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210704092644914.png)  \n**解决方案**\n\n```python\nsudo apt-get install gdebi\n```\n\n接着在右击你要安装的 .deb 文件，选择 Open With —> GDebi Package Installer接着install package即可  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210704092759414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)\n\n## Chrome driver 配置\n\n[Chrome 浏览器驱动下载地址](https://chromedriver.storage.googleapis.com/index.html)  \n根据浏览器版本下载相应的driver版本，给文件赋予可执行权限\n\n```python\nchmod +x chromedriver\n```\n\n然后将文件放到系统环境变量PATH路径中\n\n```python\nsudo cp chromedriver /usr/bin/\n```\n\n查看chromedriver的版本号确认成功\n\n```python\nchromedriver --version\n```\n\n然后新建.py文件进行测试，此时已能自动打开chrome并访问百度\n\n```python\nfrom selenium import webdriver\n\nwd = webdriver.Chrome()\n\nwd.get('https://www.baidu.com')\n```","slug":"Linux下配置Selenium","published":1,"updated":"2023-08-15T12:59:46.754Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllcdfgkb000di7jx9i7aacdz","content":"<h3 id=\"Linux下使用Selenium进行自动化测试\"><a href=\"#Linux下使用Selenium进行自动化测试\" class=\"headerlink\" title=\"Linux下使用Selenium进行自动化测试\"></a>Linux下使用Selenium进行自动化测试</h3><ul>\n<li><ul>\n<li><a href=\"#selenium_1\">selenium的安装</a></li>\n<li><a href=\"#chromechrome_driver_5\">安装chrome以及chrome driver</a></li>\n<li><a href=\"#Chrome_driver__16\">Chrome driver 配置</a></li>\n</ul>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"selenium的安装\"><a href=\"#selenium的安装\" class=\"headerlink\" title=\"selenium的安装\"></a>selenium的安装</h2><pre><code class=\"python\">pip install selenium\n</code></pre>\n<h2 id=\"安装chrome以及chrome-driver\"><a href=\"#安装chrome以及chrome-driver\" class=\"headerlink\" title=\"安装chrome以及chrome driver\"></a>安装chrome以及chrome driver</h2><p>简单点直接从官网下载deb安装包，此时双击直接用默认应用商店安装可能会出现如下错误<br><img src=\"https://img-blog.csdnimg.cn/20210704092644914.png\" alt=\"在这里插入图片描述\"><br><strong>解决方案</strong></p>\n<pre><code class=\"python\">sudo apt-get install gdebi\n</code></pre>\n<p>接着在右击你要安装的 .deb 文件，选择 Open With —&gt; GDebi Package Installer接着install package即可<br><img src=\"https://img-blog.csdnimg.cn/20210704092759414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"Chrome-driver-配置\"><a href=\"#Chrome-driver-配置\" class=\"headerlink\" title=\"Chrome driver 配置\"></a>Chrome driver 配置</h2><p><a href=\"https://chromedriver.storage.googleapis.com/index.html\">Chrome 浏览器驱动下载地址</a><br>根据浏览器版本下载相应的driver版本，给文件赋予可执行权限</p>\n<pre><code class=\"python\">chmod +x chromedriver\n</code></pre>\n<p>然后将文件放到系统环境变量PATH路径中</p>\n<pre><code class=\"python\">sudo cp chromedriver /usr/bin/\n</code></pre>\n<p>查看chromedriver的版本号确认成功</p>\n<pre><code class=\"python\">chromedriver --version\n</code></pre>\n<p>然后新建.py文件进行测试，此时已能自动打开chrome并访问百度</p>\n<pre><code class=\"python\">from selenium import webdriver\n\nwd = webdriver.Chrome()\n\nwd.get(&#39;https://www.baidu.com&#39;)\n</code></pre>\n","site":{"data":{}},"excerpt":"<h3 id=\"Linux下使用Selenium进行自动化测试\"><a href=\"#Linux下使用Selenium进行自动化测试\" class=\"headerlink\" title=\"Linux下使用Selenium进行自动化测试\"></a>Linux下使用Selenium进行自动化测试</h3><ul>\n<li><ul>\n<li><a href=\"#selenium_1\">selenium的安装</a></li>\n<li><a href=\"#chromechrome_driver_5\">安装chrome以及chrome driver</a></li>\n<li><a href=\"#Chrome_driver__16\">Chrome driver 配置</a></li>\n</ul>\n</li>\n</ul>","more":"<h2 id=\"selenium的安装\"><a href=\"#selenium的安装\" class=\"headerlink\" title=\"selenium的安装\"></a>selenium的安装</h2><pre><code class=\"python\">pip install selenium\n</code></pre>\n<h2 id=\"安装chrome以及chrome-driver\"><a href=\"#安装chrome以及chrome-driver\" class=\"headerlink\" title=\"安装chrome以及chrome driver\"></a>安装chrome以及chrome driver</h2><p>简单点直接从官网下载deb安装包，此时双击直接用默认应用商店安装可能会出现如下错误<br><img src=\"https://img-blog.csdnimg.cn/20210704092644914.png\" alt=\"在这里插入图片描述\"><br><strong>解决方案</strong></p>\n<pre><code class=\"python\">sudo apt-get install gdebi\n</code></pre>\n<p>接着在右击你要安装的 .deb 文件，选择 Open With —&gt; GDebi Package Installer接着install package即可<br><img src=\"https://img-blog.csdnimg.cn/20210704092759414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"Chrome-driver-配置\"><a href=\"#Chrome-driver-配置\" class=\"headerlink\" title=\"Chrome driver 配置\"></a>Chrome driver 配置</h2><p><a href=\"https://chromedriver.storage.googleapis.com/index.html\">Chrome 浏览器驱动下载地址</a><br>根据浏览器版本下载相应的driver版本，给文件赋予可执行权限</p>\n<pre><code class=\"python\">chmod +x chromedriver\n</code></pre>\n<p>然后将文件放到系统环境变量PATH路径中</p>\n<pre><code class=\"python\">sudo cp chromedriver /usr/bin/\n</code></pre>\n<p>查看chromedriver的版本号确认成功</p>\n<pre><code class=\"python\">chromedriver --version\n</code></pre>\n<p>然后新建.py文件进行测试，此时已能自动打开chrome并访问百度</p>\n<pre><code class=\"python\">from selenium import webdriver\n\nwd = webdriver.Chrome()\n\nwd.get(&#39;https://www.baidu.com&#39;)\n</code></pre>"},{"title":"Linux安装Jupyter并且远程访问","date":"2021-06-20T05:16:12.000Z","_content":"\n\n### pip的安装\n\n下载pip安装脚本  \n`wget https://bootstrap.pypa.io/get-pip.py`  \n使用python命令运行安装脚本  \n`python3 get-pip.py`\n<!--more-->\n\n### Jupyter的安装\n\n```bash\npip install ipython  \npip install jupyter\n```\n\nUbuntu此时使用jupyter notebook命令启动jupyter会提示未找到命令，按照提示安装jupyter即可  \n`sudo snap install jupyter`  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210620102132972.png)\n\n### 配置Jupyter notebook server\n\n#### 生成配置文件\n\n安装jupyter后续通过以下命令生成配置文件  \n`jupyter notebook \\--generate-config`\n\n#### 生成访问密码\n\n只需要需要运行一行命令 jupyter notebook password ，会让你填写密码和确认密码，并且生成含有密码的hash的jupyter\\_notebook\\_config.json在配置文件中\n\n```bash\njupyter notebook password\nEnter password: \nVerify password: \n[NotebookPasswordApp] Wrote hashed password to /home/coke/snap/jupyter/6/.jupyter/jupyter_notebook_config.json\n```\n\n#### 生成hash密码\n\n下面我们还需要手动生成一个hash密码。\n\n可能你会问，为什么前面我们生成了一个Jupyter密码，这里还需生成一个hash密码呢？\n\n原因很简单，如果你没有生成这么一个hash密码的话，那么每次通过浏览器远程访问Jupyter时，你都需要输入一次密码，这很繁琐！\n\n但如果我们启用了这个hash密码，只需要首次远程访问Jupyter文档时，输入一次密码，在下次访问时，这个hash密码就好比一个钥匙（token），替我们打开密码之门，也就是免密码登录。\n\n然后在IPython中，依次输入如下代码：\n\n```bash\nIn [1]: from notebook.auth import passwd\nIn [2]: passwd()\nEnter password:\nVerify password:\nOut[2]: 'sha1:67c9e60bb8b6:9ffede0825894254b2e042ea597d771089e11aed'\n```\n\n#### 修改默认配置文件\n\n使用vim对配置文件进行修改，配置文件目录以本机为准  \n`vim /home/coke/snap/jupyter/6/.jupyter/jupyter_notebook_config.py`  \n主要对以下几条进行修改\n\n```bash\nc.NotebookApp.ip='0.0.0.0'\nc.NotebookApp.password = u'sha:ce...刚才复制的那个密文'\nc.NotebookApp.open_browser = False #避免服务器端浏览器自动打开\nc.NotebookApp.port =8888 #随便指定一个端口\n```\n\n如果此时依然无法访问，最简单的方法在本地主机建立SSH通道\n\n```bash\nPS C:\\Users\\z> ssh coke@192.168.20.135\ncoke@192.168.20.135's password:\nWelcome to Ubuntu 20.04.2 LTS (GNU/Linux 5.8.0-55-generic x86_64)\n```\n\n此时启动jupyter notebook 就可以在本地主机进入notebook了\n\n```bash\njupyter notebook #服务启动\n\nhttp://192.168.0.1:8888/tree #访问ip地址更换为服务器地址\n```","source":"_posts/Linux安装Jupyter并且远程访问.md","raw":"---\ntitle: Linux安装Jupyter并且远程访问\ndate: 2021-06-20 13:16:12\ntags: \ncategories: Linux\n---\n\n\n### pip的安装\n\n下载pip安装脚本  \n`wget https://bootstrap.pypa.io/get-pip.py`  \n使用python命令运行安装脚本  \n`python3 get-pip.py`\n<!--more-->\n\n### Jupyter的安装\n\n```bash\npip install ipython  \npip install jupyter\n```\n\nUbuntu此时使用jupyter notebook命令启动jupyter会提示未找到命令，按照提示安装jupyter即可  \n`sudo snap install jupyter`  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210620102132972.png)\n\n### 配置Jupyter notebook server\n\n#### 生成配置文件\n\n安装jupyter后续通过以下命令生成配置文件  \n`jupyter notebook \\--generate-config`\n\n#### 生成访问密码\n\n只需要需要运行一行命令 jupyter notebook password ，会让你填写密码和确认密码，并且生成含有密码的hash的jupyter\\_notebook\\_config.json在配置文件中\n\n```bash\njupyter notebook password\nEnter password: \nVerify password: \n[NotebookPasswordApp] Wrote hashed password to /home/coke/snap/jupyter/6/.jupyter/jupyter_notebook_config.json\n```\n\n#### 生成hash密码\n\n下面我们还需要手动生成一个hash密码。\n\n可能你会问，为什么前面我们生成了一个Jupyter密码，这里还需生成一个hash密码呢？\n\n原因很简单，如果你没有生成这么一个hash密码的话，那么每次通过浏览器远程访问Jupyter时，你都需要输入一次密码，这很繁琐！\n\n但如果我们启用了这个hash密码，只需要首次远程访问Jupyter文档时，输入一次密码，在下次访问时，这个hash密码就好比一个钥匙（token），替我们打开密码之门，也就是免密码登录。\n\n然后在IPython中，依次输入如下代码：\n\n```bash\nIn [1]: from notebook.auth import passwd\nIn [2]: passwd()\nEnter password:\nVerify password:\nOut[2]: 'sha1:67c9e60bb8b6:9ffede0825894254b2e042ea597d771089e11aed'\n```\n\n#### 修改默认配置文件\n\n使用vim对配置文件进行修改，配置文件目录以本机为准  \n`vim /home/coke/snap/jupyter/6/.jupyter/jupyter_notebook_config.py`  \n主要对以下几条进行修改\n\n```bash\nc.NotebookApp.ip='0.0.0.0'\nc.NotebookApp.password = u'sha:ce...刚才复制的那个密文'\nc.NotebookApp.open_browser = False #避免服务器端浏览器自动打开\nc.NotebookApp.port =8888 #随便指定一个端口\n```\n\n如果此时依然无法访问，最简单的方法在本地主机建立SSH通道\n\n```bash\nPS C:\\Users\\z> ssh coke@192.168.20.135\ncoke@192.168.20.135's password:\nWelcome to Ubuntu 20.04.2 LTS (GNU/Linux 5.8.0-55-generic x86_64)\n```\n\n此时启动jupyter notebook 就可以在本地主机进入notebook了\n\n```bash\njupyter notebook #服务启动\n\nhttp://192.168.0.1:8888/tree #访问ip地址更换为服务器地址\n```","slug":"Linux安装Jupyter并且远程访问","published":1,"updated":"2023-08-15T12:59:46.738Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllcdfgkc000fi7jxhcvkgrkf","content":"<h3 id=\"pip的安装\"><a href=\"#pip的安装\" class=\"headerlink\" title=\"pip的安装\"></a>pip的安装</h3><p>下载pip安装脚本<br><code>wget https://bootstrap.pypa.io/get-pip.py</code><br>使用python命令运行安装脚本<br><code>python3 get-pip.py</code></p>\n<span id=\"more\"></span>\n\n<h3 id=\"Jupyter的安装\"><a href=\"#Jupyter的安装\" class=\"headerlink\" title=\"Jupyter的安装\"></a>Jupyter的安装</h3><pre><code class=\"bash\">pip install ipython  \npip install jupyter\n</code></pre>\n<p>Ubuntu此时使用jupyter notebook命令启动jupyter会提示未找到命令，按照提示安装jupyter即可<br><code>sudo snap install jupyter</code><br><img src=\"https://img-blog.csdnimg.cn/20210620102132972.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"配置Jupyter-notebook-server\"><a href=\"#配置Jupyter-notebook-server\" class=\"headerlink\" title=\"配置Jupyter notebook server\"></a>配置Jupyter notebook server</h3><h4 id=\"生成配置文件\"><a href=\"#生成配置文件\" class=\"headerlink\" title=\"生成配置文件\"></a>生成配置文件</h4><p>安装jupyter后续通过以下命令生成配置文件<br><code>jupyter notebook \\--generate-config</code></p>\n<h4 id=\"生成访问密码\"><a href=\"#生成访问密码\" class=\"headerlink\" title=\"生成访问密码\"></a>生成访问密码</h4><p>只需要需要运行一行命令 jupyter notebook password ，会让你填写密码和确认密码，并且生成含有密码的hash的jupyter_notebook_config.json在配置文件中</p>\n<pre><code class=\"bash\">jupyter notebook password\nEnter password: \nVerify password: \n[NotebookPasswordApp] Wrote hashed password to /home/coke/snap/jupyter/6/.jupyter/jupyter_notebook_config.json\n</code></pre>\n<h4 id=\"生成hash密码\"><a href=\"#生成hash密码\" class=\"headerlink\" title=\"生成hash密码\"></a>生成hash密码</h4><p>下面我们还需要手动生成一个hash密码。</p>\n<p>可能你会问，为什么前面我们生成了一个Jupyter密码，这里还需生成一个hash密码呢？</p>\n<p>原因很简单，如果你没有生成这么一个hash密码的话，那么每次通过浏览器远程访问Jupyter时，你都需要输入一次密码，这很繁琐！</p>\n<p>但如果我们启用了这个hash密码，只需要首次远程访问Jupyter文档时，输入一次密码，在下次访问时，这个hash密码就好比一个钥匙（token），替我们打开密码之门，也就是免密码登录。</p>\n<p>然后在IPython中，依次输入如下代码：</p>\n<pre><code class=\"bash\">In [1]: from notebook.auth import passwd\nIn [2]: passwd()\nEnter password:\nVerify password:\nOut[2]: &#39;sha1:67c9e60bb8b6:9ffede0825894254b2e042ea597d771089e11aed&#39;\n</code></pre>\n<h4 id=\"修改默认配置文件\"><a href=\"#修改默认配置文件\" class=\"headerlink\" title=\"修改默认配置文件\"></a>修改默认配置文件</h4><p>使用vim对配置文件进行修改，配置文件目录以本机为准<br><code>vim /home/coke/snap/jupyter/6/.jupyter/jupyter_notebook_config.py</code><br>主要对以下几条进行修改</p>\n<pre><code class=\"bash\">c.NotebookApp.ip=&#39;0.0.0.0&#39;\nc.NotebookApp.password = u&#39;sha:ce...刚才复制的那个密文&#39;\nc.NotebookApp.open_browser = False #避免服务器端浏览器自动打开\nc.NotebookApp.port =8888 #随便指定一个端口\n</code></pre>\n<p>如果此时依然无法访问，最简单的方法在本地主机建立SSH通道</p>\n<pre><code class=\"bash\">PS C:\\Users\\z&gt; ssh coke@192.168.20.135\ncoke@192.168.20.135&#39;s password:\nWelcome to Ubuntu 20.04.2 LTS (GNU/Linux 5.8.0-55-generic x86_64)\n</code></pre>\n<p>此时启动jupyter notebook 就可以在本地主机进入notebook了</p>\n<pre><code class=\"bash\">jupyter notebook #服务启动\n\nhttp://192.168.0.1:8888/tree #访问ip地址更换为服务器地址\n</code></pre>\n","site":{"data":{}},"excerpt":"<h3 id=\"pip的安装\"><a href=\"#pip的安装\" class=\"headerlink\" title=\"pip的安装\"></a>pip的安装</h3><p>下载pip安装脚本<br><code>wget https://bootstrap.pypa.io/get-pip.py</code><br>使用python命令运行安装脚本<br><code>python3 get-pip.py</code></p>","more":"<h3 id=\"Jupyter的安装\"><a href=\"#Jupyter的安装\" class=\"headerlink\" title=\"Jupyter的安装\"></a>Jupyter的安装</h3><pre><code class=\"bash\">pip install ipython  \npip install jupyter\n</code></pre>\n<p>Ubuntu此时使用jupyter notebook命令启动jupyter会提示未找到命令，按照提示安装jupyter即可<br><code>sudo snap install jupyter</code><br><img src=\"https://img-blog.csdnimg.cn/20210620102132972.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"配置Jupyter-notebook-server\"><a href=\"#配置Jupyter-notebook-server\" class=\"headerlink\" title=\"配置Jupyter notebook server\"></a>配置Jupyter notebook server</h3><h4 id=\"生成配置文件\"><a href=\"#生成配置文件\" class=\"headerlink\" title=\"生成配置文件\"></a>生成配置文件</h4><p>安装jupyter后续通过以下命令生成配置文件<br><code>jupyter notebook \\--generate-config</code></p>\n<h4 id=\"生成访问密码\"><a href=\"#生成访问密码\" class=\"headerlink\" title=\"生成访问密码\"></a>生成访问密码</h4><p>只需要需要运行一行命令 jupyter notebook password ，会让你填写密码和确认密码，并且生成含有密码的hash的jupyter_notebook_config.json在配置文件中</p>\n<pre><code class=\"bash\">jupyter notebook password\nEnter password: \nVerify password: \n[NotebookPasswordApp] Wrote hashed password to /home/coke/snap/jupyter/6/.jupyter/jupyter_notebook_config.json\n</code></pre>\n<h4 id=\"生成hash密码\"><a href=\"#生成hash密码\" class=\"headerlink\" title=\"生成hash密码\"></a>生成hash密码</h4><p>下面我们还需要手动生成一个hash密码。</p>\n<p>可能你会问，为什么前面我们生成了一个Jupyter密码，这里还需生成一个hash密码呢？</p>\n<p>原因很简单，如果你没有生成这么一个hash密码的话，那么每次通过浏览器远程访问Jupyter时，你都需要输入一次密码，这很繁琐！</p>\n<p>但如果我们启用了这个hash密码，只需要首次远程访问Jupyter文档时，输入一次密码，在下次访问时，这个hash密码就好比一个钥匙（token），替我们打开密码之门，也就是免密码登录。</p>\n<p>然后在IPython中，依次输入如下代码：</p>\n<pre><code class=\"bash\">In [1]: from notebook.auth import passwd\nIn [2]: passwd()\nEnter password:\nVerify password:\nOut[2]: &#39;sha1:67c9e60bb8b6:9ffede0825894254b2e042ea597d771089e11aed&#39;\n</code></pre>\n<h4 id=\"修改默认配置文件\"><a href=\"#修改默认配置文件\" class=\"headerlink\" title=\"修改默认配置文件\"></a>修改默认配置文件</h4><p>使用vim对配置文件进行修改，配置文件目录以本机为准<br><code>vim /home/coke/snap/jupyter/6/.jupyter/jupyter_notebook_config.py</code><br>主要对以下几条进行修改</p>\n<pre><code class=\"bash\">c.NotebookApp.ip=&#39;0.0.0.0&#39;\nc.NotebookApp.password = u&#39;sha:ce...刚才复制的那个密文&#39;\nc.NotebookApp.open_browser = False #避免服务器端浏览器自动打开\nc.NotebookApp.port =8888 #随便指定一个端口\n</code></pre>\n<p>如果此时依然无法访问，最简单的方法在本地主机建立SSH通道</p>\n<pre><code class=\"bash\">PS C:\\Users\\z&gt; ssh coke@192.168.20.135\ncoke@192.168.20.135&#39;s password:\nWelcome to Ubuntu 20.04.2 LTS (GNU/Linux 5.8.0-55-generic x86_64)\n</code></pre>\n<p>此时启动jupyter notebook 就可以在本地主机进入notebook了</p>\n<pre><code class=\"bash\">jupyter notebook #服务启动\n\nhttp://192.168.0.1:8888/tree #访问ip地址更换为服务器地址\n</code></pre>"},{"title":"Linux系统编程-守护进程","date":"2021-06-14T05:41:19.000Z","_content":"\n\n### 基本概念\n\n1.  Linux后台服务进程\n2.  独立于控制终端\n3.  周期性的执行某种任务\n4.  不受用户登陆和注销的影响\n<!--more-->\n5.  一般采用以d结尾的名字\n\n### 进程组和会话\n\n进程组: 一个进程包含多个进程  \n会话: 多个组组成一个会话.\n\n创建会话的进程不能是组长进程;  \n一般创建会话是父进程先fork子进程, 然后父进程退出, 让子进程调用setsid函数  \n创建一个会话, 这个子进程既是会长也是组长;  \n只要是创建了会话, 这个进程就脱离了控制终端的影响.\n\n![[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-zja3K36a-1623649224301)(Untitled.assets/image-20210614124433571.png)]](https://img-blog.csdnimg.cn/20210614134052443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)\n\n### 创建守护进程\n\n 1.     父进程fork子进程, 然后父进程退出.  \n    目的是: 子进程肯定不是组长进程, 为后续调用setsid函数提供了条件.\n 2.     子进程调用setsid函数创建一个新的会话.  \n    该子进程成了该会话的会长  \n    该子进程成了该组的组长进程.  \n    不再受控制终端的影响了\n 3.     改变当前的工作目录, chdir -----不是必须的\n 4.     重设文件掩码, umask\\(0000\\) -----不是必须的\n 5.     关闭STDIN\\_FILENO STDOUT\\_FILENO STDERR\\_FILENO —不是必须的\n 6.     核心操作\n\n```c\n//创建守护进程\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <signal.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/time.h>\n\nvoid myfunc(int signo)\n{\n\t//打开文件\n\tint fd = open(\"mydemon.log\", O_RDWR | O_CREAT | O_APPEND, 0755);\n\tif(fd<0)\n\t{\n\t\treturn;\n\t}\n\n\t//获取当前的系统时间\n\ttime_t t;\n\ttime(&t);\n\tchar *p = ctime(&t);\n\t\n\t//将时间写入文件\n\twrite(fd, p, strlen(p));\n\n\tclose(fd);\n\n\treturn;\n}\n\nint main()\n{\n\t//父进程fork子进程, 然后父进程退出\n\tpid_t pid = fork();\n\tif(pid<0 || pid>0)\n\t{\n\t\texit(1);\n\t}\n\t\n\t//子进程调用setsid函数创建会话\n\tsetsid();\n\n\t//改变当前的工作目录\n\tchdir(\"/home/itcast/log\");\n\n\t//改变文件掩码\n\tumask(0000);\n\n\t//关闭标准输入,输出和错误输出文件描述符\n\tclose(STDIN_FILENO);\n\tclose(STDOUT_FILENO);\n\tclose(STDERR_FILENO);\n\n\t//核心操作\n\t//注册信号处理函数\n\tstruct sigaction act;\n\tact.sa_handler = myfunc;\n\tact.sa_flags = 0;\n\tsigemptyset(&act.sa_mask);\t\n\tsigaction(SIGALRM, &act, NULL);\n\n\t//设置时钟\n\tstruct itimerval tm;\n\ttm.it_interval.tv_sec = 2;\n\ttm.it_interval.tv_usec = 0;\n\ttm.it_value.tv_sec = 3;\n\ttm.it_value.tv_usec = 0;\n\tsetitimer(ITIMER_REAL, &tm, NULL);\n\n\tprintf(\"hello world\\n\");\n\n\twhile(1)\n\t{\n\t\tsleep(1);\n\t}\n}\n```","source":"_posts/Linux系统编程-守护进程.md","raw":"---\ntitle: Linux系统编程-守护进程\ndate: 2021-06-14 13:41:19\ntags: \ncategories: Linux\n---\n\n\n### 基本概念\n\n1.  Linux后台服务进程\n2.  独立于控制终端\n3.  周期性的执行某种任务\n4.  不受用户登陆和注销的影响\n<!--more-->\n5.  一般采用以d结尾的名字\n\n### 进程组和会话\n\n进程组: 一个进程包含多个进程  \n会话: 多个组组成一个会话.\n\n创建会话的进程不能是组长进程;  \n一般创建会话是父进程先fork子进程, 然后父进程退出, 让子进程调用setsid函数  \n创建一个会话, 这个子进程既是会长也是组长;  \n只要是创建了会话, 这个进程就脱离了控制终端的影响.\n\n![[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-zja3K36a-1623649224301)(Untitled.assets/image-20210614124433571.png)]](https://img-blog.csdnimg.cn/20210614134052443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)\n\n### 创建守护进程\n\n 1.     父进程fork子进程, 然后父进程退出.  \n    目的是: 子进程肯定不是组长进程, 为后续调用setsid函数提供了条件.\n 2.     子进程调用setsid函数创建一个新的会话.  \n    该子进程成了该会话的会长  \n    该子进程成了该组的组长进程.  \n    不再受控制终端的影响了\n 3.     改变当前的工作目录, chdir -----不是必须的\n 4.     重设文件掩码, umask\\(0000\\) -----不是必须的\n 5.     关闭STDIN\\_FILENO STDOUT\\_FILENO STDERR\\_FILENO —不是必须的\n 6.     核心操作\n\n```c\n//创建守护进程\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <signal.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/time.h>\n\nvoid myfunc(int signo)\n{\n\t//打开文件\n\tint fd = open(\"mydemon.log\", O_RDWR | O_CREAT | O_APPEND, 0755);\n\tif(fd<0)\n\t{\n\t\treturn;\n\t}\n\n\t//获取当前的系统时间\n\ttime_t t;\n\ttime(&t);\n\tchar *p = ctime(&t);\n\t\n\t//将时间写入文件\n\twrite(fd, p, strlen(p));\n\n\tclose(fd);\n\n\treturn;\n}\n\nint main()\n{\n\t//父进程fork子进程, 然后父进程退出\n\tpid_t pid = fork();\n\tif(pid<0 || pid>0)\n\t{\n\t\texit(1);\n\t}\n\t\n\t//子进程调用setsid函数创建会话\n\tsetsid();\n\n\t//改变当前的工作目录\n\tchdir(\"/home/itcast/log\");\n\n\t//改变文件掩码\n\tumask(0000);\n\n\t//关闭标准输入,输出和错误输出文件描述符\n\tclose(STDIN_FILENO);\n\tclose(STDOUT_FILENO);\n\tclose(STDERR_FILENO);\n\n\t//核心操作\n\t//注册信号处理函数\n\tstruct sigaction act;\n\tact.sa_handler = myfunc;\n\tact.sa_flags = 0;\n\tsigemptyset(&act.sa_mask);\t\n\tsigaction(SIGALRM, &act, NULL);\n\n\t//设置时钟\n\tstruct itimerval tm;\n\ttm.it_interval.tv_sec = 2;\n\ttm.it_interval.tv_usec = 0;\n\ttm.it_value.tv_sec = 3;\n\ttm.it_value.tv_usec = 0;\n\tsetitimer(ITIMER_REAL, &tm, NULL);\n\n\tprintf(\"hello world\\n\");\n\n\twhile(1)\n\t{\n\t\tsleep(1);\n\t}\n}\n```","slug":"Linux系统编程-守护进程","published":1,"updated":"2023-08-15T12:59:46.722Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllcdfgkd000ii7jx44iq7zcl","content":"<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ol>\n<li> Linux后台服务进程</li>\n<li> 独立于控制终端</li>\n<li> 周期性的执行某种任务</li>\n<li> 不受用户登陆和注销的影响<span id=\"more\"></span></li>\n<li> 一般采用以d结尾的名字</li>\n</ol>\n<h3 id=\"进程组和会话\"><a href=\"#进程组和会话\" class=\"headerlink\" title=\"进程组和会话\"></a>进程组和会话</h3><p>进程组: 一个进程包含多个进程<br>会话: 多个组组成一个会话.</p>\n<p>创建会话的进程不能是组长进程;<br>一般创建会话是父进程先fork子进程, 然后父进程退出, 让子进程调用setsid函数<br>创建一个会话, 这个子进程既是会长也是组长;<br>只要是创建了会话, 这个进程就脱离了控制终端的影响.</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210614134052443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-zja3K36a-1623649224301)(Untitled.assets/image-20210614124433571.png)]\"></p>\n<h3 id=\"创建守护进程\"><a href=\"#创建守护进程\" class=\"headerlink\" title=\"创建守护进程\"></a>创建守护进程</h3><ol>\n<li>父进程fork子进程, 然后父进程退出.<br>目的是: 子进程肯定不是组长进程, 为后续调用setsid函数提供了条件.</li>\n<li>子进程调用setsid函数创建一个新的会话.<br>该子进程成了该会话的会长<br>该子进程成了该组的组长进程.<br>不再受控制终端的影响了</li>\n<li><pre><code>改变当前的工作目录, chdir -----不是必须的\n</code></pre>\n</li>\n<li><pre><code>重设文件掩码, umask\\(0000\\) -----不是必须的\n</code></pre>\n</li>\n<li><pre><code>关闭STDIN\\_FILENO STDOUT\\_FILENO STDERR\\_FILENO —不是必须的\n</code></pre>\n</li>\n<li><pre><code>核心操作\n</code></pre>\n</li>\n</ol>\n<pre><code class=\"c\">//创建守护进程\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;signal.h&gt;\n#include &lt;time.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;sys/time.h&gt;\n\nvoid myfunc(int signo)\n&#123;\n    //打开文件\n    int fd = open(&quot;mydemon.log&quot;, O_RDWR | O_CREAT | O_APPEND, 0755);\n    if(fd&lt;0)\n    &#123;\n        return;\n    &#125;\n\n    //获取当前的系统时间\n    time_t t;\n    time(&amp;t);\n    char *p = ctime(&amp;t);\n    \n    //将时间写入文件\n    write(fd, p, strlen(p));\n\n    close(fd);\n\n    return;\n&#125;\n\nint main()\n&#123;\n    //父进程fork子进程, 然后父进程退出\n    pid_t pid = fork();\n    if(pid&lt;0 || pid&gt;0)\n    &#123;\n        exit(1);\n    &#125;\n    \n    //子进程调用setsid函数创建会话\n    setsid();\n\n    //改变当前的工作目录\n    chdir(&quot;/home/itcast/log&quot;);\n\n    //改变文件掩码\n    umask(0000);\n\n    //关闭标准输入,输出和错误输出文件描述符\n    close(STDIN_FILENO);\n    close(STDOUT_FILENO);\n    close(STDERR_FILENO);\n\n    //核心操作\n    //注册信号处理函数\n    struct sigaction act;\n    act.sa_handler = myfunc;\n    act.sa_flags = 0;\n    sigemptyset(&amp;act.sa_mask);    \n    sigaction(SIGALRM, &amp;act, NULL);\n\n    //设置时钟\n    struct itimerval tm;\n    tm.it_interval.tv_sec = 2;\n    tm.it_interval.tv_usec = 0;\n    tm.it_value.tv_sec = 3;\n    tm.it_value.tv_usec = 0;\n    setitimer(ITIMER_REAL, &amp;tm, NULL);\n\n    printf(&quot;hello world\\n&quot;);\n\n    while(1)\n    &#123;\n        sleep(1);\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ol>\n<li> Linux后台服务进程</li>\n<li> 独立于控制终端</li>\n<li> 周期性的执行某种任务</li>\n<li> 不受用户登陆和注销的影响","more":"</li>\n<li> 一般采用以d结尾的名字</li>\n</ol>\n<h3 id=\"进程组和会话\"><a href=\"#进程组和会话\" class=\"headerlink\" title=\"进程组和会话\"></a>进程组和会话</h3><p>进程组: 一个进程包含多个进程<br>会话: 多个组组成一个会话.</p>\n<p>创建会话的进程不能是组长进程;<br>一般创建会话是父进程先fork子进程, 然后父进程退出, 让子进程调用setsid函数<br>创建一个会话, 这个子进程既是会长也是组长;<br>只要是创建了会话, 这个进程就脱离了控制终端的影响.</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210614134052443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-zja3K36a-1623649224301)(Untitled.assets/image-20210614124433571.png)]\"></p>\n<h3 id=\"创建守护进程\"><a href=\"#创建守护进程\" class=\"headerlink\" title=\"创建守护进程\"></a>创建守护进程</h3><ol>\n<li>父进程fork子进程, 然后父进程退出.<br>目的是: 子进程肯定不是组长进程, 为后续调用setsid函数提供了条件.</li>\n<li>子进程调用setsid函数创建一个新的会话.<br>该子进程成了该会话的会长<br>该子进程成了该组的组长进程.<br>不再受控制终端的影响了</li>\n<li><pre><code>改变当前的工作目录, chdir -----不是必须的\n</code></pre>\n</li>\n<li><pre><code>重设文件掩码, umask\\(0000\\) -----不是必须的\n</code></pre>\n</li>\n<li><pre><code>关闭STDIN\\_FILENO STDOUT\\_FILENO STDERR\\_FILENO —不是必须的\n</code></pre>\n</li>\n<li><pre><code>核心操作\n</code></pre>\n</li>\n</ol>\n<pre><code class=\"c\">//创建守护进程\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;signal.h&gt;\n#include &lt;time.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;sys/time.h&gt;\n\nvoid myfunc(int signo)\n&#123;\n    //打开文件\n    int fd = open(&quot;mydemon.log&quot;, O_RDWR | O_CREAT | O_APPEND, 0755);\n    if(fd&lt;0)\n    &#123;\n        return;\n    &#125;\n\n    //获取当前的系统时间\n    time_t t;\n    time(&amp;t);\n    char *p = ctime(&amp;t);\n    \n    //将时间写入文件\n    write(fd, p, strlen(p));\n\n    close(fd);\n\n    return;\n&#125;\n\nint main()\n&#123;\n    //父进程fork子进程, 然后父进程退出\n    pid_t pid = fork();\n    if(pid&lt;0 || pid&gt;0)\n    &#123;\n        exit(1);\n    &#125;\n    \n    //子进程调用setsid函数创建会话\n    setsid();\n\n    //改变当前的工作目录\n    chdir(&quot;/home/itcast/log&quot;);\n\n    //改变文件掩码\n    umask(0000);\n\n    //关闭标准输入,输出和错误输出文件描述符\n    close(STDIN_FILENO);\n    close(STDOUT_FILENO);\n    close(STDERR_FILENO);\n\n    //核心操作\n    //注册信号处理函数\n    struct sigaction act;\n    act.sa_handler = myfunc;\n    act.sa_flags = 0;\n    sigemptyset(&amp;act.sa_mask);    \n    sigaction(SIGALRM, &amp;act, NULL);\n\n    //设置时钟\n    struct itimerval tm;\n    tm.it_interval.tv_sec = 2;\n    tm.it_interval.tv_usec = 0;\n    tm.it_value.tv_sec = 3;\n    tm.it_value.tv_usec = 0;\n    setitimer(ITIMER_REAL, &amp;tm, NULL);\n\n    printf(&quot;hello world\\n&quot;);\n\n    while(1)\n    &#123;\n        sleep(1);\n    &#125;\n&#125;\n</code></pre>"},{"title":"Linux系统编程-进程控制","date":"2021-06-10T05:09:41.000Z","_content":"\n\n### 基本概念\n\n#### 程序和进程\n\n1.  程序：编译好的二进制文件，占用磁盘空间，静态\n2.  进程：程序的运行过程，占用内存、CPU等，动态\n<!--more-->\n\n#### 并行和并发\n\n1.  并行：一边吃饭一边看电影，这就是并行\n2.  并发：在一个时间段内, 是在同一个cpu上, 同时运行多个程序。如：若将CPU的1S的时间分成1000个时间片，每个进程执行完一个时间片必须无条件让出CPU的使用权，这样1S中就可以执行1000个进程。**简单来说就是可以先暂停吃饭去看电影，再暂停看电影去吃饭，这就是并发**\n\n#### 进程状态\n\n初始态，就绪态，运行态，挂起态与终止态\n\n### 创建进程\n\nFork函数\n\n1.  函数作用：创建子进程\n2.  原型: pid\\_t fork\\(void\\);\n3.  函数参数：无\n4.  返回值：调用成功:父进程返回子进程的PID，子进程返回0； 调用失败:返回-1，设置errno值。\n\n● fork函数代码片段实例\n\n```c\n......\n\tpid_t pid = fork();\n\tif(pid<0)\n\t{\n\t\tperror(\"fork error\");\n\t\treturn -1;\n\t}\n\telse if(pid>0)\n\t{\n\t\tprintf(\"father: [%d], pid==[%d], fpid==[%d]\\n\", pid, getpid(),getppid());\n\t\t//sleep(1);\n\t}\n\telse if(pid==0) \n\t{\n\t\tprintf(\"child: pid==[%d], fpid==[%d]\\n\", getpid(), getppid());\n\t}\n......\n```\n\n### exec函数族\n\n如果想在一个进程内部执行系统命令或者是应用程序, 可以使用execl和execlp函数拉起可执行程序或者命令.\n\n 1.     execl\\(\\) 通常用来执行用户自定义程序\n 2.     execlp\\(\\) 通常用力啊执行系统命令，如要执行自定义程序，需将程序加入系统环境变量\n\n```c\n.......\nelse if(pid==0) //子进程\n\t{\n\t\tprintf(\"child: pid==[%d], fpid==[%d]\\n\", getpid(), getppid());\n\t\texecl(\"/bin/ls\", \"ls\", \"-l\", NULL);\n\t\texecl(\"./test\", \"test\", \"hello\", \"world\", \"ni\", \"hao\", NULL);\n\t\texeclp(\"ls\", \"ls\", \"-l\", NULL);\n......\n```\n\n### 回收进程\n\n当一个进程退出之后，进程能够回收自己的用户区的资源，但是不能回收内核空间的PCB资源，必须由它的父进程调用wait或者waitpid函数完成对子进程的回收，避免造成系统资源的浪费。\n\n#### 孤儿进程\n\n孤儿进程是指父进程已死而子进程还活着，此时子进程就是孤儿进程。  \n孤儿进程会被init进程领养。\n\n#### 僵尸进程\n\n若子进程死了，父进程还活着， 并且父进程没有调用wait或waitpid函数回收子进程，此时子进程就成了僵尸进程。  \n由于僵尸进程已死，不能用kill命令杀死子进程，回收子进程的方法如下：  \n杀死父进程->僵尸进程被init进程领养->由init回收\n\n#### 回收函数\n\n##### 函数原型\n\n```c\n#include <sys/wait.h>\npid_t wait(int * statloc);\npid_t waitpid(pid_t pid,int *statloc,int options);\n```\n\n调用wait或waitpid的进程发生的情况如下：\n\n1.  如果所有子进程都还在运行，则阻塞\n2.  如果一个子进程已终止，正等待父进程获取其终止状态，则取得该子进程的终止状态立即返回\n3.  如果它没有任何子进程，则立即出错返回","source":"_posts/Linux系统编程-进程控制.md","raw":"---\ntitle: Linux系统编程-进程控制\ndate: 2021-06-10 13:09:41\ntags: \ncategories: Linux\n---\n\n\n### 基本概念\n\n#### 程序和进程\n\n1.  程序：编译好的二进制文件，占用磁盘空间，静态\n2.  进程：程序的运行过程，占用内存、CPU等，动态\n<!--more-->\n\n#### 并行和并发\n\n1.  并行：一边吃饭一边看电影，这就是并行\n2.  并发：在一个时间段内, 是在同一个cpu上, 同时运行多个程序。如：若将CPU的1S的时间分成1000个时间片，每个进程执行完一个时间片必须无条件让出CPU的使用权，这样1S中就可以执行1000个进程。**简单来说就是可以先暂停吃饭去看电影，再暂停看电影去吃饭，这就是并发**\n\n#### 进程状态\n\n初始态，就绪态，运行态，挂起态与终止态\n\n### 创建进程\n\nFork函数\n\n1.  函数作用：创建子进程\n2.  原型: pid\\_t fork\\(void\\);\n3.  函数参数：无\n4.  返回值：调用成功:父进程返回子进程的PID，子进程返回0； 调用失败:返回-1，设置errno值。\n\n● fork函数代码片段实例\n\n```c\n......\n\tpid_t pid = fork();\n\tif(pid<0)\n\t{\n\t\tperror(\"fork error\");\n\t\treturn -1;\n\t}\n\telse if(pid>0)\n\t{\n\t\tprintf(\"father: [%d], pid==[%d], fpid==[%d]\\n\", pid, getpid(),getppid());\n\t\t//sleep(1);\n\t}\n\telse if(pid==0) \n\t{\n\t\tprintf(\"child: pid==[%d], fpid==[%d]\\n\", getpid(), getppid());\n\t}\n......\n```\n\n### exec函数族\n\n如果想在一个进程内部执行系统命令或者是应用程序, 可以使用execl和execlp函数拉起可执行程序或者命令.\n\n 1.     execl\\(\\) 通常用来执行用户自定义程序\n 2.     execlp\\(\\) 通常用力啊执行系统命令，如要执行自定义程序，需将程序加入系统环境变量\n\n```c\n.......\nelse if(pid==0) //子进程\n\t{\n\t\tprintf(\"child: pid==[%d], fpid==[%d]\\n\", getpid(), getppid());\n\t\texecl(\"/bin/ls\", \"ls\", \"-l\", NULL);\n\t\texecl(\"./test\", \"test\", \"hello\", \"world\", \"ni\", \"hao\", NULL);\n\t\texeclp(\"ls\", \"ls\", \"-l\", NULL);\n......\n```\n\n### 回收进程\n\n当一个进程退出之后，进程能够回收自己的用户区的资源，但是不能回收内核空间的PCB资源，必须由它的父进程调用wait或者waitpid函数完成对子进程的回收，避免造成系统资源的浪费。\n\n#### 孤儿进程\n\n孤儿进程是指父进程已死而子进程还活着，此时子进程就是孤儿进程。  \n孤儿进程会被init进程领养。\n\n#### 僵尸进程\n\n若子进程死了，父进程还活着， 并且父进程没有调用wait或waitpid函数回收子进程，此时子进程就成了僵尸进程。  \n由于僵尸进程已死，不能用kill命令杀死子进程，回收子进程的方法如下：  \n杀死父进程->僵尸进程被init进程领养->由init回收\n\n#### 回收函数\n\n##### 函数原型\n\n```c\n#include <sys/wait.h>\npid_t wait(int * statloc);\npid_t waitpid(pid_t pid,int *statloc,int options);\n```\n\n调用wait或waitpid的进程发生的情况如下：\n\n1.  如果所有子进程都还在运行，则阻塞\n2.  如果一个子进程已终止，正等待父进程获取其终止状态，则取得该子进程的终止状态立即返回\n3.  如果它没有任何子进程，则立即出错返回","slug":"Linux系统编程-进程控制","published":1,"updated":"2023-08-15T12:59:46.706Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllcdfgke000ki7jx0pwp66c6","content":"<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><h4 id=\"程序和进程\"><a href=\"#程序和进程\" class=\"headerlink\" title=\"程序和进程\"></a>程序和进程</h4><ol>\n<li> 程序：编译好的二进制文件，占用磁盘空间，静态</li>\n<li> 进程：程序的运行过程，占用内存、CPU等，动态<span id=\"more\"></span></li>\n</ol>\n<h4 id=\"并行和并发\"><a href=\"#并行和并发\" class=\"headerlink\" title=\"并行和并发\"></a>并行和并发</h4><ol>\n<li> 并行：一边吃饭一边看电影，这就是并行</li>\n<li> 并发：在一个时间段内, 是在同一个cpu上, 同时运行多个程序。如：若将CPU的1S的时间分成1000个时间片，每个进程执行完一个时间片必须无条件让出CPU的使用权，这样1S中就可以执行1000个进程。<strong>简单来说就是可以先暂停吃饭去看电影，再暂停看电影去吃饭，这就是并发</strong></li>\n</ol>\n<h4 id=\"进程状态\"><a href=\"#进程状态\" class=\"headerlink\" title=\"进程状态\"></a>进程状态</h4><p>初始态，就绪态，运行态，挂起态与终止态</p>\n<h3 id=\"创建进程\"><a href=\"#创建进程\" class=\"headerlink\" title=\"创建进程\"></a>创建进程</h3><p>Fork函数</p>\n<ol>\n<li> 函数作用：创建子进程</li>\n<li> 原型: pid_t fork(void);</li>\n<li> 函数参数：无</li>\n<li> 返回值：调用成功:父进程返回子进程的PID，子进程返回0； 调用失败:返回-1，设置errno值。</li>\n</ol>\n<p>● fork函数代码片段实例</p>\n<pre><code class=\"c\">......\n    pid_t pid = fork();\n    if(pid&lt;0)\n    &#123;\n        perror(&quot;fork error&quot;);\n        return -1;\n    &#125;\n    else if(pid&gt;0)\n    &#123;\n        printf(&quot;father: [%d], pid==[%d], fpid==[%d]\\n&quot;, pid, getpid(),getppid());\n        //sleep(1);\n    &#125;\n    else if(pid==0) \n    &#123;\n        printf(&quot;child: pid==[%d], fpid==[%d]\\n&quot;, getpid(), getppid());\n    &#125;\n......\n</code></pre>\n<h3 id=\"exec函数族\"><a href=\"#exec函数族\" class=\"headerlink\" title=\"exec函数族\"></a>exec函数族</h3><p>如果想在一个进程内部执行系统命令或者是应用程序, 可以使用execl和execlp函数拉起可执行程序或者命令.</p>\n<ol>\n<li><pre><code>execl\\(\\) 通常用来执行用户自定义程序\n</code></pre>\n</li>\n<li><pre><code>execlp\\(\\) 通常用力啊执行系统命令，如要执行自定义程序，需将程序加入系统环境变量\n</code></pre>\n</li>\n</ol>\n<pre><code class=\"c\">.......\nelse if(pid==0) //子进程\n    &#123;\n        printf(&quot;child: pid==[%d], fpid==[%d]\\n&quot;, getpid(), getppid());\n        execl(&quot;/bin/ls&quot;, &quot;ls&quot;, &quot;-l&quot;, NULL);\n        execl(&quot;./test&quot;, &quot;test&quot;, &quot;hello&quot;, &quot;world&quot;, &quot;ni&quot;, &quot;hao&quot;, NULL);\n        execlp(&quot;ls&quot;, &quot;ls&quot;, &quot;-l&quot;, NULL);\n......\n</code></pre>\n<h3 id=\"回收进程\"><a href=\"#回收进程\" class=\"headerlink\" title=\"回收进程\"></a>回收进程</h3><p>当一个进程退出之后，进程能够回收自己的用户区的资源，但是不能回收内核空间的PCB资源，必须由它的父进程调用wait或者waitpid函数完成对子进程的回收，避免造成系统资源的浪费。</p>\n<h4 id=\"孤儿进程\"><a href=\"#孤儿进程\" class=\"headerlink\" title=\"孤儿进程\"></a>孤儿进程</h4><p>孤儿进程是指父进程已死而子进程还活着，此时子进程就是孤儿进程。<br>孤儿进程会被init进程领养。</p>\n<h4 id=\"僵尸进程\"><a href=\"#僵尸进程\" class=\"headerlink\" title=\"僵尸进程\"></a>僵尸进程</h4><p>若子进程死了，父进程还活着， 并且父进程没有调用wait或waitpid函数回收子进程，此时子进程就成了僵尸进程。<br>由于僵尸进程已死，不能用kill命令杀死子进程，回收子进程的方法如下：<br>杀死父进程-&gt;僵尸进程被init进程领养-&gt;由init回收</p>\n<h4 id=\"回收函数\"><a href=\"#回收函数\" class=\"headerlink\" title=\"回收函数\"></a>回收函数</h4><h5 id=\"函数原型\"><a href=\"#函数原型\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h5><pre><code class=\"c\">#include &lt;sys/wait.h&gt;\npid_t wait(int * statloc);\npid_t waitpid(pid_t pid,int *statloc,int options);\n</code></pre>\n<p>调用wait或waitpid的进程发生的情况如下：</p>\n<ol>\n<li> 如果所有子进程都还在运行，则阻塞</li>\n<li> 如果一个子进程已终止，正等待父进程获取其终止状态，则取得该子进程的终止状态立即返回</li>\n<li> 如果它没有任何子进程，则立即出错返回</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><h4 id=\"程序和进程\"><a href=\"#程序和进程\" class=\"headerlink\" title=\"程序和进程\"></a>程序和进程</h4><ol>\n<li> 程序：编译好的二进制文件，占用磁盘空间，静态</li>\n<li> 进程：程序的运行过程，占用内存、CPU等，动态","more":"</li>\n</ol>\n<h4 id=\"并行和并发\"><a href=\"#并行和并发\" class=\"headerlink\" title=\"并行和并发\"></a>并行和并发</h4><ol>\n<li> 并行：一边吃饭一边看电影，这就是并行</li>\n<li> 并发：在一个时间段内, 是在同一个cpu上, 同时运行多个程序。如：若将CPU的1S的时间分成1000个时间片，每个进程执行完一个时间片必须无条件让出CPU的使用权，这样1S中就可以执行1000个进程。<strong>简单来说就是可以先暂停吃饭去看电影，再暂停看电影去吃饭，这就是并发</strong></li>\n</ol>\n<h4 id=\"进程状态\"><a href=\"#进程状态\" class=\"headerlink\" title=\"进程状态\"></a>进程状态</h4><p>初始态，就绪态，运行态，挂起态与终止态</p>\n<h3 id=\"创建进程\"><a href=\"#创建进程\" class=\"headerlink\" title=\"创建进程\"></a>创建进程</h3><p>Fork函数</p>\n<ol>\n<li> 函数作用：创建子进程</li>\n<li> 原型: pid_t fork(void);</li>\n<li> 函数参数：无</li>\n<li> 返回值：调用成功:父进程返回子进程的PID，子进程返回0； 调用失败:返回-1，设置errno值。</li>\n</ol>\n<p>● fork函数代码片段实例</p>\n<pre><code class=\"c\">......\n    pid_t pid = fork();\n    if(pid&lt;0)\n    &#123;\n        perror(&quot;fork error&quot;);\n        return -1;\n    &#125;\n    else if(pid&gt;0)\n    &#123;\n        printf(&quot;father: [%d], pid==[%d], fpid==[%d]\\n&quot;, pid, getpid(),getppid());\n        //sleep(1);\n    &#125;\n    else if(pid==0) \n    &#123;\n        printf(&quot;child: pid==[%d], fpid==[%d]\\n&quot;, getpid(), getppid());\n    &#125;\n......\n</code></pre>\n<h3 id=\"exec函数族\"><a href=\"#exec函数族\" class=\"headerlink\" title=\"exec函数族\"></a>exec函数族</h3><p>如果想在一个进程内部执行系统命令或者是应用程序, 可以使用execl和execlp函数拉起可执行程序或者命令.</p>\n<ol>\n<li><pre><code>execl\\(\\) 通常用来执行用户自定义程序\n</code></pre>\n</li>\n<li><pre><code>execlp\\(\\) 通常用力啊执行系统命令，如要执行自定义程序，需将程序加入系统环境变量\n</code></pre>\n</li>\n</ol>\n<pre><code class=\"c\">.......\nelse if(pid==0) //子进程\n    &#123;\n        printf(&quot;child: pid==[%d], fpid==[%d]\\n&quot;, getpid(), getppid());\n        execl(&quot;/bin/ls&quot;, &quot;ls&quot;, &quot;-l&quot;, NULL);\n        execl(&quot;./test&quot;, &quot;test&quot;, &quot;hello&quot;, &quot;world&quot;, &quot;ni&quot;, &quot;hao&quot;, NULL);\n        execlp(&quot;ls&quot;, &quot;ls&quot;, &quot;-l&quot;, NULL);\n......\n</code></pre>\n<h3 id=\"回收进程\"><a href=\"#回收进程\" class=\"headerlink\" title=\"回收进程\"></a>回收进程</h3><p>当一个进程退出之后，进程能够回收自己的用户区的资源，但是不能回收内核空间的PCB资源，必须由它的父进程调用wait或者waitpid函数完成对子进程的回收，避免造成系统资源的浪费。</p>\n<h4 id=\"孤儿进程\"><a href=\"#孤儿进程\" class=\"headerlink\" title=\"孤儿进程\"></a>孤儿进程</h4><p>孤儿进程是指父进程已死而子进程还活着，此时子进程就是孤儿进程。<br>孤儿进程会被init进程领养。</p>\n<h4 id=\"僵尸进程\"><a href=\"#僵尸进程\" class=\"headerlink\" title=\"僵尸进程\"></a>僵尸进程</h4><p>若子进程死了，父进程还活着， 并且父进程没有调用wait或waitpid函数回收子进程，此时子进程就成了僵尸进程。<br>由于僵尸进程已死，不能用kill命令杀死子进程，回收子进程的方法如下：<br>杀死父进程-&gt;僵尸进程被init进程领养-&gt;由init回收</p>\n<h4 id=\"回收函数\"><a href=\"#回收函数\" class=\"headerlink\" title=\"回收函数\"></a>回收函数</h4><h5 id=\"函数原型\"><a href=\"#函数原型\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h5><pre><code class=\"c\">#include &lt;sys/wait.h&gt;\npid_t wait(int * statloc);\npid_t waitpid(pid_t pid,int *statloc,int options);\n</code></pre>\n<p>调用wait或waitpid的进程发生的情况如下：</p>\n<ol>\n<li> 如果所有子进程都还在运行，则阻塞</li>\n<li> 如果一个子进程已终止，正等待父进程获取其终止状态，则取得该子进程的终止状态立即返回</li>\n<li> 如果它没有任何子进程，则立即出错返回</li>\n</ol>"},{"title":"Linux系统编程-进程间通讯","date":"2021-06-13T06:17:36.000Z","_content":"\n\n### 基本概念\n\nLinux环境下，进程地址空间相互独立，每个进程都有不同的用户地址空间，一个进程的全局变量在另一个中是看不到的，要交换数据必须通过内核，在内核中开辟一块缓冲区，一个进程写，另一个读，这种机制就是**进程间通信**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210613141653818.png)\n\n<!--more-->\n常用的进程间的通讯方式有以下几种：\n\n1.  管道 \\(使用最简单\\)\n2.  信号 \\(开销最小\\)\n3.  共享映射区 \\(无血缘关系\\)\n4.  本地套接字 \\(最稳定\\)\n\n### 管道Pipe\n\n#### 创建管道\n\n**pipe函数**\n\n1.  函数作用: 创建一个管道\n2.  函数原型: int pipe\\(int fd\\[2\\]\\);\n3.  函数参数: 若函数调用成功，fd\\[0\\]存放管道的读端，fd\\[1\\]存放管道的写端\n4.  返回值: 成功返回0；失败返回-1，并设置errno值。\n\n函数调用成功返回读端和写端的文件描述符，其中fd\\[0\\]是读端， fd\\[1\\]是写端\\*\\*，\\*\\*向管道读写数据是通过使用这两个文件描述符进行的，读写管道的实质是操作内核缓冲区\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021061314171373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)\n\n**创建步骤总结：**\n\n 1.     父进程调用pipe函数创建管道，得到两个文件描述符fd\\[0\\]和fd\\[1\\]，分别指向管道的读端和写端。\n 2.     父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管。\n 3.     父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出，这样就实现了父子进程间通信。\n\n```c\n......\nint main()\n{\n    int fd[2];\n    int ret = pipe(fd);\n    if(ret<0)\n    {\n        perror(\"pipe error\");\n        return -1;\n    }\n\n    pid_t pid=fork();\n    if((pid<0))\n    {\n        perror(\"fork error\");\n        return -1;\n    }\n    else if(pid>0)\n    {\n        close(fd[0]);\n        sleep(5);\n        write(fd[1],\"hello world\",strlen(\"hello world\"));\n        wait(NULL);\n    }\n    else\n    {\n        close(fd[1]);\n        char buf[64];\n        memset(buf,0x00,sizeof(buf));\n        int n=read(fd[0],buf,sizeof(buf));\n        printf(\"read over, n==[%d], buf==[%s]\\n\", n, buf);\n    }\n    return 0;\n}\n......\n```\n\n### FIFO\n\n**FIFO常被称为命名管道**，以区分管道\\(pipe\\)。管道\\(pipe\\)只能用于“有血缘关系”的进程间通信。但通过FIFO，不相关的进程也能交换数据。\n\n创建方式：\n\n1.  **命令**：mkfifo 管道名\n\n2.  **库函数**：int mkfifo\\(const char \\*pathname, mode\\_t mode\\); 成功：0； 失败：-1\n\n    一旦使用mkfifo创建了一个FIFO，就可以使用open打开它，常见的文件I/O函数都可用于fifo。如：close、read、write、unlink等。\n\n使用FIFO进行进程间通讯：\n\n进程A：\n\n1.  创建一个fifo文件：myfifo\n2.  调用open函数打开myfifo文件\n3.  调用write函数写入一个字符串如：“hello world”（其实是将数据写入到了内核缓冲区）\n4.  调用close函数关闭myfifo文件\n\n进程B：\n\n1.  调用open函数打开myfifo文件\n2.  调用read函数读取文件内容（其实就是从内核中读取数据）\n3.  打印显示读取的内容\n4.  调用close函数关闭myfifo文件","source":"_posts/Linux系统编程-进程间通讯.md","raw":"---\ntitle: Linux系统编程-进程间通讯\ndate: 2021-06-13 14:17:36\ntags: \ncategories: Linux\n---\n\n\n### 基本概念\n\nLinux环境下，进程地址空间相互独立，每个进程都有不同的用户地址空间，一个进程的全局变量在另一个中是看不到的，要交换数据必须通过内核，在内核中开辟一块缓冲区，一个进程写，另一个读，这种机制就是**进程间通信**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210613141653818.png)\n\n<!--more-->\n常用的进程间的通讯方式有以下几种：\n\n1.  管道 \\(使用最简单\\)\n2.  信号 \\(开销最小\\)\n3.  共享映射区 \\(无血缘关系\\)\n4.  本地套接字 \\(最稳定\\)\n\n### 管道Pipe\n\n#### 创建管道\n\n**pipe函数**\n\n1.  函数作用: 创建一个管道\n2.  函数原型: int pipe\\(int fd\\[2\\]\\);\n3.  函数参数: 若函数调用成功，fd\\[0\\]存放管道的读端，fd\\[1\\]存放管道的写端\n4.  返回值: 成功返回0；失败返回-1，并设置errno值。\n\n函数调用成功返回读端和写端的文件描述符，其中fd\\[0\\]是读端， fd\\[1\\]是写端\\*\\*，\\*\\*向管道读写数据是通过使用这两个文件描述符进行的，读写管道的实质是操作内核缓冲区\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021061314171373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)\n\n**创建步骤总结：**\n\n 1.     父进程调用pipe函数创建管道，得到两个文件描述符fd\\[0\\]和fd\\[1\\]，分别指向管道的读端和写端。\n 2.     父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管。\n 3.     父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出，这样就实现了父子进程间通信。\n\n```c\n......\nint main()\n{\n    int fd[2];\n    int ret = pipe(fd);\n    if(ret<0)\n    {\n        perror(\"pipe error\");\n        return -1;\n    }\n\n    pid_t pid=fork();\n    if((pid<0))\n    {\n        perror(\"fork error\");\n        return -1;\n    }\n    else if(pid>0)\n    {\n        close(fd[0]);\n        sleep(5);\n        write(fd[1],\"hello world\",strlen(\"hello world\"));\n        wait(NULL);\n    }\n    else\n    {\n        close(fd[1]);\n        char buf[64];\n        memset(buf,0x00,sizeof(buf));\n        int n=read(fd[0],buf,sizeof(buf));\n        printf(\"read over, n==[%d], buf==[%s]\\n\", n, buf);\n    }\n    return 0;\n}\n......\n```\n\n### FIFO\n\n**FIFO常被称为命名管道**，以区分管道\\(pipe\\)。管道\\(pipe\\)只能用于“有血缘关系”的进程间通信。但通过FIFO，不相关的进程也能交换数据。\n\n创建方式：\n\n1.  **命令**：mkfifo 管道名\n\n2.  **库函数**：int mkfifo\\(const char \\*pathname, mode\\_t mode\\); 成功：0； 失败：-1\n\n    一旦使用mkfifo创建了一个FIFO，就可以使用open打开它，常见的文件I/O函数都可用于fifo。如：close、read、write、unlink等。\n\n使用FIFO进行进程间通讯：\n\n进程A：\n\n1.  创建一个fifo文件：myfifo\n2.  调用open函数打开myfifo文件\n3.  调用write函数写入一个字符串如：“hello world”（其实是将数据写入到了内核缓冲区）\n4.  调用close函数关闭myfifo文件\n\n进程B：\n\n1.  调用open函数打开myfifo文件\n2.  调用read函数读取文件内容（其实就是从内核中读取数据）\n3.  打印显示读取的内容\n4.  调用close函数关闭myfifo文件","slug":"Linux系统编程-进程间通讯","published":1,"updated":"2023-08-15T12:59:46.690Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllcdfgkg000ni7jxcxhvcrrp","content":"<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>Linux环境下，进程地址空间相互独立，每个进程都有不同的用户地址空间，一个进程的全局变量在另一个中是看不到的，要交换数据必须通过内核，在内核中开辟一块缓冲区，一个进程写，另一个读，这种机制就是<strong>进程间通信</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210613141653818.png\" alt=\"在这里插入图片描述\"></p>\n<span id=\"more\"></span>\n<p>常用的进程间的通讯方式有以下几种：</p>\n<ol>\n<li> 管道 (使用最简单)</li>\n<li> 信号 (开销最小)</li>\n<li> 共享映射区 (无血缘关系)</li>\n<li> 本地套接字 (最稳定)</li>\n</ol>\n<h3 id=\"管道Pipe\"><a href=\"#管道Pipe\" class=\"headerlink\" title=\"管道Pipe\"></a>管道Pipe</h3><h4 id=\"创建管道\"><a href=\"#创建管道\" class=\"headerlink\" title=\"创建管道\"></a>创建管道</h4><p><strong>pipe函数</strong></p>\n<ol>\n<li> 函数作用: 创建一个管道</li>\n<li> 函数原型: int pipe(int fd[2]);</li>\n<li> 函数参数: 若函数调用成功，fd[0]存放管道的读端，fd[1]存放管道的写端</li>\n<li> 返回值: 成功返回0；失败返回-1，并设置errno值。</li>\n</ol>\n<p>函数调用成功返回读端和写端的文件描述符，其中fd[0]是读端， fd[1]是写端**，**向管道读写数据是通过使用这两个文件描述符进行的，读写管道的实质是操作内核缓冲区</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2021061314171373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p><strong>创建步骤总结：</strong></p>\n<ol>\n<li><pre><code>父进程调用pipe函数创建管道，得到两个文件描述符fd\\[0\\]和fd\\[1\\]，分别指向管道的读端和写端。\n</code></pre>\n</li>\n<li><pre><code>父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管。\n</code></pre>\n</li>\n<li><pre><code>父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出，这样就实现了父子进程间通信。\n</code></pre>\n</li>\n</ol>\n<pre><code class=\"c\">......\nint main()\n&#123;\n    int fd[2];\n    int ret = pipe(fd);\n    if(ret&lt;0)\n    &#123;\n        perror(&quot;pipe error&quot;);\n        return -1;\n    &#125;\n\n    pid_t pid=fork();\n    if((pid&lt;0))\n    &#123;\n        perror(&quot;fork error&quot;);\n        return -1;\n    &#125;\n    else if(pid&gt;0)\n    &#123;\n        close(fd[0]);\n        sleep(5);\n        write(fd[1],&quot;hello world&quot;,strlen(&quot;hello world&quot;));\n        wait(NULL);\n    &#125;\n    else\n    &#123;\n        close(fd[1]);\n        char buf[64];\n        memset(buf,0x00,sizeof(buf));\n        int n=read(fd[0],buf,sizeof(buf));\n        printf(&quot;read over, n==[%d], buf==[%s]\\n&quot;, n, buf);\n    &#125;\n    return 0;\n&#125;\n......\n</code></pre>\n<h3 id=\"FIFO\"><a href=\"#FIFO\" class=\"headerlink\" title=\"FIFO\"></a>FIFO</h3><p><strong>FIFO常被称为命名管道</strong>，以区分管道(pipe)。管道(pipe)只能用于“有血缘关系”的进程间通信。但通过FIFO，不相关的进程也能交换数据。</p>\n<p>创建方式：</p>\n<ol>\n<li><p> <strong>命令</strong>：mkfifo 管道名</p>\n</li>\n<li><p><strong>库函数</strong>：int mkfifo(const char *pathname, mode_t mode); 成功：0； 失败：-1</p>\n<p> 一旦使用mkfifo创建了一个FIFO，就可以使用open打开它，常见的文件I/O函数都可用于fifo。如：close、read、write、unlink等。</p>\n</li>\n</ol>\n<p>使用FIFO进行进程间通讯：</p>\n<p>进程A：</p>\n<ol>\n<li> 创建一个fifo文件：myfifo</li>\n<li> 调用open函数打开myfifo文件</li>\n<li> 调用write函数写入一个字符串如：“hello world”（其实是将数据写入到了内核缓冲区）</li>\n<li> 调用close函数关闭myfifo文件</li>\n</ol>\n<p>进程B：</p>\n<ol>\n<li> 调用open函数打开myfifo文件</li>\n<li> 调用read函数读取文件内容（其实就是从内核中读取数据）</li>\n<li> 打印显示读取的内容</li>\n<li> 调用close函数关闭myfifo文件</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>Linux环境下，进程地址空间相互独立，每个进程都有不同的用户地址空间，一个进程的全局变量在另一个中是看不到的，要交换数据必须通过内核，在内核中开辟一块缓冲区，一个进程写，另一个读，这种机制就是<strong>进程间通信</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210613141653818.png\" alt=\"在这里插入图片描述\"></p>","more":"<p>常用的进程间的通讯方式有以下几种：</p>\n<ol>\n<li> 管道 (使用最简单)</li>\n<li> 信号 (开销最小)</li>\n<li> 共享映射区 (无血缘关系)</li>\n<li> 本地套接字 (最稳定)</li>\n</ol>\n<h3 id=\"管道Pipe\"><a href=\"#管道Pipe\" class=\"headerlink\" title=\"管道Pipe\"></a>管道Pipe</h3><h4 id=\"创建管道\"><a href=\"#创建管道\" class=\"headerlink\" title=\"创建管道\"></a>创建管道</h4><p><strong>pipe函数</strong></p>\n<ol>\n<li> 函数作用: 创建一个管道</li>\n<li> 函数原型: int pipe(int fd[2]);</li>\n<li> 函数参数: 若函数调用成功，fd[0]存放管道的读端，fd[1]存放管道的写端</li>\n<li> 返回值: 成功返回0；失败返回-1，并设置errno值。</li>\n</ol>\n<p>函数调用成功返回读端和写端的文件描述符，其中fd[0]是读端， fd[1]是写端**，**向管道读写数据是通过使用这两个文件描述符进行的，读写管道的实质是操作内核缓冲区</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2021061314171373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p><strong>创建步骤总结：</strong></p>\n<ol>\n<li><pre><code>父进程调用pipe函数创建管道，得到两个文件描述符fd\\[0\\]和fd\\[1\\]，分别指向管道的读端和写端。\n</code></pre>\n</li>\n<li><pre><code>父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管。\n</code></pre>\n</li>\n<li><pre><code>父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出，这样就实现了父子进程间通信。\n</code></pre>\n</li>\n</ol>\n<pre><code class=\"c\">......\nint main()\n&#123;\n    int fd[2];\n    int ret = pipe(fd);\n    if(ret&lt;0)\n    &#123;\n        perror(&quot;pipe error&quot;);\n        return -1;\n    &#125;\n\n    pid_t pid=fork();\n    if((pid&lt;0))\n    &#123;\n        perror(&quot;fork error&quot;);\n        return -1;\n    &#125;\n    else if(pid&gt;0)\n    &#123;\n        close(fd[0]);\n        sleep(5);\n        write(fd[1],&quot;hello world&quot;,strlen(&quot;hello world&quot;));\n        wait(NULL);\n    &#125;\n    else\n    &#123;\n        close(fd[1]);\n        char buf[64];\n        memset(buf,0x00,sizeof(buf));\n        int n=read(fd[0],buf,sizeof(buf));\n        printf(&quot;read over, n==[%d], buf==[%s]\\n&quot;, n, buf);\n    &#125;\n    return 0;\n&#125;\n......\n</code></pre>\n<h3 id=\"FIFO\"><a href=\"#FIFO\" class=\"headerlink\" title=\"FIFO\"></a>FIFO</h3><p><strong>FIFO常被称为命名管道</strong>，以区分管道(pipe)。管道(pipe)只能用于“有血缘关系”的进程间通信。但通过FIFO，不相关的进程也能交换数据。</p>\n<p>创建方式：</p>\n<ol>\n<li><p> <strong>命令</strong>：mkfifo 管道名</p>\n</li>\n<li><p><strong>库函数</strong>：int mkfifo(const char *pathname, mode_t mode); 成功：0； 失败：-1</p>\n<p> 一旦使用mkfifo创建了一个FIFO，就可以使用open打开它，常见的文件I/O函数都可用于fifo。如：close、read、write、unlink等。</p>\n</li>\n</ol>\n<p>使用FIFO进行进程间通讯：</p>\n<p>进程A：</p>\n<ol>\n<li> 创建一个fifo文件：myfifo</li>\n<li> 调用open函数打开myfifo文件</li>\n<li> 调用write函数写入一个字符串如：“hello world”（其实是将数据写入到了内核缓冲区）</li>\n<li> 调用close函数关闭myfifo文件</li>\n</ol>\n<p>进程B：</p>\n<ol>\n<li> 调用open函数打开myfifo文件</li>\n<li> 调用read函数读取文件内容（其实就是从内核中读取数据）</li>\n<li> 打印显示读取的内容</li>\n<li> 调用close函数关闭myfifo文件</li>\n</ol>"},{"title":"Python学习-从面向对象开始","date":"2021-06-21T14:30:25.000Z","_content":"\n\n### Python学习-从面向对象开始\n\n- [面向对象](#_1)\n- - [类和实例](#_2)\n  - [访问限制](#_75)\n  - [继承和多态](#_88)\n<!--more-->\n\n# 面向对象\n\n## 类和实例\n\n**面向对象编程**\\(Object Oriented Programming\\)\\(OOP\\)，是一种程序设计思想\n\n与之相对应的事**面向过程编程**\\(Procedure Oriented Programming\\)\\(POP\\) 两者区别如下：\n\n把大象放进冰箱需要几个步骤？\n\n 1.     面向过程编程：  \n    打开冰箱、放进大象、关闭冰箱\n\n```python\ndef open_icebox():\n    print(\"open icebox\")\n\ndef close_icebox():\n    print(\"close icebox\")\n\ndef put_elephant():\n    print(\"put elephant\")    \n\nif __name__ == \"__main__\":\n    open_icebox()\n    put_elephant()\n    close_icebox()\n```\n\n 2.     面向对象编程：  \n    冰箱一个类，大象一个类，放的动作一个类\n\n```python\nclass icebox():\n    def __init__(self,size,brand):\n        self.size = size\n        self.brand = brand\n    \n    def open_icebox(self):\n        print(\"open size:%d brand:%s icebox\" % (self.size,self.brand))\n\n    def close_icebox(self):\n        print(\"close size:%d brand:%s icebox\" % (self.size,self.brand)) \n\n\nclass elephant():\n    def __init__(self,size,type):\n        self.size = size\n        self.type = type  \n\n    def print_arr(self):\n        print(\"elephant size is:%d type is:%s \" % (self.size,self.type)) \n\nclass action():\n    def __init__(self,action) -> None:\n        self.action = action\n    \n    def start_action(self):\n        if self.action == 'put':\n            print('put')\n        elif self.action == 'get':\n            print('get')\n\n\nif __name__ == \"__main__\":\n    icebox = icebox(100,'songxia')\n    elephant = elephant(10,'yazhouxiang')\n    action = action('put')\n\n    icebox.open_icebox()\n    action.start_action()\n    elephant.print_arr()\n    icebox.close_icebox()\n```\n\n面向对象是以功能来划分问题，功能上的统一保证了面向对象设计的**可扩展性**。比如我想把大象取出，就只需要在动作类中添加取出的方法即可，并且可以更改冰箱的种类、大象的种类\n\n其中\\_\\_init\\_\\_方法的第一个参数永远是self，表示创建的实例本身，此方法有点类似与C++中的构造函数，比如一个人在出生时就携带了自身的属性，如人类、男性这样的属性，\\_\\_init\\_\\_方法就是在创建一个实例的同时，初始化一个自带的属性。\n\n## 访问限制\n\n类的最重要的属性之一就是**封装**，即从外部无法直接访问到类的属性\n\n与C++中类的关键字private关键字类似，python中也有类似的方法，如下在init方法中加上双下划线即可\n\n```python\nclass icebox():\n    def __init__(self,size,brand):\n        self.__size = size\n        self.__brand = brand\n```\n\n此时如果想访问或更改类属性，就可以在类中定义相应的方法，通过类方法更改类属性，同时可以在方法中，可以对参数做检查，避免传入无效的参数\n\n## 继承和多态\n\n类的第二个特性-**继承**\n\n子类可以继承父类的所有方法，如果需要子类自己的方法，只需要在子类中重写父类的方法就会自动覆盖\n\n```python\nclass elephant():\n    def run(self):\n        print(\"elephant is runing\") \n\nclass asia_elephant(elephant):\n    pass\n\nif __name__ == \"__main__\":\n    elephant = asia_elephant()\n    elephant.run()\n```\n\n类的第二个特性-**多态**\n\n在如下代码中可以发现函数run\\_twice\\(elephant\\)中传入不同的实例对象时，其结果也随之变化，这就是多态\n\n```python\nclass elephant(object):\n    def run(self):\n        print(\"elephant is runing\") \n\nclass asia_elephant(elephant):\n    def run(self):\n        print(\"asia elephant is runing\")\n\nclass africa_elephant(elephant):\n    def run(self):\n        print(\"africa elephant is runing\")\n\nif __name__ == \"__main__\":\n    asia_elephant = asia_elephant()\n    africa_elephant = africa_elephant()\n\n    def run_twice(elephant):\n        elephant.run()\n        elephant.run()\n    \n    run_twice(asia_elephant)\n    run_twice(africa_elephant)\n\n```\n","source":"_posts/Python学习-从面向对象开始.md","raw":"---\ntitle: Python学习-从面向对象开始\ndate: 2021-06-21 22:30:25\ntags: \ncategories: Python\n---\n\n\n### Python学习-从面向对象开始\n\n- [面向对象](#_1)\n- - [类和实例](#_2)\n  - [访问限制](#_75)\n  - [继承和多态](#_88)\n<!--more-->\n\n# 面向对象\n\n## 类和实例\n\n**面向对象编程**\\(Object Oriented Programming\\)\\(OOP\\)，是一种程序设计思想\n\n与之相对应的事**面向过程编程**\\(Procedure Oriented Programming\\)\\(POP\\) 两者区别如下：\n\n把大象放进冰箱需要几个步骤？\n\n 1.     面向过程编程：  \n    打开冰箱、放进大象、关闭冰箱\n\n```python\ndef open_icebox():\n    print(\"open icebox\")\n\ndef close_icebox():\n    print(\"close icebox\")\n\ndef put_elephant():\n    print(\"put elephant\")    \n\nif __name__ == \"__main__\":\n    open_icebox()\n    put_elephant()\n    close_icebox()\n```\n\n 2.     面向对象编程：  \n    冰箱一个类，大象一个类，放的动作一个类\n\n```python\nclass icebox():\n    def __init__(self,size,brand):\n        self.size = size\n        self.brand = brand\n    \n    def open_icebox(self):\n        print(\"open size:%d brand:%s icebox\" % (self.size,self.brand))\n\n    def close_icebox(self):\n        print(\"close size:%d brand:%s icebox\" % (self.size,self.brand)) \n\n\nclass elephant():\n    def __init__(self,size,type):\n        self.size = size\n        self.type = type  \n\n    def print_arr(self):\n        print(\"elephant size is:%d type is:%s \" % (self.size,self.type)) \n\nclass action():\n    def __init__(self,action) -> None:\n        self.action = action\n    \n    def start_action(self):\n        if self.action == 'put':\n            print('put')\n        elif self.action == 'get':\n            print('get')\n\n\nif __name__ == \"__main__\":\n    icebox = icebox(100,'songxia')\n    elephant = elephant(10,'yazhouxiang')\n    action = action('put')\n\n    icebox.open_icebox()\n    action.start_action()\n    elephant.print_arr()\n    icebox.close_icebox()\n```\n\n面向对象是以功能来划分问题，功能上的统一保证了面向对象设计的**可扩展性**。比如我想把大象取出，就只需要在动作类中添加取出的方法即可，并且可以更改冰箱的种类、大象的种类\n\n其中\\_\\_init\\_\\_方法的第一个参数永远是self，表示创建的实例本身，此方法有点类似与C++中的构造函数，比如一个人在出生时就携带了自身的属性，如人类、男性这样的属性，\\_\\_init\\_\\_方法就是在创建一个实例的同时，初始化一个自带的属性。\n\n## 访问限制\n\n类的最重要的属性之一就是**封装**，即从外部无法直接访问到类的属性\n\n与C++中类的关键字private关键字类似，python中也有类似的方法，如下在init方法中加上双下划线即可\n\n```python\nclass icebox():\n    def __init__(self,size,brand):\n        self.__size = size\n        self.__brand = brand\n```\n\n此时如果想访问或更改类属性，就可以在类中定义相应的方法，通过类方法更改类属性，同时可以在方法中，可以对参数做检查，避免传入无效的参数\n\n## 继承和多态\n\n类的第二个特性-**继承**\n\n子类可以继承父类的所有方法，如果需要子类自己的方法，只需要在子类中重写父类的方法就会自动覆盖\n\n```python\nclass elephant():\n    def run(self):\n        print(\"elephant is runing\") \n\nclass asia_elephant(elephant):\n    pass\n\nif __name__ == \"__main__\":\n    elephant = asia_elephant()\n    elephant.run()\n```\n\n类的第二个特性-**多态**\n\n在如下代码中可以发现函数run\\_twice\\(elephant\\)中传入不同的实例对象时，其结果也随之变化，这就是多态\n\n```python\nclass elephant(object):\n    def run(self):\n        print(\"elephant is runing\") \n\nclass asia_elephant(elephant):\n    def run(self):\n        print(\"asia elephant is runing\")\n\nclass africa_elephant(elephant):\n    def run(self):\n        print(\"africa elephant is runing\")\n\nif __name__ == \"__main__\":\n    asia_elephant = asia_elephant()\n    africa_elephant = africa_elephant()\n\n    def run_twice(elephant):\n        elephant.run()\n        elephant.run()\n    \n    run_twice(asia_elephant)\n    run_twice(africa_elephant)\n\n```\n","slug":"Python学习-从面向对象开始","published":1,"updated":"2023-08-15T12:59:46.674Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllcdfgkh000pi7jxfpay5tsd","content":"<h3 id=\"Python学习-从面向对象开始\"><a href=\"#Python学习-从面向对象开始\" class=\"headerlink\" title=\"Python学习-从面向对象开始\"></a>Python学习-从面向对象开始</h3><ul>\n<li><a href=\"#_1\">面向对象</a></li>\n<li><ul>\n<li><a href=\"#_2\">类和实例</a></li>\n<li><a href=\"#_75\">访问限制</a></li>\n<li><a href=\"#_88\">继承和多态</a><span id=\"more\"></span></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h1><h2 id=\"类和实例\"><a href=\"#类和实例\" class=\"headerlink\" title=\"类和实例\"></a>类和实例</h2><p><strong>面向对象编程</strong>(Object Oriented Programming)(OOP)，是一种程序设计思想</p>\n<p>与之相对应的事<strong>面向过程编程</strong>(Procedure Oriented Programming)(POP) 两者区别如下：</p>\n<p>把大象放进冰箱需要几个步骤？</p>\n<ol>\n<li>面向过程编程：<br>打开冰箱、放进大象、关闭冰箱</li>\n</ol>\n<pre><code class=\"python\">def open_icebox():\n    print(&quot;open icebox&quot;)\n\ndef close_icebox():\n    print(&quot;close icebox&quot;)\n\ndef put_elephant():\n    print(&quot;put elephant&quot;)    \n\nif __name__ == &quot;__main__&quot;:\n    open_icebox()\n    put_elephant()\n    close_icebox()\n</code></pre>\n<ol start=\"2\">\n<li>面向对象编程：<br>冰箱一个类，大象一个类，放的动作一个类</li>\n</ol>\n<pre><code class=\"python\">class icebox():\n    def __init__(self,size,brand):\n        self.size = size\n        self.brand = brand\n    \n    def open_icebox(self):\n        print(&quot;open size:%d brand:%s icebox&quot; % (self.size,self.brand))\n\n    def close_icebox(self):\n        print(&quot;close size:%d brand:%s icebox&quot; % (self.size,self.brand)) \n\n\nclass elephant():\n    def __init__(self,size,type):\n        self.size = size\n        self.type = type  \n\n    def print_arr(self):\n        print(&quot;elephant size is:%d type is:%s &quot; % (self.size,self.type)) \n\nclass action():\n    def __init__(self,action) -&gt; None:\n        self.action = action\n    \n    def start_action(self):\n        if self.action == &#39;put&#39;:\n            print(&#39;put&#39;)\n        elif self.action == &#39;get&#39;:\n            print(&#39;get&#39;)\n\n\nif __name__ == &quot;__main__&quot;:\n    icebox = icebox(100,&#39;songxia&#39;)\n    elephant = elephant(10,&#39;yazhouxiang&#39;)\n    action = action(&#39;put&#39;)\n\n    icebox.open_icebox()\n    action.start_action()\n    elephant.print_arr()\n    icebox.close_icebox()\n</code></pre>\n<p>面向对象是以功能来划分问题，功能上的统一保证了面向对象设计的<strong>可扩展性</strong>。比如我想把大象取出，就只需要在动作类中添加取出的方法即可，并且可以更改冰箱的种类、大象的种类</p>\n<p>其中__init__方法的第一个参数永远是self，表示创建的实例本身，此方法有点类似与C++中的构造函数，比如一个人在出生时就携带了自身的属性，如人类、男性这样的属性，__init__方法就是在创建一个实例的同时，初始化一个自带的属性。</p>\n<h2 id=\"访问限制\"><a href=\"#访问限制\" class=\"headerlink\" title=\"访问限制\"></a>访问限制</h2><p>类的最重要的属性之一就是<strong>封装</strong>，即从外部无法直接访问到类的属性</p>\n<p>与C++中类的关键字private关键字类似，python中也有类似的方法，如下在init方法中加上双下划线即可</p>\n<pre><code class=\"python\">class icebox():\n    def __init__(self,size,brand):\n        self.__size = size\n        self.__brand = brand\n</code></pre>\n<p>此时如果想访问或更改类属性，就可以在类中定义相应的方法，通过类方法更改类属性，同时可以在方法中，可以对参数做检查，避免传入无效的参数</p>\n<h2 id=\"继承和多态\"><a href=\"#继承和多态\" class=\"headerlink\" title=\"继承和多态\"></a>继承和多态</h2><p>类的第二个特性-<strong>继承</strong></p>\n<p>子类可以继承父类的所有方法，如果需要子类自己的方法，只需要在子类中重写父类的方法就会自动覆盖</p>\n<pre><code class=\"python\">class elephant():\n    def run(self):\n        print(&quot;elephant is runing&quot;) \n\nclass asia_elephant(elephant):\n    pass\n\nif __name__ == &quot;__main__&quot;:\n    elephant = asia_elephant()\n    elephant.run()\n</code></pre>\n<p>类的第二个特性-<strong>多态</strong></p>\n<p>在如下代码中可以发现函数run_twice(elephant)中传入不同的实例对象时，其结果也随之变化，这就是多态</p>\n<pre><code class=\"python\">class elephant(object):\n    def run(self):\n        print(&quot;elephant is runing&quot;) \n\nclass asia_elephant(elephant):\n    def run(self):\n        print(&quot;asia elephant is runing&quot;)\n\nclass africa_elephant(elephant):\n    def run(self):\n        print(&quot;africa elephant is runing&quot;)\n\nif __name__ == &quot;__main__&quot;:\n    asia_elephant = asia_elephant()\n    africa_elephant = africa_elephant()\n\n    def run_twice(elephant):\n        elephant.run()\n        elephant.run()\n    \n    run_twice(asia_elephant)\n    run_twice(africa_elephant)\n</code></pre>\n","site":{"data":{}},"excerpt":"<h3 id=\"Python学习-从面向对象开始\"><a href=\"#Python学习-从面向对象开始\" class=\"headerlink\" title=\"Python学习-从面向对象开始\"></a>Python学习-从面向对象开始</h3><ul>\n<li><a href=\"#_1\">面向对象</a></li>\n<li><ul>\n<li><a href=\"#_2\">类和实例</a></li>\n<li><a href=\"#_75\">访问限制</a></li>\n<li><a href=\"#_88\">继承和多态</a>","more":"</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h1><h2 id=\"类和实例\"><a href=\"#类和实例\" class=\"headerlink\" title=\"类和实例\"></a>类和实例</h2><p><strong>面向对象编程</strong>(Object Oriented Programming)(OOP)，是一种程序设计思想</p>\n<p>与之相对应的事<strong>面向过程编程</strong>(Procedure Oriented Programming)(POP) 两者区别如下：</p>\n<p>把大象放进冰箱需要几个步骤？</p>\n<ol>\n<li>面向过程编程：<br>打开冰箱、放进大象、关闭冰箱</li>\n</ol>\n<pre><code class=\"python\">def open_icebox():\n    print(&quot;open icebox&quot;)\n\ndef close_icebox():\n    print(&quot;close icebox&quot;)\n\ndef put_elephant():\n    print(&quot;put elephant&quot;)    \n\nif __name__ == &quot;__main__&quot;:\n    open_icebox()\n    put_elephant()\n    close_icebox()\n</code></pre>\n<ol start=\"2\">\n<li>面向对象编程：<br>冰箱一个类，大象一个类，放的动作一个类</li>\n</ol>\n<pre><code class=\"python\">class icebox():\n    def __init__(self,size,brand):\n        self.size = size\n        self.brand = brand\n    \n    def open_icebox(self):\n        print(&quot;open size:%d brand:%s icebox&quot; % (self.size,self.brand))\n\n    def close_icebox(self):\n        print(&quot;close size:%d brand:%s icebox&quot; % (self.size,self.brand)) \n\n\nclass elephant():\n    def __init__(self,size,type):\n        self.size = size\n        self.type = type  \n\n    def print_arr(self):\n        print(&quot;elephant size is:%d type is:%s &quot; % (self.size,self.type)) \n\nclass action():\n    def __init__(self,action) -&gt; None:\n        self.action = action\n    \n    def start_action(self):\n        if self.action == &#39;put&#39;:\n            print(&#39;put&#39;)\n        elif self.action == &#39;get&#39;:\n            print(&#39;get&#39;)\n\n\nif __name__ == &quot;__main__&quot;:\n    icebox = icebox(100,&#39;songxia&#39;)\n    elephant = elephant(10,&#39;yazhouxiang&#39;)\n    action = action(&#39;put&#39;)\n\n    icebox.open_icebox()\n    action.start_action()\n    elephant.print_arr()\n    icebox.close_icebox()\n</code></pre>\n<p>面向对象是以功能来划分问题，功能上的统一保证了面向对象设计的<strong>可扩展性</strong>。比如我想把大象取出，就只需要在动作类中添加取出的方法即可，并且可以更改冰箱的种类、大象的种类</p>\n<p>其中__init__方法的第一个参数永远是self，表示创建的实例本身，此方法有点类似与C++中的构造函数，比如一个人在出生时就携带了自身的属性，如人类、男性这样的属性，__init__方法就是在创建一个实例的同时，初始化一个自带的属性。</p>\n<h2 id=\"访问限制\"><a href=\"#访问限制\" class=\"headerlink\" title=\"访问限制\"></a>访问限制</h2><p>类的最重要的属性之一就是<strong>封装</strong>，即从外部无法直接访问到类的属性</p>\n<p>与C++中类的关键字private关键字类似，python中也有类似的方法，如下在init方法中加上双下划线即可</p>\n<pre><code class=\"python\">class icebox():\n    def __init__(self,size,brand):\n        self.__size = size\n        self.__brand = brand\n</code></pre>\n<p>此时如果想访问或更改类属性，就可以在类中定义相应的方法，通过类方法更改类属性，同时可以在方法中，可以对参数做检查，避免传入无效的参数</p>\n<h2 id=\"继承和多态\"><a href=\"#继承和多态\" class=\"headerlink\" title=\"继承和多态\"></a>继承和多态</h2><p>类的第二个特性-<strong>继承</strong></p>\n<p>子类可以继承父类的所有方法，如果需要子类自己的方法，只需要在子类中重写父类的方法就会自动覆盖</p>\n<pre><code class=\"python\">class elephant():\n    def run(self):\n        print(&quot;elephant is runing&quot;) \n\nclass asia_elephant(elephant):\n    pass\n\nif __name__ == &quot;__main__&quot;:\n    elephant = asia_elephant()\n    elephant.run()\n</code></pre>\n<p>类的第二个特性-<strong>多态</strong></p>\n<p>在如下代码中可以发现函数run_twice(elephant)中传入不同的实例对象时，其结果也随之变化，这就是多态</p>\n<pre><code class=\"python\">class elephant(object):\n    def run(self):\n        print(&quot;elephant is runing&quot;) \n\nclass asia_elephant(elephant):\n    def run(self):\n        print(&quot;asia elephant is runing&quot;)\n\nclass africa_elephant(elephant):\n    def run(self):\n        print(&quot;africa elephant is runing&quot;)\n\nif __name__ == &quot;__main__&quot;:\n    asia_elephant = asia_elephant()\n    africa_elephant = africa_elephant()\n\n    def run_twice(elephant):\n        elephant.run()\n        elephant.run()\n    \n    run_twice(asia_elephant)\n    run_twice(africa_elephant)\n</code></pre>"},{"title":"Python学习-多线程和多进程","date":"2021-06-23T14:33:04.000Z","_content":"\n\n### Python学习-多线程和多进程\n\n- [基本概念](#_1)\n- [线程](#_4)\n- - [线程的创建](#_5)\n  - [线程共享全局变量和锁](#_29)\n<!--more-->\n- [进程](#_81)\n- - [进程的创建](#_82)\n  - [进程间的通信](#_117)\n\n# 基本概念\n\n1.  进程：程序的一次执行\n2.  线程：CPU的基本调度单位\n\n# 线程\n\n## 线程的创建\n\n线程的创建主要通过threading模块\n\n```python\nprint('主线程开始')\n\nfrom threading import Thread\nimport threading\nfrom time import sleep\n\ndef sub_fun(arg1,arg2):\n    print('子线程开始')\n    print('子线程函数参数时：{0},{1}'.format(arg1,arg2))\n    sleep(5)\n    print('子进程结束')\n\nthread = Thread(target=sub_fun, args=('参数1','参数2'))\n\nthread.start()\n\nthread.join()\n\nprint('主线程结束')\n```\n\n## 线程共享全局变量和锁\n\n在一个进程内的所有线程共享全局变量，很方便在多个线程间共享数据  \n缺点就是，线程是对全局变量随意遂改可能造成多线程之间对全局变量的混乱（即线程非安全）\n\n```python\nfrom threading import Thread\nimport time\n\nnum = 0 \n\ndef add1(n):\n    global num\n    for i in range(n):\n        num = num+1\n    print('in add1, num is {0}\\n'.format(num))\n    \ndef add2(n):\n    global num\n    for i in range(n):\n        num = num+1\n    print('in add2, num is {0}\\n'.format(num))   \n\nthread1 = Thread(target=add1, args=(1000000,))\nthread1.start()\n\nthread2 = Thread(target=add2, args=(1000000,))\nthread2.start()\n\ntime.sleep(5)\nprint('final num is {0}\\n'.format(num))\n```\n\n最后运行的结果是\n\n```python\nin add2, num is 1295511\nin add1, num is 1324484\nfinal num is 1324484\n```\n\n对num加1，2000000次，结果却不是2000000，这是由于线程共享全局变量\n\n在num=0时，thread1 thread2同时取得num=0。  \n此时thread1 sleeping，thread2 running， thread2使num=1  \n然后thread2 sleeping，thread1 running， thread1使num=1  \n这就导致两个线程重复操作了两次，num结果仍是1\n\n简单来说就是线程被覆盖了，这时可以使用 threading库里面的锁对象 Lock 去保护\n\n```python\nlock = threading.Lock()\n\nlock.acquire()\nlock.release()\n```\n\n# 进程\n\n## 进程的创建\n\n在python中进程的创建主要通过Process函数  \nProcess\\(\\[group \\[, target \\[, name \\[, args \\[, kwargs\\]\\]\\]\\]\\]\\)\n\n1.  target：如果传递了函数的引用，可以任务这个子进程就执行这里的代码\n2.  args：给target指定的函数传递的参数，以元组的方式传递\n3.  kwargs：给target指定的函数传递命名参数\n4.  name：给进程设定一个名字，可以不设定\n5.  group：指定进程组，大多数情况下用不到\n\nProcess创建的实例对象的常用方法：\n\n1.  start\\(\\)：启动子进程实例（创建子进程）\n2.  is\\_alive\\(\\)：判断进程子进程是否还在活着\n3.  join\\(\\[timeout\\]\\)：是否等待子进程执行结束，或等待多少秒\n4.  terminate\\(\\)：不管任务是否完成，立即终止子进程\n\nProcess创建的实例对象的常用属性：\n\n 1.     name：当前进程的别名，默认为Process-N，N为从1开始递增的整\n 2.     pid：当前进程的pid（进程号）\n\n```python\nfrom multiprocessing import Process\nimport os\nimport time\n\ndef sub_fun():\n        print('子进程运行中，pid=%d...' % os.getpid())\n\nif __name__ == '__main__':\n    print('父进程pid: %d' % os.getpid())\n    for i in range(3):\n        p = Process(target=sub_fun)\n        p.start()\n```\n\n## 进程间的通信\n\n进程间有多种通信机制，下面就常用的Queue为例进行说明\n\n```python\nfrom multiprocessing import Process,Queue\nimport os,time,random\n\ndef write(q):\n    for value in ['a','b','c']:\n        print('put {0} to queue'.format(value))\n        q.put(value)\n        time.sleep(random.random())\n\ndef read(q):\n    while not q.empty():#此处死循环，ctrl+c终止\n        value = q.get(True)\n        print('get {0} to queue'.format(value))\n        q.put(value)\n        time.sleep(random.random())\n\nif __name__ == '__main__':\n    q = Queue()\n\n    pw = Process(target=write, args=(q,))\n    pr = Process(target=read, args=(q,))\n\n    pw.start()\n    pw.join()\n\n    pr.start()\n    pr.join()\n\n    print('-----ok------')\n```\n","source":"_posts/Python学习-多线程和多进程.md","raw":"---\ntitle: Python学习-多线程和多进程\ndate: 2021-06-23 22:33:04\ntags: \ncategories: Python\n---\n\n\n### Python学习-多线程和多进程\n\n- [基本概念](#_1)\n- [线程](#_4)\n- - [线程的创建](#_5)\n  - [线程共享全局变量和锁](#_29)\n<!--more-->\n- [进程](#_81)\n- - [进程的创建](#_82)\n  - [进程间的通信](#_117)\n\n# 基本概念\n\n1.  进程：程序的一次执行\n2.  线程：CPU的基本调度单位\n\n# 线程\n\n## 线程的创建\n\n线程的创建主要通过threading模块\n\n```python\nprint('主线程开始')\n\nfrom threading import Thread\nimport threading\nfrom time import sleep\n\ndef sub_fun(arg1,arg2):\n    print('子线程开始')\n    print('子线程函数参数时：{0},{1}'.format(arg1,arg2))\n    sleep(5)\n    print('子进程结束')\n\nthread = Thread(target=sub_fun, args=('参数1','参数2'))\n\nthread.start()\n\nthread.join()\n\nprint('主线程结束')\n```\n\n## 线程共享全局变量和锁\n\n在一个进程内的所有线程共享全局变量，很方便在多个线程间共享数据  \n缺点就是，线程是对全局变量随意遂改可能造成多线程之间对全局变量的混乱（即线程非安全）\n\n```python\nfrom threading import Thread\nimport time\n\nnum = 0 \n\ndef add1(n):\n    global num\n    for i in range(n):\n        num = num+1\n    print('in add1, num is {0}\\n'.format(num))\n    \ndef add2(n):\n    global num\n    for i in range(n):\n        num = num+1\n    print('in add2, num is {0}\\n'.format(num))   \n\nthread1 = Thread(target=add1, args=(1000000,))\nthread1.start()\n\nthread2 = Thread(target=add2, args=(1000000,))\nthread2.start()\n\ntime.sleep(5)\nprint('final num is {0}\\n'.format(num))\n```\n\n最后运行的结果是\n\n```python\nin add2, num is 1295511\nin add1, num is 1324484\nfinal num is 1324484\n```\n\n对num加1，2000000次，结果却不是2000000，这是由于线程共享全局变量\n\n在num=0时，thread1 thread2同时取得num=0。  \n此时thread1 sleeping，thread2 running， thread2使num=1  \n然后thread2 sleeping，thread1 running， thread1使num=1  \n这就导致两个线程重复操作了两次，num结果仍是1\n\n简单来说就是线程被覆盖了，这时可以使用 threading库里面的锁对象 Lock 去保护\n\n```python\nlock = threading.Lock()\n\nlock.acquire()\nlock.release()\n```\n\n# 进程\n\n## 进程的创建\n\n在python中进程的创建主要通过Process函数  \nProcess\\(\\[group \\[, target \\[, name \\[, args \\[, kwargs\\]\\]\\]\\]\\]\\)\n\n1.  target：如果传递了函数的引用，可以任务这个子进程就执行这里的代码\n2.  args：给target指定的函数传递的参数，以元组的方式传递\n3.  kwargs：给target指定的函数传递命名参数\n4.  name：给进程设定一个名字，可以不设定\n5.  group：指定进程组，大多数情况下用不到\n\nProcess创建的实例对象的常用方法：\n\n1.  start\\(\\)：启动子进程实例（创建子进程）\n2.  is\\_alive\\(\\)：判断进程子进程是否还在活着\n3.  join\\(\\[timeout\\]\\)：是否等待子进程执行结束，或等待多少秒\n4.  terminate\\(\\)：不管任务是否完成，立即终止子进程\n\nProcess创建的实例对象的常用属性：\n\n 1.     name：当前进程的别名，默认为Process-N，N为从1开始递增的整\n 2.     pid：当前进程的pid（进程号）\n\n```python\nfrom multiprocessing import Process\nimport os\nimport time\n\ndef sub_fun():\n        print('子进程运行中，pid=%d...' % os.getpid())\n\nif __name__ == '__main__':\n    print('父进程pid: %d' % os.getpid())\n    for i in range(3):\n        p = Process(target=sub_fun)\n        p.start()\n```\n\n## 进程间的通信\n\n进程间有多种通信机制，下面就常用的Queue为例进行说明\n\n```python\nfrom multiprocessing import Process,Queue\nimport os,time,random\n\ndef write(q):\n    for value in ['a','b','c']:\n        print('put {0} to queue'.format(value))\n        q.put(value)\n        time.sleep(random.random())\n\ndef read(q):\n    while not q.empty():#此处死循环，ctrl+c终止\n        value = q.get(True)\n        print('get {0} to queue'.format(value))\n        q.put(value)\n        time.sleep(random.random())\n\nif __name__ == '__main__':\n    q = Queue()\n\n    pw = Process(target=write, args=(q,))\n    pr = Process(target=read, args=(q,))\n\n    pw.start()\n    pw.join()\n\n    pr.start()\n    pr.join()\n\n    print('-----ok------')\n```\n","slug":"Python学习-多线程和多进程","published":1,"updated":"2023-08-15T12:59:46.654Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllcdfgki000si7jxcgyo6ujw","content":"<h3 id=\"Python学习-多线程和多进程\"><a href=\"#Python学习-多线程和多进程\" class=\"headerlink\" title=\"Python学习-多线程和多进程\"></a>Python学习-多线程和多进程</h3><ul>\n<li><a href=\"#_1\">基本概念</a></li>\n<li><a href=\"#_4\">线程</a></li>\n<li><ul>\n<li><a href=\"#_5\">线程的创建</a></li>\n<li><a href=\"#_29\">线程共享全局变量和锁</a><span id=\"more\"></span></li>\n</ul>\n</li>\n<li><a href=\"#_81\">进程</a></li>\n<li><ul>\n<li><a href=\"#_82\">进程的创建</a></li>\n<li><a href=\"#_117\">进程间的通信</a></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><ol>\n<li> 进程：程序的一次执行</li>\n<li> 线程：CPU的基本调度单位</li>\n</ol>\n<h1 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h1><h2 id=\"线程的创建\"><a href=\"#线程的创建\" class=\"headerlink\" title=\"线程的创建\"></a>线程的创建</h2><p>线程的创建主要通过threading模块</p>\n<pre><code class=\"python\">print(&#39;主线程开始&#39;)\n\nfrom threading import Thread\nimport threading\nfrom time import sleep\n\ndef sub_fun(arg1,arg2):\n    print(&#39;子线程开始&#39;)\n    print(&#39;子线程函数参数时：&#123;0&#125;,&#123;1&#125;&#39;.format(arg1,arg2))\n    sleep(5)\n    print(&#39;子进程结束&#39;)\n\nthread = Thread(target=sub_fun, args=(&#39;参数1&#39;,&#39;参数2&#39;))\n\nthread.start()\n\nthread.join()\n\nprint(&#39;主线程结束&#39;)\n</code></pre>\n<h2 id=\"线程共享全局变量和锁\"><a href=\"#线程共享全局变量和锁\" class=\"headerlink\" title=\"线程共享全局变量和锁\"></a>线程共享全局变量和锁</h2><p>在一个进程内的所有线程共享全局变量，很方便在多个线程间共享数据<br>缺点就是，线程是对全局变量随意遂改可能造成多线程之间对全局变量的混乱（即线程非安全）</p>\n<pre><code class=\"python\">from threading import Thread\nimport time\n\nnum = 0 \n\ndef add1(n):\n    global num\n    for i in range(n):\n        num = num+1\n    print(&#39;in add1, num is &#123;0&#125;\\n&#39;.format(num))\n    \ndef add2(n):\n    global num\n    for i in range(n):\n        num = num+1\n    print(&#39;in add2, num is &#123;0&#125;\\n&#39;.format(num))   \n\nthread1 = Thread(target=add1, args=(1000000,))\nthread1.start()\n\nthread2 = Thread(target=add2, args=(1000000,))\nthread2.start()\n\ntime.sleep(5)\nprint(&#39;final num is &#123;0&#125;\\n&#39;.format(num))\n</code></pre>\n<p>最后运行的结果是</p>\n<pre><code class=\"python\">in add2, num is 1295511\nin add1, num is 1324484\nfinal num is 1324484\n</code></pre>\n<p>对num加1，2000000次，结果却不是2000000，这是由于线程共享全局变量</p>\n<p>在num=0时，thread1 thread2同时取得num=0。<br>此时thread1 sleeping，thread2 running， thread2使num=1<br>然后thread2 sleeping，thread1 running， thread1使num=1<br>这就导致两个线程重复操作了两次，num结果仍是1</p>\n<p>简单来说就是线程被覆盖了，这时可以使用 threading库里面的锁对象 Lock 去保护</p>\n<pre><code class=\"python\">lock = threading.Lock()\n\nlock.acquire()\nlock.release()\n</code></pre>\n<h1 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h1><h2 id=\"进程的创建\"><a href=\"#进程的创建\" class=\"headerlink\" title=\"进程的创建\"></a>进程的创建</h2><p>在python中进程的创建主要通过Process函数<br>Process([group [, target [, name [, args [, kwargs]]]]])</p>\n<ol>\n<li> target：如果传递了函数的引用，可以任务这个子进程就执行这里的代码</li>\n<li> args：给target指定的函数传递的参数，以元组的方式传递</li>\n<li> kwargs：给target指定的函数传递命名参数</li>\n<li> name：给进程设定一个名字，可以不设定</li>\n<li> group：指定进程组，大多数情况下用不到</li>\n</ol>\n<p>Process创建的实例对象的常用方法：</p>\n<ol>\n<li> start()：启动子进程实例（创建子进程）</li>\n<li> is_alive()：判断进程子进程是否还在活着</li>\n<li> join([timeout])：是否等待子进程执行结束，或等待多少秒</li>\n<li> terminate()：不管任务是否完成，立即终止子进程</li>\n</ol>\n<p>Process创建的实例对象的常用属性：</p>\n<ol>\n<li><pre><code>name：当前进程的别名，默认为Process-N，N为从1开始递增的整\n</code></pre>\n</li>\n<li><pre><code>pid：当前进程的pid（进程号）\n</code></pre>\n</li>\n</ol>\n<pre><code class=\"python\">from multiprocessing import Process\nimport os\nimport time\n\ndef sub_fun():\n        print(&#39;子进程运行中，pid=%d...&#39; % os.getpid())\n\nif __name__ == &#39;__main__&#39;:\n    print(&#39;父进程pid: %d&#39; % os.getpid())\n    for i in range(3):\n        p = Process(target=sub_fun)\n        p.start()\n</code></pre>\n<h2 id=\"进程间的通信\"><a href=\"#进程间的通信\" class=\"headerlink\" title=\"进程间的通信\"></a>进程间的通信</h2><p>进程间有多种通信机制，下面就常用的Queue为例进行说明</p>\n<pre><code class=\"python\">from multiprocessing import Process,Queue\nimport os,time,random\n\ndef write(q):\n    for value in [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]:\n        print(&#39;put &#123;0&#125; to queue&#39;.format(value))\n        q.put(value)\n        time.sleep(random.random())\n\ndef read(q):\n    while not q.empty():#此处死循环，ctrl+c终止\n        value = q.get(True)\n        print(&#39;get &#123;0&#125; to queue&#39;.format(value))\n        q.put(value)\n        time.sleep(random.random())\n\nif __name__ == &#39;__main__&#39;:\n    q = Queue()\n\n    pw = Process(target=write, args=(q,))\n    pr = Process(target=read, args=(q,))\n\n    pw.start()\n    pw.join()\n\n    pr.start()\n    pr.join()\n\n    print(&#39;-----ok------&#39;)\n</code></pre>\n","site":{"data":{}},"excerpt":"<h3 id=\"Python学习-多线程和多进程\"><a href=\"#Python学习-多线程和多进程\" class=\"headerlink\" title=\"Python学习-多线程和多进程\"></a>Python学习-多线程和多进程</h3><ul>\n<li><a href=\"#_1\">基本概念</a></li>\n<li><a href=\"#_4\">线程</a></li>\n<li><ul>\n<li><a href=\"#_5\">线程的创建</a></li>\n<li><a href=\"#_29\">线程共享全局变量和锁</a>","more":"</li>\n</ul>\n</li>\n<li><a href=\"#_81\">进程</a></li>\n<li><ul>\n<li><a href=\"#_82\">进程的创建</a></li>\n<li><a href=\"#_117\">进程间的通信</a></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><ol>\n<li> 进程：程序的一次执行</li>\n<li> 线程：CPU的基本调度单位</li>\n</ol>\n<h1 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h1><h2 id=\"线程的创建\"><a href=\"#线程的创建\" class=\"headerlink\" title=\"线程的创建\"></a>线程的创建</h2><p>线程的创建主要通过threading模块</p>\n<pre><code class=\"python\">print(&#39;主线程开始&#39;)\n\nfrom threading import Thread\nimport threading\nfrom time import sleep\n\ndef sub_fun(arg1,arg2):\n    print(&#39;子线程开始&#39;)\n    print(&#39;子线程函数参数时：&#123;0&#125;,&#123;1&#125;&#39;.format(arg1,arg2))\n    sleep(5)\n    print(&#39;子进程结束&#39;)\n\nthread = Thread(target=sub_fun, args=(&#39;参数1&#39;,&#39;参数2&#39;))\n\nthread.start()\n\nthread.join()\n\nprint(&#39;主线程结束&#39;)\n</code></pre>\n<h2 id=\"线程共享全局变量和锁\"><a href=\"#线程共享全局变量和锁\" class=\"headerlink\" title=\"线程共享全局变量和锁\"></a>线程共享全局变量和锁</h2><p>在一个进程内的所有线程共享全局变量，很方便在多个线程间共享数据<br>缺点就是，线程是对全局变量随意遂改可能造成多线程之间对全局变量的混乱（即线程非安全）</p>\n<pre><code class=\"python\">from threading import Thread\nimport time\n\nnum = 0 \n\ndef add1(n):\n    global num\n    for i in range(n):\n        num = num+1\n    print(&#39;in add1, num is &#123;0&#125;\\n&#39;.format(num))\n    \ndef add2(n):\n    global num\n    for i in range(n):\n        num = num+1\n    print(&#39;in add2, num is &#123;0&#125;\\n&#39;.format(num))   \n\nthread1 = Thread(target=add1, args=(1000000,))\nthread1.start()\n\nthread2 = Thread(target=add2, args=(1000000,))\nthread2.start()\n\ntime.sleep(5)\nprint(&#39;final num is &#123;0&#125;\\n&#39;.format(num))\n</code></pre>\n<p>最后运行的结果是</p>\n<pre><code class=\"python\">in add2, num is 1295511\nin add1, num is 1324484\nfinal num is 1324484\n</code></pre>\n<p>对num加1，2000000次，结果却不是2000000，这是由于线程共享全局变量</p>\n<p>在num=0时，thread1 thread2同时取得num=0。<br>此时thread1 sleeping，thread2 running， thread2使num=1<br>然后thread2 sleeping，thread1 running， thread1使num=1<br>这就导致两个线程重复操作了两次，num结果仍是1</p>\n<p>简单来说就是线程被覆盖了，这时可以使用 threading库里面的锁对象 Lock 去保护</p>\n<pre><code class=\"python\">lock = threading.Lock()\n\nlock.acquire()\nlock.release()\n</code></pre>\n<h1 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h1><h2 id=\"进程的创建\"><a href=\"#进程的创建\" class=\"headerlink\" title=\"进程的创建\"></a>进程的创建</h2><p>在python中进程的创建主要通过Process函数<br>Process([group [, target [, name [, args [, kwargs]]]]])</p>\n<ol>\n<li> target：如果传递了函数的引用，可以任务这个子进程就执行这里的代码</li>\n<li> args：给target指定的函数传递的参数，以元组的方式传递</li>\n<li> kwargs：给target指定的函数传递命名参数</li>\n<li> name：给进程设定一个名字，可以不设定</li>\n<li> group：指定进程组，大多数情况下用不到</li>\n</ol>\n<p>Process创建的实例对象的常用方法：</p>\n<ol>\n<li> start()：启动子进程实例（创建子进程）</li>\n<li> is_alive()：判断进程子进程是否还在活着</li>\n<li> join([timeout])：是否等待子进程执行结束，或等待多少秒</li>\n<li> terminate()：不管任务是否完成，立即终止子进程</li>\n</ol>\n<p>Process创建的实例对象的常用属性：</p>\n<ol>\n<li><pre><code>name：当前进程的别名，默认为Process-N，N为从1开始递增的整\n</code></pre>\n</li>\n<li><pre><code>pid：当前进程的pid（进程号）\n</code></pre>\n</li>\n</ol>\n<pre><code class=\"python\">from multiprocessing import Process\nimport os\nimport time\n\ndef sub_fun():\n        print(&#39;子进程运行中，pid=%d...&#39; % os.getpid())\n\nif __name__ == &#39;__main__&#39;:\n    print(&#39;父进程pid: %d&#39; % os.getpid())\n    for i in range(3):\n        p = Process(target=sub_fun)\n        p.start()\n</code></pre>\n<h2 id=\"进程间的通信\"><a href=\"#进程间的通信\" class=\"headerlink\" title=\"进程间的通信\"></a>进程间的通信</h2><p>进程间有多种通信机制，下面就常用的Queue为例进行说明</p>\n<pre><code class=\"python\">from multiprocessing import Process,Queue\nimport os,time,random\n\ndef write(q):\n    for value in [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]:\n        print(&#39;put &#123;0&#125; to queue&#39;.format(value))\n        q.put(value)\n        time.sleep(random.random())\n\ndef read(q):\n    while not q.empty():#此处死循环，ctrl+c终止\n        value = q.get(True)\n        print(&#39;get &#123;0&#125; to queue&#39;.format(value))\n        q.put(value)\n        time.sleep(random.random())\n\nif __name__ == &#39;__main__&#39;:\n    q = Queue()\n\n    pw = Process(target=write, args=(q,))\n    pr = Process(target=read, args=(q,))\n\n    pw.start()\n    pw.join()\n\n    pr.start()\n    pr.join()\n\n    print(&#39;-----ok------&#39;)\n</code></pre>"},{"title":"Python学习-网络编程","date":"2021-06-25T14:44:30.000Z","_content":"\n\n### Python学习-网络编程\n\n- [引言](#_1)\n- - [网络](#_5)\n  - [IP](#IP_7)\n  - [端口](#_9)\n<!--more-->\n  - [协议](#_11)\n- [TCP/IP网络模型](#TCPIP_15)\n- - [UDP](#UDP_27)\n  - [TCP](#TCP_60)\n\n# 引言\n\n计算机网络是学习编程的基础四大件，而网络协议则是计算机网络的基础\n\nTCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP，本文将介绍下这两者以及它们之间的区别。\n\n## 网络\n\n网络编程就是通过程序使不同主机上的软件能够通过网络进行通信\n\n## IP\n\nip是用来在网络中标记一台电脑的地址，在本地局域网内是唯一的。\n\n## 端口\n\n一台电脑有一个ip，但是一台电脑上有多个软件，怎么识别到不同软件进行通信，这时就需要端口，每个软件的端口在本地主机上都是唯一的。\n\n## 协议\n\n有了ip有了端口，好比商家有了你家小区的地址，单元号，但是该采用什么快递，怎么确保你收到货这些并没有确定，这时就需要商家-顾客有一个统一的规定对这些内容进行规定，这就是**协议**\n\n所以，ip地址+协议+端口 三者结合才可以可以标识网络中的进程，并利用这个标识进行进程之间的通信\n\n# TCP/IP网络模型\n\n计算机与网络设备要相互通信，双方就必须基于相同的方法。比如\n\n- 如何探测到通信目标\n- 由哪一边先发起通信\n- 使用哪种语言进行通信\n- 怎样结束通信\n\n等等都需要事先确定规则。这种规则就是协议（protocol）\n\nTCP/IP 是互联网相关的各类协议族的总称，比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等都属于 TCP/IP 族内的协议。  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210624220714298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)\n\n## UDP\n\nsocket\\(简称 套接字\\) 是进程间通信的一种方式，通过socket函数，我们可以指定期望的通信协议类型\n\n函数 socket.socket 创建一个 socket，该函数带有两个参数  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210625212120166.png)  \n第一个参数指明了协议簇，目前支持5种协议簇，最常用的有AF\\_INET\\(IPv4协议\\)和AF\\_INET6\\(IPv6协议\\)  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210625212203662.png)  \n第二个参数指明套接口类型，主要有种类型可选：SOCK\\_STREAM\\(字节流套接口\\)、SOCK\\_DGRAM\\(数据报套接口\\)和SOCK\\_RAW\\(原始套接口\\)\n\n下面是UDP客户端和服务器之间通信交互的时间线，相应的代码实现也是根据此框图进行实现  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210625212814498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)\n\n```python\nfrom socket import *\n\nudp_socket = socket(AF_INET, SOCK_DGRAM)\n\ndest_addr = ('192.168.123.1', 8888)\n\nsend_data = input('请输入要发送的数据:')\n\nudp_socket.sendto(send_data.encode('utf-8'), dest_addr)\n\nrecv_data = udp_socket.recvfrom(1024)\n\n# 接收到的数据recv_data是一个元组\n# 第1个元素是对方发送的数据\n# 第2个元素是对方的ip和端口\nprint(recv_data[0].decode('gbk'))\nprint(recv_data[1])\n\nudp_socket.close()\n```\n\n## TCP\n\n\\*\\*TCP协议，传输控制协议（英语：Transmission Control Protocol，缩写为 TCP）\\*\\*是一种面向连接的、可靠的、基于字节流的传输层通信协议\n\nTCP通信需要经过创建连接、数据传送、终止连接三个步骤\n\n下面是TCP客户端和服务器之间通信交互的时间线，相应的代码实现也是根据此框图进行实现  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210625223637898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)\n\n```python\nfrom socket import *\n\ntcp_client = socket(AF_INET, SOCK_DGRAM)\n\nserver_ip = input('input server ip:')\nserver_port = input('input server port:')\n\ntcp_client.connect((server_ip,server_port))\n\nsend_data = input('input send data:')\n\ntcp_client.send(send_data)\n\ntcp_client.send(send_data.encode(\"gbk\"))\n\nrecvData = tcp_client.recv(1024)\nprint('接收到的数据为:', recvData.decode('gbk'))\n\ntcp_client.close()\n```\n","source":"_posts/Python学习-网络编程.md","raw":"---\ntitle: Python学习-网络编程\ndate: 2021-06-25 22:44:30\ntags: \ncategories: Python\n---\n\n\n### Python学习-网络编程\n\n- [引言](#_1)\n- - [网络](#_5)\n  - [IP](#IP_7)\n  - [端口](#_9)\n<!--more-->\n  - [协议](#_11)\n- [TCP/IP网络模型](#TCPIP_15)\n- - [UDP](#UDP_27)\n  - [TCP](#TCP_60)\n\n# 引言\n\n计算机网络是学习编程的基础四大件，而网络协议则是计算机网络的基础\n\nTCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP，本文将介绍下这两者以及它们之间的区别。\n\n## 网络\n\n网络编程就是通过程序使不同主机上的软件能够通过网络进行通信\n\n## IP\n\nip是用来在网络中标记一台电脑的地址，在本地局域网内是唯一的。\n\n## 端口\n\n一台电脑有一个ip，但是一台电脑上有多个软件，怎么识别到不同软件进行通信，这时就需要端口，每个软件的端口在本地主机上都是唯一的。\n\n## 协议\n\n有了ip有了端口，好比商家有了你家小区的地址，单元号，但是该采用什么快递，怎么确保你收到货这些并没有确定，这时就需要商家-顾客有一个统一的规定对这些内容进行规定，这就是**协议**\n\n所以，ip地址+协议+端口 三者结合才可以可以标识网络中的进程，并利用这个标识进行进程之间的通信\n\n# TCP/IP网络模型\n\n计算机与网络设备要相互通信，双方就必须基于相同的方法。比如\n\n- 如何探测到通信目标\n- 由哪一边先发起通信\n- 使用哪种语言进行通信\n- 怎样结束通信\n\n等等都需要事先确定规则。这种规则就是协议（protocol）\n\nTCP/IP 是互联网相关的各类协议族的总称，比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等都属于 TCP/IP 族内的协议。  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210624220714298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)\n\n## UDP\n\nsocket\\(简称 套接字\\) 是进程间通信的一种方式，通过socket函数，我们可以指定期望的通信协议类型\n\n函数 socket.socket 创建一个 socket，该函数带有两个参数  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210625212120166.png)  \n第一个参数指明了协议簇，目前支持5种协议簇，最常用的有AF\\_INET\\(IPv4协议\\)和AF\\_INET6\\(IPv6协议\\)  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210625212203662.png)  \n第二个参数指明套接口类型，主要有种类型可选：SOCK\\_STREAM\\(字节流套接口\\)、SOCK\\_DGRAM\\(数据报套接口\\)和SOCK\\_RAW\\(原始套接口\\)\n\n下面是UDP客户端和服务器之间通信交互的时间线，相应的代码实现也是根据此框图进行实现  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210625212814498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)\n\n```python\nfrom socket import *\n\nudp_socket = socket(AF_INET, SOCK_DGRAM)\n\ndest_addr = ('192.168.123.1', 8888)\n\nsend_data = input('请输入要发送的数据:')\n\nudp_socket.sendto(send_data.encode('utf-8'), dest_addr)\n\nrecv_data = udp_socket.recvfrom(1024)\n\n# 接收到的数据recv_data是一个元组\n# 第1个元素是对方发送的数据\n# 第2个元素是对方的ip和端口\nprint(recv_data[0].decode('gbk'))\nprint(recv_data[1])\n\nudp_socket.close()\n```\n\n## TCP\n\n\\*\\*TCP协议，传输控制协议（英语：Transmission Control Protocol，缩写为 TCP）\\*\\*是一种面向连接的、可靠的、基于字节流的传输层通信协议\n\nTCP通信需要经过创建连接、数据传送、终止连接三个步骤\n\n下面是TCP客户端和服务器之间通信交互的时间线，相应的代码实现也是根据此框图进行实现  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210625223637898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)\n\n```python\nfrom socket import *\n\ntcp_client = socket(AF_INET, SOCK_DGRAM)\n\nserver_ip = input('input server ip:')\nserver_port = input('input server port:')\n\ntcp_client.connect((server_ip,server_port))\n\nsend_data = input('input send data:')\n\ntcp_client.send(send_data)\n\ntcp_client.send(send_data.encode(\"gbk\"))\n\nrecvData = tcp_client.recv(1024)\nprint('接收到的数据为:', recvData.decode('gbk'))\n\ntcp_client.close()\n```\n","slug":"Python学习-网络编程","published":1,"updated":"2023-08-15T12:59:46.638Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllcdfgkj000ti7jx537s1s89","content":"<h3 id=\"Python学习-网络编程\"><a href=\"#Python学习-网络编程\" class=\"headerlink\" title=\"Python学习-网络编程\"></a>Python学习-网络编程</h3><ul>\n<li><a href=\"#_1\">引言</a></li>\n<li><ul>\n<li><a href=\"#_5\">网络</a></li>\n<li><a href=\"#IP_7\">IP</a></li>\n<li><a href=\"#_9\">端口</a><span id=\"more\"></span></li>\n<li><a href=\"#_11\">协议</a></li>\n</ul>\n</li>\n<li><a href=\"#TCPIP_15\">TCP/IP网络模型</a></li>\n<li><ul>\n<li><a href=\"#UDP_27\">UDP</a></li>\n<li><a href=\"#TCP_60\">TCP</a></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>计算机网络是学习编程的基础四大件，而网络协议则是计算机网络的基础</p>\n<p>TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP，本文将介绍下这两者以及它们之间的区别。</p>\n<h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><p>网络编程就是通过程序使不同主机上的软件能够通过网络进行通信</p>\n<h2 id=\"IP\"><a href=\"#IP\" class=\"headerlink\" title=\"IP\"></a>IP</h2><p>ip是用来在网络中标记一台电脑的地址，在本地局域网内是唯一的。</p>\n<h2 id=\"端口\"><a href=\"#端口\" class=\"headerlink\" title=\"端口\"></a>端口</h2><p>一台电脑有一个ip，但是一台电脑上有多个软件，怎么识别到不同软件进行通信，这时就需要端口，每个软件的端口在本地主机上都是唯一的。</p>\n<h2 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h2><p>有了ip有了端口，好比商家有了你家小区的地址，单元号，但是该采用什么快递，怎么确保你收到货这些并没有确定，这时就需要商家-顾客有一个统一的规定对这些内容进行规定，这就是<strong>协议</strong></p>\n<p>所以，ip地址+协议+端口 三者结合才可以可以标识网络中的进程，并利用这个标识进行进程之间的通信</p>\n<h1 id=\"TCP-IP网络模型\"><a href=\"#TCP-IP网络模型\" class=\"headerlink\" title=\"TCP/IP网络模型\"></a>TCP/IP网络模型</h1><p>计算机与网络设备要相互通信，双方就必须基于相同的方法。比如</p>\n<ul>\n<li>如何探测到通信目标</li>\n<li>由哪一边先发起通信</li>\n<li>使用哪种语言进行通信</li>\n<li>怎样结束通信</li>\n</ul>\n<p>等等都需要事先确定规则。这种规则就是协议（protocol）</p>\n<p>TCP/IP 是互联网相关的各类协议族的总称，比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等都属于 TCP/IP 族内的协议。<br><img src=\"https://img-blog.csdnimg.cn/20210624220714298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h2><p>socket(简称 套接字) 是进程间通信的一种方式，通过socket函数，我们可以指定期望的通信协议类型</p>\n<p>函数 socket.socket 创建一个 socket，该函数带有两个参数<br><img src=\"https://img-blog.csdnimg.cn/20210625212120166.png\" alt=\"在这里插入图片描述\"><br>第一个参数指明了协议簇，目前支持5种协议簇，最常用的有AF_INET(IPv4协议)和AF_INET6(IPv6协议)<br><img src=\"https://img-blog.csdnimg.cn/20210625212203662.png\" alt=\"在这里插入图片描述\"><br>第二个参数指明套接口类型，主要有种类型可选：SOCK_STREAM(字节流套接口)、SOCK_DGRAM(数据报套接口)和SOCK_RAW(原始套接口)</p>\n<p>下面是UDP客户端和服务器之间通信交互的时间线，相应的代码实现也是根据此框图进行实现<br><img src=\"https://img-blog.csdnimg.cn/20210625212814498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<pre><code class=\"python\">from socket import *\n\nudp_socket = socket(AF_INET, SOCK_DGRAM)\n\ndest_addr = (&#39;192.168.123.1&#39;, 8888)\n\nsend_data = input(&#39;请输入要发送的数据:&#39;)\n\nudp_socket.sendto(send_data.encode(&#39;utf-8&#39;), dest_addr)\n\nrecv_data = udp_socket.recvfrom(1024)\n\n# 接收到的数据recv_data是一个元组\n# 第1个元素是对方发送的数据\n# 第2个元素是对方的ip和端口\nprint(recv_data[0].decode(&#39;gbk&#39;))\nprint(recv_data[1])\n\nudp_socket.close()\n</code></pre>\n<h2 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h2><p>**TCP协议，传输控制协议（英语：Transmission Control Protocol，缩写为 TCP）**是一种面向连接的、可靠的、基于字节流的传输层通信协议</p>\n<p>TCP通信需要经过创建连接、数据传送、终止连接三个步骤</p>\n<p>下面是TCP客户端和服务器之间通信交互的时间线，相应的代码实现也是根据此框图进行实现<br><img src=\"https://img-blog.csdnimg.cn/20210625223637898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<pre><code class=\"python\">from socket import *\n\ntcp_client = socket(AF_INET, SOCK_DGRAM)\n\nserver_ip = input(&#39;input server ip:&#39;)\nserver_port = input(&#39;input server port:&#39;)\n\ntcp_client.connect((server_ip,server_port))\n\nsend_data = input(&#39;input send data:&#39;)\n\ntcp_client.send(send_data)\n\ntcp_client.send(send_data.encode(&quot;gbk&quot;))\n\nrecvData = tcp_client.recv(1024)\nprint(&#39;接收到的数据为:&#39;, recvData.decode(&#39;gbk&#39;))\n\ntcp_client.close()\n</code></pre>\n","site":{"data":{}},"excerpt":"<h3 id=\"Python学习-网络编程\"><a href=\"#Python学习-网络编程\" class=\"headerlink\" title=\"Python学习-网络编程\"></a>Python学习-网络编程</h3><ul>\n<li><a href=\"#_1\">引言</a></li>\n<li><ul>\n<li><a href=\"#_5\">网络</a></li>\n<li><a href=\"#IP_7\">IP</a></li>\n<li><a href=\"#_9\">端口</a>","more":"</li>\n<li><a href=\"#_11\">协议</a></li>\n</ul>\n</li>\n<li><a href=\"#TCPIP_15\">TCP/IP网络模型</a></li>\n<li><ul>\n<li><a href=\"#UDP_27\">UDP</a></li>\n<li><a href=\"#TCP_60\">TCP</a></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>计算机网络是学习编程的基础四大件，而网络协议则是计算机网络的基础</p>\n<p>TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP，本文将介绍下这两者以及它们之间的区别。</p>\n<h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><p>网络编程就是通过程序使不同主机上的软件能够通过网络进行通信</p>\n<h2 id=\"IP\"><a href=\"#IP\" class=\"headerlink\" title=\"IP\"></a>IP</h2><p>ip是用来在网络中标记一台电脑的地址，在本地局域网内是唯一的。</p>\n<h2 id=\"端口\"><a href=\"#端口\" class=\"headerlink\" title=\"端口\"></a>端口</h2><p>一台电脑有一个ip，但是一台电脑上有多个软件，怎么识别到不同软件进行通信，这时就需要端口，每个软件的端口在本地主机上都是唯一的。</p>\n<h2 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h2><p>有了ip有了端口，好比商家有了你家小区的地址，单元号，但是该采用什么快递，怎么确保你收到货这些并没有确定，这时就需要商家-顾客有一个统一的规定对这些内容进行规定，这就是<strong>协议</strong></p>\n<p>所以，ip地址+协议+端口 三者结合才可以可以标识网络中的进程，并利用这个标识进行进程之间的通信</p>\n<h1 id=\"TCP-IP网络模型\"><a href=\"#TCP-IP网络模型\" class=\"headerlink\" title=\"TCP/IP网络模型\"></a>TCP/IP网络模型</h1><p>计算机与网络设备要相互通信，双方就必须基于相同的方法。比如</p>\n<ul>\n<li>如何探测到通信目标</li>\n<li>由哪一边先发起通信</li>\n<li>使用哪种语言进行通信</li>\n<li>怎样结束通信</li>\n</ul>\n<p>等等都需要事先确定规则。这种规则就是协议（protocol）</p>\n<p>TCP/IP 是互联网相关的各类协议族的总称，比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等都属于 TCP/IP 族内的协议。<br><img src=\"https://img-blog.csdnimg.cn/20210624220714298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h2><p>socket(简称 套接字) 是进程间通信的一种方式，通过socket函数，我们可以指定期望的通信协议类型</p>\n<p>函数 socket.socket 创建一个 socket，该函数带有两个参数<br><img src=\"https://img-blog.csdnimg.cn/20210625212120166.png\" alt=\"在这里插入图片描述\"><br>第一个参数指明了协议簇，目前支持5种协议簇，最常用的有AF_INET(IPv4协议)和AF_INET6(IPv6协议)<br><img src=\"https://img-blog.csdnimg.cn/20210625212203662.png\" alt=\"在这里插入图片描述\"><br>第二个参数指明套接口类型，主要有种类型可选：SOCK_STREAM(字节流套接口)、SOCK_DGRAM(数据报套接口)和SOCK_RAW(原始套接口)</p>\n<p>下面是UDP客户端和服务器之间通信交互的时间线，相应的代码实现也是根据此框图进行实现<br><img src=\"https://img-blog.csdnimg.cn/20210625212814498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<pre><code class=\"python\">from socket import *\n\nudp_socket = socket(AF_INET, SOCK_DGRAM)\n\ndest_addr = (&#39;192.168.123.1&#39;, 8888)\n\nsend_data = input(&#39;请输入要发送的数据:&#39;)\n\nudp_socket.sendto(send_data.encode(&#39;utf-8&#39;), dest_addr)\n\nrecv_data = udp_socket.recvfrom(1024)\n\n# 接收到的数据recv_data是一个元组\n# 第1个元素是对方发送的数据\n# 第2个元素是对方的ip和端口\nprint(recv_data[0].decode(&#39;gbk&#39;))\nprint(recv_data[1])\n\nudp_socket.close()\n</code></pre>\n<h2 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h2><p>**TCP协议，传输控制协议（英语：Transmission Control Protocol，缩写为 TCP）**是一种面向连接的、可靠的、基于字节流的传输层通信协议</p>\n<p>TCP通信需要经过创建连接、数据传送、终止连接三个步骤</p>\n<p>下面是TCP客户端和服务器之间通信交互的时间线，相应的代码实现也是根据此框图进行实现<br><img src=\"https://img-blog.csdnimg.cn/20210625223637898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<pre><code class=\"python\">from socket import *\n\ntcp_client = socket(AF_INET, SOCK_DGRAM)\n\nserver_ip = input(&#39;input server ip:&#39;)\nserver_port = input(&#39;input server port:&#39;)\n\ntcp_client.connect((server_ip,server_port))\n\nsend_data = input(&#39;input send data:&#39;)\n\ntcp_client.send(send_data)\n\ntcp_client.send(send_data.encode(&quot;gbk&quot;))\n\nrecvData = tcp_client.recv(1024)\nprint(&#39;接收到的数据为:&#39;, recvData.decode(&#39;gbk&#39;))\n\ntcp_client.close()\n</code></pre>"},{"title":"Selenium的使用","date":"2021-07-04T11:48:42.000Z","_content":"\n\n### Selenium的使用\n\n- [选择元素的基本方法](#_1)\n- - [通过webdriver自带的元素选择器等选择元素](#webdriver_2)\n  - - [选择元素](#_3)\n    - [操纵元素](#_38)\n<!--more-->\n  - [通过CSS Selector 选择元素](#CSS_Selector__52)\n  - [通过xpath选择元素](#xpath_86)\n\n# 选择元素的基本方法\n\n## 通过webdriver自带的元素选择器等选择元素\n\n### 选择元素\n\n通过`find_element_by_xxxxxx`或`find_elements_by_xxxxxx`\n\n`xxxxx`为选择元素的关键字，常用关键字有：\n\n```python\n1.id定位：find_element_by_id(self, id_)\n2.name定位：find_element_by_name(self, name)\n3.class定位：find_element_by_class_name(self, name)\n4.tag定位：find_element_by_tag_name(self, name)\n```\n\n1.  使用 find\\_elements 选择的是符合条件的**所有**元素， 如果没有符合条件的元素， 返回空列表\n2.  使用 find\\_element 选择的是符合条件的**第一个**元素， 如果没有符合条件的元素， 抛出NoSuchElementException 异常\n\n通常程序的运行速度是远远大于网页请求渲染速度的，为了避免选择元素时`NoSuchElementException`异常的抛出，可以使用Selenium 的 Webdriver 对象 中的`implicitly_wait`方法\n\n该方法接受一个参数， 用来指定 最大等待时长。\n\n```python\nfrom selenium import webdriver\n\nwd = webdriver.Chrome()\n\nwd.implicitly_wait(10)\n\nwd.get('https://www.baidu.com')\n\nelement = wd.find_element_by_id('kw')\n\nelement.send_keys('lpl\\n')\n\nelement = wd.find_element_by_id('1')\n\nprint (element.text)\n```\n\n### 操纵元素\n\n1.  通过 WebElement 对象的`.click()`函数点击元素\n2.  输入框的操作可以用 WebElement 对象的`.clear()`和`.send_keys()`方法\n    ```python\n    element.clear() # 清除输入框已有的字符串\n    element.send_keys('白月黑羽') # 输入新字符串\n    ```\n3.  获取元素的文本信息可以通过`.text`方法\n4.  获取元素属性和输入框内的文本则可以通过`.get_attribute()`方法\n    ```python\n    get_attribute('class') # 获取元素属性\n    get_attribute('value')) # 获取输入框中的文本\n    ```\n\n## 通过CSS Selector 选择元素\n\n通过 CSS Selector 选择元素的方法是\n\n```python\nfind_element_by_css_selector(CSS Selector参数)\nfind_elements_by_css_selector(CSS Selector参数)\n```\n\n常用的选择方法\n\n| 选择器 | 表达式 |\n| --- | --- |\n| 根据class选择 | .class值 |\n| 根据id选择 | #id值 |\n| 父类下的子类 | 元素1 空格/> 元素2 |\n| 根据属性选择 | div\\[class=‘SKnet’\\] |\n\n根据属性选择还可以通过通配符选择以包含…开头结尾的元素\n\n1.  选择a节点，里面的href属性包含了 miitbeian 字符串，`a[href*=\"miitbeian\"]`\n2.  选择a节点，里面的href属性以 http 开头 ，`a[href^=\"http\"]`\n3.  要选择a节点，里面的href属性以 gov.cn结尾 ，`a[href$=\"gov.cn\"]`\n4.  如果一个元素具有多个属性`div[class=misc][ctype=gun]`\n\nCSS选择器还可以联合使用，如`div.footer1 > span.copyright`  \n以及进行组选择如 `div.footer1 ， span.copyright`\n\n最后还可以按照次序进行选择\n\n| 选择器 | 表达式 |\n| --- | --- |\n| 父元素的第n个子节点 | span:nth-child\\(2\\) |\n| 父元素的倒数第n个子节点 | p:nth-last-child\\(1\\) |\n| 父元素的第几个某类型的子节点 | span:nth-of-type\\(1\\) |\n| 父元素的倒数第几个某类型的子节点 | p:nth-last-of-type\\(2\\) |\n| 相邻兄弟节点选择 | h3 + span |\n| 后续所有兄弟节点选择 | h3 \\~ span |\n\n## 通过xpath选择元素\n\n通过 xpath 选择元素的方法是\n\n```python\nfind_element_by_xpath(xpath参数)\nfind_elements_by_xpath(xpath参数)\n```\n\nxpath 可以通过**相对路径**和**绝对路径**两种方式进行选择，通常相对路径使用较多\n\n常用的选择方法\n\n| 选择器 | 表达式 |\n| --- | --- |\n| 根据属性选择 | \\[\\@属性名=‘属性值’\\] |\n| 属性值包含字符串 | //\\*\\[contains\\(\\@style,‘color’\\)\\] |\n| 属性值以字符串开头 | //\\*\\[starts-with\\(\\@style,‘color’\\)\\] |\n| 属性值以字符串结尾 | //\\*\\[ends-with\\(\\@style,‘color’\\)\\] |\n\nxpath选择器进行组选择用`|` 进行分割，类似css的`,`\n\n同样的xpath也可以通过次序进行选择\n\n| 选择器 | 表达式 |\n| --- | --- |\n| 某类型 第几个 子元素 | //p\\[2\\] |\n| 某类型 倒数第几个 子元素 | //p\\[last\\(\\)-1\\] |\n| 范围选择 | //option\\[position\\(\\)\\<=2\\] |\n| 后续所有兄弟节点选择 | following-sibling:: |\n\n同时xpath的优势在于可以使用子节点反选父节点使用`//*[@id='china']/../../..`\n\n最后，以上包括css，xpath都可以通过chrome的开发者工具栏中`ctrl+f`进行表达式的验证\n","source":"_posts/Selenium的使用.md","raw":"---\ntitle: Selenium的使用\ndate: 2021-07-04 19:48:42\ntags: \ncategories: Python\n---\n\n\n### Selenium的使用\n\n- [选择元素的基本方法](#_1)\n- - [通过webdriver自带的元素选择器等选择元素](#webdriver_2)\n  - - [选择元素](#_3)\n    - [操纵元素](#_38)\n<!--more-->\n  - [通过CSS Selector 选择元素](#CSS_Selector__52)\n  - [通过xpath选择元素](#xpath_86)\n\n# 选择元素的基本方法\n\n## 通过webdriver自带的元素选择器等选择元素\n\n### 选择元素\n\n通过`find_element_by_xxxxxx`或`find_elements_by_xxxxxx`\n\n`xxxxx`为选择元素的关键字，常用关键字有：\n\n```python\n1.id定位：find_element_by_id(self, id_)\n2.name定位：find_element_by_name(self, name)\n3.class定位：find_element_by_class_name(self, name)\n4.tag定位：find_element_by_tag_name(self, name)\n```\n\n1.  使用 find\\_elements 选择的是符合条件的**所有**元素， 如果没有符合条件的元素， 返回空列表\n2.  使用 find\\_element 选择的是符合条件的**第一个**元素， 如果没有符合条件的元素， 抛出NoSuchElementException 异常\n\n通常程序的运行速度是远远大于网页请求渲染速度的，为了避免选择元素时`NoSuchElementException`异常的抛出，可以使用Selenium 的 Webdriver 对象 中的`implicitly_wait`方法\n\n该方法接受一个参数， 用来指定 最大等待时长。\n\n```python\nfrom selenium import webdriver\n\nwd = webdriver.Chrome()\n\nwd.implicitly_wait(10)\n\nwd.get('https://www.baidu.com')\n\nelement = wd.find_element_by_id('kw')\n\nelement.send_keys('lpl\\n')\n\nelement = wd.find_element_by_id('1')\n\nprint (element.text)\n```\n\n### 操纵元素\n\n1.  通过 WebElement 对象的`.click()`函数点击元素\n2.  输入框的操作可以用 WebElement 对象的`.clear()`和`.send_keys()`方法\n    ```python\n    element.clear() # 清除输入框已有的字符串\n    element.send_keys('白月黑羽') # 输入新字符串\n    ```\n3.  获取元素的文本信息可以通过`.text`方法\n4.  获取元素属性和输入框内的文本则可以通过`.get_attribute()`方法\n    ```python\n    get_attribute('class') # 获取元素属性\n    get_attribute('value')) # 获取输入框中的文本\n    ```\n\n## 通过CSS Selector 选择元素\n\n通过 CSS Selector 选择元素的方法是\n\n```python\nfind_element_by_css_selector(CSS Selector参数)\nfind_elements_by_css_selector(CSS Selector参数)\n```\n\n常用的选择方法\n\n| 选择器 | 表达式 |\n| --- | --- |\n| 根据class选择 | .class值 |\n| 根据id选择 | #id值 |\n| 父类下的子类 | 元素1 空格/> 元素2 |\n| 根据属性选择 | div\\[class=‘SKnet’\\] |\n\n根据属性选择还可以通过通配符选择以包含…开头结尾的元素\n\n1.  选择a节点，里面的href属性包含了 miitbeian 字符串，`a[href*=\"miitbeian\"]`\n2.  选择a节点，里面的href属性以 http 开头 ，`a[href^=\"http\"]`\n3.  要选择a节点，里面的href属性以 gov.cn结尾 ，`a[href$=\"gov.cn\"]`\n4.  如果一个元素具有多个属性`div[class=misc][ctype=gun]`\n\nCSS选择器还可以联合使用，如`div.footer1 > span.copyright`  \n以及进行组选择如 `div.footer1 ， span.copyright`\n\n最后还可以按照次序进行选择\n\n| 选择器 | 表达式 |\n| --- | --- |\n| 父元素的第n个子节点 | span:nth-child\\(2\\) |\n| 父元素的倒数第n个子节点 | p:nth-last-child\\(1\\) |\n| 父元素的第几个某类型的子节点 | span:nth-of-type\\(1\\) |\n| 父元素的倒数第几个某类型的子节点 | p:nth-last-of-type\\(2\\) |\n| 相邻兄弟节点选择 | h3 + span |\n| 后续所有兄弟节点选择 | h3 \\~ span |\n\n## 通过xpath选择元素\n\n通过 xpath 选择元素的方法是\n\n```python\nfind_element_by_xpath(xpath参数)\nfind_elements_by_xpath(xpath参数)\n```\n\nxpath 可以通过**相对路径**和**绝对路径**两种方式进行选择，通常相对路径使用较多\n\n常用的选择方法\n\n| 选择器 | 表达式 |\n| --- | --- |\n| 根据属性选择 | \\[\\@属性名=‘属性值’\\] |\n| 属性值包含字符串 | //\\*\\[contains\\(\\@style,‘color’\\)\\] |\n| 属性值以字符串开头 | //\\*\\[starts-with\\(\\@style,‘color’\\)\\] |\n| 属性值以字符串结尾 | //\\*\\[ends-with\\(\\@style,‘color’\\)\\] |\n\nxpath选择器进行组选择用`|` 进行分割，类似css的`,`\n\n同样的xpath也可以通过次序进行选择\n\n| 选择器 | 表达式 |\n| --- | --- |\n| 某类型 第几个 子元素 | //p\\[2\\] |\n| 某类型 倒数第几个 子元素 | //p\\[last\\(\\)-1\\] |\n| 范围选择 | //option\\[position\\(\\)\\<=2\\] |\n| 后续所有兄弟节点选择 | following-sibling:: |\n\n同时xpath的优势在于可以使用子节点反选父节点使用`//*[@id='china']/../../..`\n\n最后，以上包括css，xpath都可以通过chrome的开发者工具栏中`ctrl+f`进行表达式的验证\n","slug":"Selenium的使用","published":1,"updated":"2023-08-15T12:59:46.622Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllcdfgkl000wi7jx5i3q1izj","content":"<h3 id=\"Selenium的使用\"><a href=\"#Selenium的使用\" class=\"headerlink\" title=\"Selenium的使用\"></a>Selenium的使用</h3><ul>\n<li><a href=\"#_1\">选择元素的基本方法</a></li>\n<li><ul>\n<li><a href=\"#webdriver_2\">通过webdriver自带的元素选择器等选择元素</a></li>\n<li><ul>\n<li><a href=\"#_3\">选择元素</a></li>\n<li><a href=\"#_38\">操纵元素</a><span id=\"more\"></span></li>\n</ul>\n</li>\n<li><a href=\"#CSS_Selector__52\">通过CSS Selector 选择元素</a></li>\n<li><a href=\"#xpath_86\">通过xpath选择元素</a></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"选择元素的基本方法\"><a href=\"#选择元素的基本方法\" class=\"headerlink\" title=\"选择元素的基本方法\"></a>选择元素的基本方法</h1><h2 id=\"通过webdriver自带的元素选择器等选择元素\"><a href=\"#通过webdriver自带的元素选择器等选择元素\" class=\"headerlink\" title=\"通过webdriver自带的元素选择器等选择元素\"></a>通过webdriver自带的元素选择器等选择元素</h2><h3 id=\"选择元素\"><a href=\"#选择元素\" class=\"headerlink\" title=\"选择元素\"></a>选择元素</h3><p>通过<code>find_element_by_xxxxxx</code>或<code>find_elements_by_xxxxxx</code></p>\n<p><code>xxxxx</code>为选择元素的关键字，常用关键字有：</p>\n<pre><code class=\"python\">1.id定位：find_element_by_id(self, id_)\n2.name定位：find_element_by_name(self, name)\n3.class定位：find_element_by_class_name(self, name)\n4.tag定位：find_element_by_tag_name(self, name)\n</code></pre>\n<ol>\n<li> 使用 find_elements 选择的是符合条件的<strong>所有</strong>元素， 如果没有符合条件的元素， 返回空列表</li>\n<li> 使用 find_element 选择的是符合条件的<strong>第一个</strong>元素， 如果没有符合条件的元素， 抛出NoSuchElementException 异常</li>\n</ol>\n<p>通常程序的运行速度是远远大于网页请求渲染速度的，为了避免选择元素时<code>NoSuchElementException</code>异常的抛出，可以使用Selenium 的 Webdriver 对象 中的<code>implicitly_wait</code>方法</p>\n<p>该方法接受一个参数， 用来指定 最大等待时长。</p>\n<pre><code class=\"python\">from selenium import webdriver\n\nwd = webdriver.Chrome()\n\nwd.implicitly_wait(10)\n\nwd.get(&#39;https://www.baidu.com&#39;)\n\nelement = wd.find_element_by_id(&#39;kw&#39;)\n\nelement.send_keys(&#39;lpl\\n&#39;)\n\nelement = wd.find_element_by_id(&#39;1&#39;)\n\nprint (element.text)\n</code></pre>\n<h3 id=\"操纵元素\"><a href=\"#操纵元素\" class=\"headerlink\" title=\"操纵元素\"></a>操纵元素</h3><ol>\n<li> 通过 WebElement 对象的<code>.click()</code>函数点击元素</li>\n<li>输入框的操作可以用 WebElement 对象的<code>.clear()</code>和<code>.send_keys()</code>方法<pre><code class=\"python\">element.clear() # 清除输入框已有的字符串\nelement.send_keys(&#39;白月黑羽&#39;) # 输入新字符串\n</code></pre>\n</li>\n<li> 获取元素的文本信息可以通过<code>.text</code>方法</li>\n<li>获取元素属性和输入框内的文本则可以通过<code>.get_attribute()</code>方法<pre><code class=\"python\">get_attribute(&#39;class&#39;) # 获取元素属性\nget_attribute(&#39;value&#39;)) # 获取输入框中的文本\n</code></pre>\n</li>\n</ol>\n<h2 id=\"通过CSS-Selector-选择元素\"><a href=\"#通过CSS-Selector-选择元素\" class=\"headerlink\" title=\"通过CSS Selector 选择元素\"></a>通过CSS Selector 选择元素</h2><p>通过 CSS Selector 选择元素的方法是</p>\n<pre><code class=\"python\">find_element_by_css_selector(CSS Selector参数)\nfind_elements_by_css_selector(CSS Selector参数)\n</code></pre>\n<p>常用的选择方法</p>\n<table>\n<thead>\n<tr>\n<th>选择器</th>\n<th>表达式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>根据class选择</td>\n<td>.class值</td>\n</tr>\n<tr>\n<td>根据id选择</td>\n<td>#id值</td>\n</tr>\n<tr>\n<td>父类下的子类</td>\n<td>元素1 空格/&gt; 元素2</td>\n</tr>\n<tr>\n<td>根据属性选择</td>\n<td>div[class=‘SKnet’]</td>\n</tr>\n</tbody></table>\n<p>根据属性选择还可以通过通配符选择以包含…开头结尾的元素</p>\n<ol>\n<li> 选择a节点，里面的href属性包含了 miitbeian 字符串，<code>a[href*=&quot;miitbeian&quot;]</code></li>\n<li> 选择a节点，里面的href属性以 http 开头 ，<code>a[href^=&quot;http&quot;]</code></li>\n<li> 要选择a节点，里面的href属性以 gov.cn结尾 ，<code>a[href$=&quot;gov.cn&quot;]</code></li>\n<li> 如果一个元素具有多个属性<code>div[class=misc][ctype=gun]</code></li>\n</ol>\n<p>CSS选择器还可以联合使用，如<code>div.footer1 &gt; span.copyright</code><br>以及进行组选择如 <code>div.footer1 ， span.copyright</code></p>\n<p>最后还可以按照次序进行选择</p>\n<table>\n<thead>\n<tr>\n<th>选择器</th>\n<th>表达式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>父元素的第n个子节点</td>\n<td>span:nth-child(2)</td>\n</tr>\n<tr>\n<td>父元素的倒数第n个子节点</td>\n<td>p:nth-last-child(1)</td>\n</tr>\n<tr>\n<td>父元素的第几个某类型的子节点</td>\n<td>span:nth-of-type(1)</td>\n</tr>\n<tr>\n<td>父元素的倒数第几个某类型的子节点</td>\n<td>p:nth-last-of-type(2)</td>\n</tr>\n<tr>\n<td>相邻兄弟节点选择</td>\n<td>h3 + span</td>\n</tr>\n<tr>\n<td>后续所有兄弟节点选择</td>\n<td>h3 ~ span</td>\n</tr>\n</tbody></table>\n<h2 id=\"通过xpath选择元素\"><a href=\"#通过xpath选择元素\" class=\"headerlink\" title=\"通过xpath选择元素\"></a>通过xpath选择元素</h2><p>通过 xpath 选择元素的方法是</p>\n<pre><code class=\"python\">find_element_by_xpath(xpath参数)\nfind_elements_by_xpath(xpath参数)\n</code></pre>\n<p>xpath 可以通过<strong>相对路径</strong>和<strong>绝对路径</strong>两种方式进行选择，通常相对路径使用较多</p>\n<p>常用的选择方法</p>\n<table>\n<thead>\n<tr>\n<th>选择器</th>\n<th>表达式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>根据属性选择</td>\n<td>[@属性名=‘属性值’]</td>\n</tr>\n<tr>\n<td>属性值包含字符串</td>\n<td>//*[contains(@style,‘color’)]</td>\n</tr>\n<tr>\n<td>属性值以字符串开头</td>\n<td>//*[starts-with(@style,‘color’)]</td>\n</tr>\n<tr>\n<td>属性值以字符串结尾</td>\n<td>//*[ends-with(@style,‘color’)]</td>\n</tr>\n</tbody></table>\n<p>xpath选择器进行组选择用<code>|</code> 进行分割，类似css的<code>,</code></p>\n<p>同样的xpath也可以通过次序进行选择</p>\n<table>\n<thead>\n<tr>\n<th>选择器</th>\n<th>表达式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>某类型 第几个 子元素</td>\n<td>//p[2]</td>\n</tr>\n<tr>\n<td>某类型 倒数第几个 子元素</td>\n<td>//p[last()-1]</td>\n</tr>\n<tr>\n<td>范围选择</td>\n<td>//option[position()&lt;=2]</td>\n</tr>\n<tr>\n<td>后续所有兄弟节点选择</td>\n<td>following-sibling::</td>\n</tr>\n</tbody></table>\n<p>同时xpath的优势在于可以使用子节点反选父节点使用<code>//*[@id=&#39;china&#39;]/../../..</code></p>\n<p>最后，以上包括css，xpath都可以通过chrome的开发者工具栏中<code>ctrl+f</code>进行表达式的验证</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"Selenium的使用\"><a href=\"#Selenium的使用\" class=\"headerlink\" title=\"Selenium的使用\"></a>Selenium的使用</h3><ul>\n<li><a href=\"#_1\">选择元素的基本方法</a></li>\n<li><ul>\n<li><a href=\"#webdriver_2\">通过webdriver自带的元素选择器等选择元素</a></li>\n<li><ul>\n<li><a href=\"#_3\">选择元素</a></li>\n<li><a href=\"#_38\">操纵元素</a>","more":"</li>\n</ul>\n</li>\n<li><a href=\"#CSS_Selector__52\">通过CSS Selector 选择元素</a></li>\n<li><a href=\"#xpath_86\">通过xpath选择元素</a></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"选择元素的基本方法\"><a href=\"#选择元素的基本方法\" class=\"headerlink\" title=\"选择元素的基本方法\"></a>选择元素的基本方法</h1><h2 id=\"通过webdriver自带的元素选择器等选择元素\"><a href=\"#通过webdriver自带的元素选择器等选择元素\" class=\"headerlink\" title=\"通过webdriver自带的元素选择器等选择元素\"></a>通过webdriver自带的元素选择器等选择元素</h2><h3 id=\"选择元素\"><a href=\"#选择元素\" class=\"headerlink\" title=\"选择元素\"></a>选择元素</h3><p>通过<code>find_element_by_xxxxxx</code>或<code>find_elements_by_xxxxxx</code></p>\n<p><code>xxxxx</code>为选择元素的关键字，常用关键字有：</p>\n<pre><code class=\"python\">1.id定位：find_element_by_id(self, id_)\n2.name定位：find_element_by_name(self, name)\n3.class定位：find_element_by_class_name(self, name)\n4.tag定位：find_element_by_tag_name(self, name)\n</code></pre>\n<ol>\n<li> 使用 find_elements 选择的是符合条件的<strong>所有</strong>元素， 如果没有符合条件的元素， 返回空列表</li>\n<li> 使用 find_element 选择的是符合条件的<strong>第一个</strong>元素， 如果没有符合条件的元素， 抛出NoSuchElementException 异常</li>\n</ol>\n<p>通常程序的运行速度是远远大于网页请求渲染速度的，为了避免选择元素时<code>NoSuchElementException</code>异常的抛出，可以使用Selenium 的 Webdriver 对象 中的<code>implicitly_wait</code>方法</p>\n<p>该方法接受一个参数， 用来指定 最大等待时长。</p>\n<pre><code class=\"python\">from selenium import webdriver\n\nwd = webdriver.Chrome()\n\nwd.implicitly_wait(10)\n\nwd.get(&#39;https://www.baidu.com&#39;)\n\nelement = wd.find_element_by_id(&#39;kw&#39;)\n\nelement.send_keys(&#39;lpl\\n&#39;)\n\nelement = wd.find_element_by_id(&#39;1&#39;)\n\nprint (element.text)\n</code></pre>\n<h3 id=\"操纵元素\"><a href=\"#操纵元素\" class=\"headerlink\" title=\"操纵元素\"></a>操纵元素</h3><ol>\n<li> 通过 WebElement 对象的<code>.click()</code>函数点击元素</li>\n<li>输入框的操作可以用 WebElement 对象的<code>.clear()</code>和<code>.send_keys()</code>方法<pre><code class=\"python\">element.clear() # 清除输入框已有的字符串\nelement.send_keys(&#39;白月黑羽&#39;) # 输入新字符串\n</code></pre>\n</li>\n<li> 获取元素的文本信息可以通过<code>.text</code>方法</li>\n<li>获取元素属性和输入框内的文本则可以通过<code>.get_attribute()</code>方法<pre><code class=\"python\">get_attribute(&#39;class&#39;) # 获取元素属性\nget_attribute(&#39;value&#39;)) # 获取输入框中的文本\n</code></pre>\n</li>\n</ol>\n<h2 id=\"通过CSS-Selector-选择元素\"><a href=\"#通过CSS-Selector-选择元素\" class=\"headerlink\" title=\"通过CSS Selector 选择元素\"></a>通过CSS Selector 选择元素</h2><p>通过 CSS Selector 选择元素的方法是</p>\n<pre><code class=\"python\">find_element_by_css_selector(CSS Selector参数)\nfind_elements_by_css_selector(CSS Selector参数)\n</code></pre>\n<p>常用的选择方法</p>\n<table>\n<thead>\n<tr>\n<th>选择器</th>\n<th>表达式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>根据class选择</td>\n<td>.class值</td>\n</tr>\n<tr>\n<td>根据id选择</td>\n<td>#id值</td>\n</tr>\n<tr>\n<td>父类下的子类</td>\n<td>元素1 空格/&gt; 元素2</td>\n</tr>\n<tr>\n<td>根据属性选择</td>\n<td>div[class=‘SKnet’]</td>\n</tr>\n</tbody></table>\n<p>根据属性选择还可以通过通配符选择以包含…开头结尾的元素</p>\n<ol>\n<li> 选择a节点，里面的href属性包含了 miitbeian 字符串，<code>a[href*=&quot;miitbeian&quot;]</code></li>\n<li> 选择a节点，里面的href属性以 http 开头 ，<code>a[href^=&quot;http&quot;]</code></li>\n<li> 要选择a节点，里面的href属性以 gov.cn结尾 ，<code>a[href$=&quot;gov.cn&quot;]</code></li>\n<li> 如果一个元素具有多个属性<code>div[class=misc][ctype=gun]</code></li>\n</ol>\n<p>CSS选择器还可以联合使用，如<code>div.footer1 &gt; span.copyright</code><br>以及进行组选择如 <code>div.footer1 ， span.copyright</code></p>\n<p>最后还可以按照次序进行选择</p>\n<table>\n<thead>\n<tr>\n<th>选择器</th>\n<th>表达式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>父元素的第n个子节点</td>\n<td>span:nth-child(2)</td>\n</tr>\n<tr>\n<td>父元素的倒数第n个子节点</td>\n<td>p:nth-last-child(1)</td>\n</tr>\n<tr>\n<td>父元素的第几个某类型的子节点</td>\n<td>span:nth-of-type(1)</td>\n</tr>\n<tr>\n<td>父元素的倒数第几个某类型的子节点</td>\n<td>p:nth-last-of-type(2)</td>\n</tr>\n<tr>\n<td>相邻兄弟节点选择</td>\n<td>h3 + span</td>\n</tr>\n<tr>\n<td>后续所有兄弟节点选择</td>\n<td>h3 ~ span</td>\n</tr>\n</tbody></table>\n<h2 id=\"通过xpath选择元素\"><a href=\"#通过xpath选择元素\" class=\"headerlink\" title=\"通过xpath选择元素\"></a>通过xpath选择元素</h2><p>通过 xpath 选择元素的方法是</p>\n<pre><code class=\"python\">find_element_by_xpath(xpath参数)\nfind_elements_by_xpath(xpath参数)\n</code></pre>\n<p>xpath 可以通过<strong>相对路径</strong>和<strong>绝对路径</strong>两种方式进行选择，通常相对路径使用较多</p>\n<p>常用的选择方法</p>\n<table>\n<thead>\n<tr>\n<th>选择器</th>\n<th>表达式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>根据属性选择</td>\n<td>[@属性名=‘属性值’]</td>\n</tr>\n<tr>\n<td>属性值包含字符串</td>\n<td>//*[contains(@style,‘color’)]</td>\n</tr>\n<tr>\n<td>属性值以字符串开头</td>\n<td>//*[starts-with(@style,‘color’)]</td>\n</tr>\n<tr>\n<td>属性值以字符串结尾</td>\n<td>//*[ends-with(@style,‘color’)]</td>\n</tr>\n</tbody></table>\n<p>xpath选择器进行组选择用<code>|</code> 进行分割，类似css的<code>,</code></p>\n<p>同样的xpath也可以通过次序进行选择</p>\n<table>\n<thead>\n<tr>\n<th>选择器</th>\n<th>表达式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>某类型 第几个 子元素</td>\n<td>//p[2]</td>\n</tr>\n<tr>\n<td>某类型 倒数第几个 子元素</td>\n<td>//p[last()-1]</td>\n</tr>\n<tr>\n<td>范围选择</td>\n<td>//option[position()&lt;=2]</td>\n</tr>\n<tr>\n<td>后续所有兄弟节点选择</td>\n<td>following-sibling::</td>\n</tr>\n</tbody></table>\n<p>同时xpath的优势在于可以使用子节点反选父节点使用<code>//*[@id=&#39;china&#39;]/../../..</code></p>\n<p>最后，以上包括css，xpath都可以通过chrome的开发者工具栏中<code>ctrl+f</code>进行表达式的验证</p>"},{"title":"Ubuntu配置Git并利用Gitee（码云）进行项目及代码的管理","date":"2021-05-01T02:54:27.000Z","_content":"\n\n# Ubuntu配置Git并利用Gitee（码云）进行项目及代码的管理\n\n## git安装与卸载\n\n```bash\napt-get install git\n<!--more-->\napt-get remove git\n```\n\n## git配置\n\n配置用户名\n\n```bash\ngit config --global user.name “your name”\n```\n\n配置邮箱\n\n```bash\ngit config --global user.email “your email”\n```\n\n查看配置信息\n\n```bash\ngit config --global --list\n```\n\n生成公钥\n\n```bash\nssh-keygen -t rsa -C \"your email\"\n```\n\n生成公钥后在ssh相应目录中将id\\_rsa.pub中的内容拷贝至码云  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210501104524858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)  \n测试配置是否成功\n\n```bash\nssh -T git@gitee.com\n```\n\n## git提交代码\n\n将你本地所有修改了的文件添加到暂存区\n\n```bash\ngit add .\n```\n\n将更改内容和日志消息一起存储在新的提交中\n\n```bash\ngit commit -m \"update\"\n```\n\n下拉代码，将远程最新的代码先跟你本地的代码合并一下，如果确定远程没有更新，可以不用这个，最好是每次都执行以下，完成之后打开代码查看有没有冲突，并解决，如果有冲突解决完成以后再次执行1跟2的操作\n\n```bash\ngit pull origin 远程分支名\n```\n\n将代码推至远程\n\n```bash\ngit push origin master或者远程分支名\n```","source":"_posts/Ubuntu配置Git并利用Gitee（码云）进行项目及代码的管理.md","raw":"---\ntitle: Ubuntu配置Git并利用Gitee（码云）进行项目及代码的管理\ndate: 2021-05-01 10:54:27\ntags: git linux\ncategories: Linux\n---\n\n\n# Ubuntu配置Git并利用Gitee（码云）进行项目及代码的管理\n\n## git安装与卸载\n\n```bash\napt-get install git\n<!--more-->\napt-get remove git\n```\n\n## git配置\n\n配置用户名\n\n```bash\ngit config --global user.name “your name”\n```\n\n配置邮箱\n\n```bash\ngit config --global user.email “your email”\n```\n\n查看配置信息\n\n```bash\ngit config --global --list\n```\n\n生成公钥\n\n```bash\nssh-keygen -t rsa -C \"your email\"\n```\n\n生成公钥后在ssh相应目录中将id\\_rsa.pub中的内容拷贝至码云  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210501104524858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)  \n测试配置是否成功\n\n```bash\nssh -T git@gitee.com\n```\n\n## git提交代码\n\n将你本地所有修改了的文件添加到暂存区\n\n```bash\ngit add .\n```\n\n将更改内容和日志消息一起存储在新的提交中\n\n```bash\ngit commit -m \"update\"\n```\n\n下拉代码，将远程最新的代码先跟你本地的代码合并一下，如果确定远程没有更新，可以不用这个，最好是每次都执行以下，完成之后打开代码查看有没有冲突，并解决，如果有冲突解决完成以后再次执行1跟2的操作\n\n```bash\ngit pull origin 远程分支名\n```\n\n将代码推至远程\n\n```bash\ngit push origin master或者远程分支名\n```","slug":"Ubuntu配置Git并利用Gitee（码云）进行项目及代码的管理","published":1,"updated":"2023-08-15T12:59:46.606Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllcdfgkl000yi7jx52ba4b2c","content":"<h1 id=\"Ubuntu配置Git并利用Gitee（码云）进行项目及代码的管理\"><a href=\"#Ubuntu配置Git并利用Gitee（码云）进行项目及代码的管理\" class=\"headerlink\" title=\"Ubuntu配置Git并利用Gitee（码云）进行项目及代码的管理\"></a>Ubuntu配置Git并利用Gitee（码云）进行项目及代码的管理</h1><h2 id=\"git安装与卸载\"><a href=\"#git安装与卸载\" class=\"headerlink\" title=\"git安装与卸载\"></a>git安装与卸载</h2><pre><code class=\"bash\">apt-get install git\n&lt;!--more--&gt;\napt-get remove git\n</code></pre>\n<h2 id=\"git配置\"><a href=\"#git配置\" class=\"headerlink\" title=\"git配置\"></a>git配置</h2><p>配置用户名</p>\n<pre><code class=\"bash\">git config --global user.name “your name”\n</code></pre>\n<p>配置邮箱</p>\n<pre><code class=\"bash\">git config --global user.email “your email”\n</code></pre>\n<p>查看配置信息</p>\n<pre><code class=\"bash\">git config --global --list\n</code></pre>\n<p>生成公钥</p>\n<pre><code class=\"bash\">ssh-keygen -t rsa -C &quot;your email&quot;\n</code></pre>\n<p>生成公钥后在ssh相应目录中将id_rsa.pub中的内容拷贝至码云<br><img src=\"https://img-blog.csdnimg.cn/20210501104524858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>测试配置是否成功</p>\n<pre><code class=\"bash\">ssh -T git@gitee.com\n</code></pre>\n<h2 id=\"git提交代码\"><a href=\"#git提交代码\" class=\"headerlink\" title=\"git提交代码\"></a>git提交代码</h2><p>将你本地所有修改了的文件添加到暂存区</p>\n<pre><code class=\"bash\">git add .\n</code></pre>\n<p>将更改内容和日志消息一起存储在新的提交中</p>\n<pre><code class=\"bash\">git commit -m &quot;update&quot;\n</code></pre>\n<p>下拉代码，将远程最新的代码先跟你本地的代码合并一下，如果确定远程没有更新，可以不用这个，最好是每次都执行以下，完成之后打开代码查看有没有冲突，并解决，如果有冲突解决完成以后再次执行1跟2的操作</p>\n<pre><code class=\"bash\">git pull origin 远程分支名\n</code></pre>\n<p>将代码推至远程</p>\n<pre><code class=\"bash\">git push origin master或者远程分支名\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Ubuntu配置Git并利用Gitee（码云）进行项目及代码的管理\"><a href=\"#Ubuntu配置Git并利用Gitee（码云）进行项目及代码的管理\" class=\"headerlink\" title=\"Ubuntu配置Git并利用Gitee（码云）进行项目及代码的管理\"></a>Ubuntu配置Git并利用Gitee（码云）进行项目及代码的管理</h1><h2 id=\"git安装与卸载\"><a href=\"#git安装与卸载\" class=\"headerlink\" title=\"git安装与卸载\"></a>git安装与卸载</h2><pre><code class=\"bash\">apt-get install git\n&lt;!--more--&gt;\napt-get remove git\n</code></pre>\n<h2 id=\"git配置\"><a href=\"#git配置\" class=\"headerlink\" title=\"git配置\"></a>git配置</h2><p>配置用户名</p>\n<pre><code class=\"bash\">git config --global user.name “your name”\n</code></pre>\n<p>配置邮箱</p>\n<pre><code class=\"bash\">git config --global user.email “your email”\n</code></pre>\n<p>查看配置信息</p>\n<pre><code class=\"bash\">git config --global --list\n</code></pre>\n<p>生成公钥</p>\n<pre><code class=\"bash\">ssh-keygen -t rsa -C &quot;your email&quot;\n</code></pre>\n<p>生成公钥后在ssh相应目录中将id_rsa.pub中的内容拷贝至码云<br><img src=\"https://img-blog.csdnimg.cn/20210501104524858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>测试配置是否成功</p>\n<pre><code class=\"bash\">ssh -T git@gitee.com\n</code></pre>\n<h2 id=\"git提交代码\"><a href=\"#git提交代码\" class=\"headerlink\" title=\"git提交代码\"></a>git提交代码</h2><p>将你本地所有修改了的文件添加到暂存区</p>\n<pre><code class=\"bash\">git add .\n</code></pre>\n<p>将更改内容和日志消息一起存储在新的提交中</p>\n<pre><code class=\"bash\">git commit -m &quot;update&quot;\n</code></pre>\n<p>下拉代码，将远程最新的代码先跟你本地的代码合并一下，如果确定远程没有更新，可以不用这个，最好是每次都执行以下，完成之后打开代码查看有没有冲突，并解决，如果有冲突解决完成以后再次执行1跟2的操作</p>\n<pre><code class=\"bash\">git pull origin 远程分支名\n</code></pre>\n<p>将代码推至远程</p>\n<pre><code class=\"bash\">git push origin master或者远程分支名\n</code></pre>\n"},{"title":"gdb调试方法","date":"2021-05-30T14:11:19.000Z","_content":"\n\n## 介绍\n\nGDB（GNU Debugger）是GCC的调试工具。其功能强大, 现描述如下：\n\nGDB主要帮忙你完成下面四个方面的功能：  \n1、启动，启动程序, 可以按照你的自定义的要求随心所欲的运行程序。  \n<!--more-->\n2、断点，可让被调试的程序在你所指定的断点处停住。（断点可以是条件表达式）  \n3、检查，当程序被停住时, 可以检查此时你的程序中所发生的事，如打印变量。  \n4、更改，动态的改变你程序的执行环境，如更改变量。\n\n## 生成调试信息\n\n使用gcc的 \\-g 参数即可，如：  \n`gcc \\-g demo.c \\-o demo`  \n然后使用gdb启动可执行文件即可\n\n```bash\ngdb test \ngdb -q test *//表示不打印gdb版本信息，界面较为干净\n```\n\n## gdb常用命令\n\n### 1、运行命令\n\n```\nrun：简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。\ncontinue （简写c ）：继续执行，到下一个断点处（或运行结束）\nnext：（简写 n），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。\nstep （简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的\nuntil：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。\nuntil+行号： 运行至某行，不仅仅用来跳出循环\nfinish： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。\ncall 函数(参数)：调用程序中可见的函数，并传递“参数”，如：call gdb_test(55)\nquit：简记为 q ，退出gdb\n```\n\n### 2、设置断点\n\n```\nbreak n （简写b n）:在第n行处设置断点\n（可以带上代码路径和代码名称： b OAGUPDATE.cpp:578）\nb fn1 if a＞b：条件断点设置\nbreak func（break缩写为b）：在函数func()的入口处设置断点，如：break cb_button\ndelete 断点号n：删除第n个断点\ndisable 断点号n：暂停第n个断点\nenable 断点号n：开启第n个断点\nclear 行号n：清除第n行的断点\ninfo b （info breakpoints） ：显示当前程序的断点设置情况\ndelete breakpoints：清除所有断点：\n```\n\n### 3、查看源码\n\n```\nlist ：简记为 l ，其作用就是列出程序的源代码，默认每次显示10行。\nlist 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12\nlist 函数名：将显示“函数名”所在函数的源代码，如：list main\nlist ：不带参数，将接着上一次 list 命令的，输出下边的内容。\n```\n\n### 4、打印表达式\n\n```\nprint 表达式：简记为 p ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。\nprint a：将显示整数 a 的值\nprint ++a：将把 a 中的值加1,并显示出来\nprint name：将显示字符串 name 的值\nprint gdb_test(22)：将以整数22作为参数调用 gdb_test() 函数\nprint gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数\ndisplay 表达式：在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display a\nwatch 表达式：设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch a\nwhatis ：查询变量或函数\ninfo function： 查询函数\n扩展info locals： 显示当前堆栈页的所有变量\n```\n\n### 5、查看运行信息\n\n```\nwhere/bt ：当前运行的堆栈列表；\nbt backtrace 显示当前调用堆栈\nup/down 改变堆栈显示的深度\nset args 参数:指定运行时的参数\nshow args：查看设置好的参数\ninfo program： 来查看程序的是否在运行，进程号，被暂停的原因。\n```\n\n### 6、分割窗口\n\n```\nlayout：用于分割窗口，可以一边查看代码，一边测试：\nlayout src：显示源代码窗口\nlayout asm：显示反汇编窗口\nlayout regs：显示源代码/反汇编和CPU寄存器窗口\nlayout split：显示源代码和反汇编窗口\nCtrl + L：刷新窗口\n```","source":"_posts/gdb调试方法.md","raw":"---\ntitle: gdb调试方法\ndate: 2021-05-30 22:11:19\ntags: \ncategories: Linux\n---\n\n\n## 介绍\n\nGDB（GNU Debugger）是GCC的调试工具。其功能强大, 现描述如下：\n\nGDB主要帮忙你完成下面四个方面的功能：  \n1、启动，启动程序, 可以按照你的自定义的要求随心所欲的运行程序。  \n<!--more-->\n2、断点，可让被调试的程序在你所指定的断点处停住。（断点可以是条件表达式）  \n3、检查，当程序被停住时, 可以检查此时你的程序中所发生的事，如打印变量。  \n4、更改，动态的改变你程序的执行环境，如更改变量。\n\n## 生成调试信息\n\n使用gcc的 \\-g 参数即可，如：  \n`gcc \\-g demo.c \\-o demo`  \n然后使用gdb启动可执行文件即可\n\n```bash\ngdb test \ngdb -q test *//表示不打印gdb版本信息，界面较为干净\n```\n\n## gdb常用命令\n\n### 1、运行命令\n\n```\nrun：简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。\ncontinue （简写c ）：继续执行，到下一个断点处（或运行结束）\nnext：（简写 n），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。\nstep （简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的\nuntil：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。\nuntil+行号： 运行至某行，不仅仅用来跳出循环\nfinish： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。\ncall 函数(参数)：调用程序中可见的函数，并传递“参数”，如：call gdb_test(55)\nquit：简记为 q ，退出gdb\n```\n\n### 2、设置断点\n\n```\nbreak n （简写b n）:在第n行处设置断点\n（可以带上代码路径和代码名称： b OAGUPDATE.cpp:578）\nb fn1 if a＞b：条件断点设置\nbreak func（break缩写为b）：在函数func()的入口处设置断点，如：break cb_button\ndelete 断点号n：删除第n个断点\ndisable 断点号n：暂停第n个断点\nenable 断点号n：开启第n个断点\nclear 行号n：清除第n行的断点\ninfo b （info breakpoints） ：显示当前程序的断点设置情况\ndelete breakpoints：清除所有断点：\n```\n\n### 3、查看源码\n\n```\nlist ：简记为 l ，其作用就是列出程序的源代码，默认每次显示10行。\nlist 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12\nlist 函数名：将显示“函数名”所在函数的源代码，如：list main\nlist ：不带参数，将接着上一次 list 命令的，输出下边的内容。\n```\n\n### 4、打印表达式\n\n```\nprint 表达式：简记为 p ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。\nprint a：将显示整数 a 的值\nprint ++a：将把 a 中的值加1,并显示出来\nprint name：将显示字符串 name 的值\nprint gdb_test(22)：将以整数22作为参数调用 gdb_test() 函数\nprint gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数\ndisplay 表达式：在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display a\nwatch 表达式：设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch a\nwhatis ：查询变量或函数\ninfo function： 查询函数\n扩展info locals： 显示当前堆栈页的所有变量\n```\n\n### 5、查看运行信息\n\n```\nwhere/bt ：当前运行的堆栈列表；\nbt backtrace 显示当前调用堆栈\nup/down 改变堆栈显示的深度\nset args 参数:指定运行时的参数\nshow args：查看设置好的参数\ninfo program： 来查看程序的是否在运行，进程号，被暂停的原因。\n```\n\n### 6、分割窗口\n\n```\nlayout：用于分割窗口，可以一边查看代码，一边测试：\nlayout src：显示源代码窗口\nlayout asm：显示反汇编窗口\nlayout regs：显示源代码/反汇编和CPU寄存器窗口\nlayout split：显示源代码和反汇编窗口\nCtrl + L：刷新窗口\n```","slug":"gdb调试方法","published":1,"updated":"2023-08-15T12:59:46.830Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllcdfgkm0011i7jx15ej8xup","content":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>GDB（GNU Debugger）是GCC的调试工具。其功能强大, 现描述如下：</p>\n<p>GDB主要帮忙你完成下面四个方面的功能：<br>1、启动，启动程序, 可以按照你的自定义的要求随心所欲的运行程序。  </p>\n<span id=\"more\"></span>\n<p>2、断点，可让被调试的程序在你所指定的断点处停住。（断点可以是条件表达式）<br>3、检查，当程序被停住时, 可以检查此时你的程序中所发生的事，如打印变量。<br>4、更改，动态的改变你程序的执行环境，如更改变量。</p>\n<h2 id=\"生成调试信息\"><a href=\"#生成调试信息\" class=\"headerlink\" title=\"生成调试信息\"></a>生成调试信息</h2><p>使用gcc的 -g 参数即可，如：<br><code>gcc \\-g demo.c \\-o demo</code><br>然后使用gdb启动可执行文件即可</p>\n<pre><code class=\"bash\">gdb test \ngdb -q test *//表示不打印gdb版本信息，界面较为干净\n</code></pre>\n<h2 id=\"gdb常用命令\"><a href=\"#gdb常用命令\" class=\"headerlink\" title=\"gdb常用命令\"></a>gdb常用命令</h2><h3 id=\"1、运行命令\"><a href=\"#1、运行命令\" class=\"headerlink\" title=\"1、运行命令\"></a>1、运行命令</h3><pre><code>run：简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。\ncontinue （简写c ）：继续执行，到下一个断点处（或运行结束）\nnext：（简写 n），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。\nstep （简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的\nuntil：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。\nuntil+行号： 运行至某行，不仅仅用来跳出循环\nfinish： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。\ncall 函数(参数)：调用程序中可见的函数，并传递“参数”，如：call gdb_test(55)\nquit：简记为 q ，退出gdb\n</code></pre>\n<h3 id=\"2、设置断点\"><a href=\"#2、设置断点\" class=\"headerlink\" title=\"2、设置断点\"></a>2、设置断点</h3><pre><code>break n （简写b n）:在第n行处设置断点\n（可以带上代码路径和代码名称： b OAGUPDATE.cpp:578）\nb fn1 if a＞b：条件断点设置\nbreak func（break缩写为b）：在函数func()的入口处设置断点，如：break cb_button\ndelete 断点号n：删除第n个断点\ndisable 断点号n：暂停第n个断点\nenable 断点号n：开启第n个断点\nclear 行号n：清除第n行的断点\ninfo b （info breakpoints） ：显示当前程序的断点设置情况\ndelete breakpoints：清除所有断点：\n</code></pre>\n<h3 id=\"3、查看源码\"><a href=\"#3、查看源码\" class=\"headerlink\" title=\"3、查看源码\"></a>3、查看源码</h3><pre><code>list ：简记为 l ，其作用就是列出程序的源代码，默认每次显示10行。\nlist 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12\nlist 函数名：将显示“函数名”所在函数的源代码，如：list main\nlist ：不带参数，将接着上一次 list 命令的，输出下边的内容。\n</code></pre>\n<h3 id=\"4、打印表达式\"><a href=\"#4、打印表达式\" class=\"headerlink\" title=\"4、打印表达式\"></a>4、打印表达式</h3><pre><code>print 表达式：简记为 p ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。\nprint a：将显示整数 a 的值\nprint ++a：将把 a 中的值加1,并显示出来\nprint name：将显示字符串 name 的值\nprint gdb_test(22)：将以整数22作为参数调用 gdb_test() 函数\nprint gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数\ndisplay 表达式：在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display a\nwatch 表达式：设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch a\nwhatis ：查询变量或函数\ninfo function： 查询函数\n扩展info locals： 显示当前堆栈页的所有变量\n</code></pre>\n<h3 id=\"5、查看运行信息\"><a href=\"#5、查看运行信息\" class=\"headerlink\" title=\"5、查看运行信息\"></a>5、查看运行信息</h3><pre><code>where/bt ：当前运行的堆栈列表；\nbt backtrace 显示当前调用堆栈\nup/down 改变堆栈显示的深度\nset args 参数:指定运行时的参数\nshow args：查看设置好的参数\ninfo program： 来查看程序的是否在运行，进程号，被暂停的原因。\n</code></pre>\n<h3 id=\"6、分割窗口\"><a href=\"#6、分割窗口\" class=\"headerlink\" title=\"6、分割窗口\"></a>6、分割窗口</h3><pre><code>layout：用于分割窗口，可以一边查看代码，一边测试：\nlayout src：显示源代码窗口\nlayout asm：显示反汇编窗口\nlayout regs：显示源代码/反汇编和CPU寄存器窗口\nlayout split：显示源代码和反汇编窗口\nCtrl + L：刷新窗口\n</code></pre>\n","site":{"data":{}},"excerpt":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>GDB（GNU Debugger）是GCC的调试工具。其功能强大, 现描述如下：</p>\n<p>GDB主要帮忙你完成下面四个方面的功能：<br>1、启动，启动程序, 可以按照你的自定义的要求随心所欲的运行程序。  </p>","more":"<p>2、断点，可让被调试的程序在你所指定的断点处停住。（断点可以是条件表达式）<br>3、检查，当程序被停住时, 可以检查此时你的程序中所发生的事，如打印变量。<br>4、更改，动态的改变你程序的执行环境，如更改变量。</p>\n<h2 id=\"生成调试信息\"><a href=\"#生成调试信息\" class=\"headerlink\" title=\"生成调试信息\"></a>生成调试信息</h2><p>使用gcc的 -g 参数即可，如：<br><code>gcc \\-g demo.c \\-o demo</code><br>然后使用gdb启动可执行文件即可</p>\n<pre><code class=\"bash\">gdb test \ngdb -q test *//表示不打印gdb版本信息，界面较为干净\n</code></pre>\n<h2 id=\"gdb常用命令\"><a href=\"#gdb常用命令\" class=\"headerlink\" title=\"gdb常用命令\"></a>gdb常用命令</h2><h3 id=\"1、运行命令\"><a href=\"#1、运行命令\" class=\"headerlink\" title=\"1、运行命令\"></a>1、运行命令</h3><pre><code>run：简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。\ncontinue （简写c ）：继续执行，到下一个断点处（或运行结束）\nnext：（简写 n），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。\nstep （简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的\nuntil：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。\nuntil+行号： 运行至某行，不仅仅用来跳出循环\nfinish： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。\ncall 函数(参数)：调用程序中可见的函数，并传递“参数”，如：call gdb_test(55)\nquit：简记为 q ，退出gdb\n</code></pre>\n<h3 id=\"2、设置断点\"><a href=\"#2、设置断点\" class=\"headerlink\" title=\"2、设置断点\"></a>2、设置断点</h3><pre><code>break n （简写b n）:在第n行处设置断点\n（可以带上代码路径和代码名称： b OAGUPDATE.cpp:578）\nb fn1 if a＞b：条件断点设置\nbreak func（break缩写为b）：在函数func()的入口处设置断点，如：break cb_button\ndelete 断点号n：删除第n个断点\ndisable 断点号n：暂停第n个断点\nenable 断点号n：开启第n个断点\nclear 行号n：清除第n行的断点\ninfo b （info breakpoints） ：显示当前程序的断点设置情况\ndelete breakpoints：清除所有断点：\n</code></pre>\n<h3 id=\"3、查看源码\"><a href=\"#3、查看源码\" class=\"headerlink\" title=\"3、查看源码\"></a>3、查看源码</h3><pre><code>list ：简记为 l ，其作用就是列出程序的源代码，默认每次显示10行。\nlist 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12\nlist 函数名：将显示“函数名”所在函数的源代码，如：list main\nlist ：不带参数，将接着上一次 list 命令的，输出下边的内容。\n</code></pre>\n<h3 id=\"4、打印表达式\"><a href=\"#4、打印表达式\" class=\"headerlink\" title=\"4、打印表达式\"></a>4、打印表达式</h3><pre><code>print 表达式：简记为 p ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。\nprint a：将显示整数 a 的值\nprint ++a：将把 a 中的值加1,并显示出来\nprint name：将显示字符串 name 的值\nprint gdb_test(22)：将以整数22作为参数调用 gdb_test() 函数\nprint gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数\ndisplay 表达式：在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display a\nwatch 表达式：设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch a\nwhatis ：查询变量或函数\ninfo function： 查询函数\n扩展info locals： 显示当前堆栈页的所有变量\n</code></pre>\n<h3 id=\"5、查看运行信息\"><a href=\"#5、查看运行信息\" class=\"headerlink\" title=\"5、查看运行信息\"></a>5、查看运行信息</h3><pre><code>where/bt ：当前运行的堆栈列表；\nbt backtrace 显示当前调用堆栈\nup/down 改变堆栈显示的深度\nset args 参数:指定运行时的参数\nshow args：查看设置好的参数\ninfo program： 来查看程序的是否在运行，进程号，被暂停的原因。\n</code></pre>\n<h3 id=\"6、分割窗口\"><a href=\"#6、分割窗口\" class=\"headerlink\" title=\"6、分割窗口\"></a>6、分割窗口</h3><pre><code>layout：用于分割窗口，可以一边查看代码，一边测试：\nlayout src：显示源代码窗口\nlayout asm：显示反汇编窗口\nlayout regs：显示源代码/反汇编和CPU寄存器窗口\nlayout split：显示源代码和反汇编窗口\nCtrl + L：刷新窗口\n</code></pre>"},{"title":"数据结构（C语言版）","date":"2021-06-06T06:38:30.000Z","_content":"\n\n## 数据结构（C语言版）\n\n### 绪论\n\n1、在计算机运行过程中，如何合理的组织数据、高效的处理数据，这就是数据结构\n\n<!--more-->\n2、数据结构包括两个方面的内容：数据的逻辑结构和存储结构  \n① 逻辑结构是从逻辑关系上描述数据，通常有四类：集合、线性、树状和图状  \n② 存储结构是逻辑结构在计算机中的存储表示，有两类：顺序和链式\n\n3、抽象数据类型（ADT）：提供类型属性和相关操作的抽象描述，下面是链表的抽象数据类型的定义，定义完抽象数据类型就可以进行接口的开发和实现了\n\n4、算法是为了解决某类问题而规定的操作方法  \n① 算法具有五个特性：有穷性、确定性、可行性、输入和输出。  \n② 算法的优劣应该从以下四方面来评价：正确性、可读性、健壮性和高效性\n\n5、算法的优劣主要是时间复杂度和空间复杂度\n\n### 链表\n\n#### 建立抽象\n\n```\n类型名：   简单链表\n类型属性： 可以存储一系列项\n类型操作： 初始化链表为空\n\t\t\t确定链表为空\n\t\t\t确定链表已满\n\t\t\t确定链表中的项数\n\t\t\t在链表末尾添加项\n\t\t  遍历链表，处理链表中的项\n\t\t  \t清空链表\n```\n\n#### 建立接口\n\n这个链表中主要分为两部分：表示数据的结构和操作数据的函数\n\n在链表中每个链结叫做节点（_node_），每个节点包含了存储内容的信息和指向下一个节点的指针，首先对节点进行定义\n\n```python\nstruct LinkNode\n{\n\tvoid * data;\n\tstruct LinkNode * next;\n};\n```\n\n下面对链表结构体进行定义，包括节点信息和链表的长度信息\n\n```python\nstruct LList\n{\n\t//头节点\n\tstruct LinkNode pHeader;\n\t//链表长度\n\tint m_size;\n};\n//使用typedef定义一个空指针作为链表的返回值\ntypedef void * LinkList;\n```\n\n以上，关于抽象数据类型的属性部分定义完成，接下来对类型的操作方法进行定义\n\n```python\n//初始化链表\nLinkList init_LinkList()\n//插入链表\nvoid insert_LinkList(LinkList list, int pos, void * data)\n//遍历链表\nvoid foreach_LinkList(LinkList list, void(*myForeach)(void *))\n//删除链表  按位置\nvoid removeByPos_LinkList(LinkList list, int pos)\n```\n\n#### 实现接口\n\n```python\nvoid init_LinkList()\n{\n    struct LList * mylist = malloc(sizeof(strict LList))\n    \n    if(mylist == NULL){return NULL;}\n    \n    mylist->pHeader.data = NULL;\n    mylist->pHeader.next = NULL;\n    mylist->m_size = 0;\n    \n    return mylist;\n}\n\nvoid insert_LinkList(LinkList list, int pos, void * data)\n{\n    if(list == NULL){return;}\n    if(data == NULL){return;}\n    struct LList *mylist = list;\n    if(pos<0 || pos>mylist->m_size){pos = mylist->m_size;}\n    \n    struct LinkNode * pCurrent = &mylist->pHeader;\n    for(int i=0; i<pos; i++){pCurrent = pCurrent->next;}\n    \n    struct LinkNode * newNode = malloc(sizeof(struct LinkNode));\n    neNode->data = data;\n    neNode->next = NULL;\n    \n    newNode->next = pCurrent->next;\n    pCurrent->next = pCurrent;\n    \n    mylist->m_size++;    \n}\n\nvoid foreach_LinkList(LinkList list, void(*myForeach)(void *))\n{\n\tif (list ==NULL){return;}\n\n\tstruct LList * mylist = list;\n\n\tstruct LinkNode* pCurrent = mylist->pHeader.next;\n\n\tfor (int i = 0; i < mylist->m_size;i++)\n\t{\n\t\tmyForeach(pCurrent->data);\n\t\tpCurrent = pCurrent->next;\n\t}\n}\n\nvoid removeByPos_LinkList(LinkList list, int pos)\n{\n\tif ( list == NULL){return;}\n\n\tstruct LList * mylist = list;\n\n\tif (pos < 0 || pos > mylist->m_size - 1){return;}\n\n\tstruct LinkNode * pCurrent = &mylist->pHeader;\n\tfor (int i = 0; i < pos;i++){pCurrent = pCurrent->next;}\n\n\tstruct LinkNode * pDel = pCurrent->next;\n\n\tpCurrent->next = pDel->next;\n\n\tfree(pDel);\n\tpDel = NULL;\n\n\tmylist->m_size--;\n}\n\n\n```\n","source":"_posts/数据结构（C语言版）.md","raw":"---\ntitle: 数据结构（C语言版）\ndate: 2021-06-06 14:38:30\ntags: \ncategories: C/C++\n---\n\n\n## 数据结构（C语言版）\n\n### 绪论\n\n1、在计算机运行过程中，如何合理的组织数据、高效的处理数据，这就是数据结构\n\n<!--more-->\n2、数据结构包括两个方面的内容：数据的逻辑结构和存储结构  \n① 逻辑结构是从逻辑关系上描述数据，通常有四类：集合、线性、树状和图状  \n② 存储结构是逻辑结构在计算机中的存储表示，有两类：顺序和链式\n\n3、抽象数据类型（ADT）：提供类型属性和相关操作的抽象描述，下面是链表的抽象数据类型的定义，定义完抽象数据类型就可以进行接口的开发和实现了\n\n4、算法是为了解决某类问题而规定的操作方法  \n① 算法具有五个特性：有穷性、确定性、可行性、输入和输出。  \n② 算法的优劣应该从以下四方面来评价：正确性、可读性、健壮性和高效性\n\n5、算法的优劣主要是时间复杂度和空间复杂度\n\n### 链表\n\n#### 建立抽象\n\n```\n类型名：   简单链表\n类型属性： 可以存储一系列项\n类型操作： 初始化链表为空\n\t\t\t确定链表为空\n\t\t\t确定链表已满\n\t\t\t确定链表中的项数\n\t\t\t在链表末尾添加项\n\t\t  遍历链表，处理链表中的项\n\t\t  \t清空链表\n```\n\n#### 建立接口\n\n这个链表中主要分为两部分：表示数据的结构和操作数据的函数\n\n在链表中每个链结叫做节点（_node_），每个节点包含了存储内容的信息和指向下一个节点的指针，首先对节点进行定义\n\n```python\nstruct LinkNode\n{\n\tvoid * data;\n\tstruct LinkNode * next;\n};\n```\n\n下面对链表结构体进行定义，包括节点信息和链表的长度信息\n\n```python\nstruct LList\n{\n\t//头节点\n\tstruct LinkNode pHeader;\n\t//链表长度\n\tint m_size;\n};\n//使用typedef定义一个空指针作为链表的返回值\ntypedef void * LinkList;\n```\n\n以上，关于抽象数据类型的属性部分定义完成，接下来对类型的操作方法进行定义\n\n```python\n//初始化链表\nLinkList init_LinkList()\n//插入链表\nvoid insert_LinkList(LinkList list, int pos, void * data)\n//遍历链表\nvoid foreach_LinkList(LinkList list, void(*myForeach)(void *))\n//删除链表  按位置\nvoid removeByPos_LinkList(LinkList list, int pos)\n```\n\n#### 实现接口\n\n```python\nvoid init_LinkList()\n{\n    struct LList * mylist = malloc(sizeof(strict LList))\n    \n    if(mylist == NULL){return NULL;}\n    \n    mylist->pHeader.data = NULL;\n    mylist->pHeader.next = NULL;\n    mylist->m_size = 0;\n    \n    return mylist;\n}\n\nvoid insert_LinkList(LinkList list, int pos, void * data)\n{\n    if(list == NULL){return;}\n    if(data == NULL){return;}\n    struct LList *mylist = list;\n    if(pos<0 || pos>mylist->m_size){pos = mylist->m_size;}\n    \n    struct LinkNode * pCurrent = &mylist->pHeader;\n    for(int i=0; i<pos; i++){pCurrent = pCurrent->next;}\n    \n    struct LinkNode * newNode = malloc(sizeof(struct LinkNode));\n    neNode->data = data;\n    neNode->next = NULL;\n    \n    newNode->next = pCurrent->next;\n    pCurrent->next = pCurrent;\n    \n    mylist->m_size++;    \n}\n\nvoid foreach_LinkList(LinkList list, void(*myForeach)(void *))\n{\n\tif (list ==NULL){return;}\n\n\tstruct LList * mylist = list;\n\n\tstruct LinkNode* pCurrent = mylist->pHeader.next;\n\n\tfor (int i = 0; i < mylist->m_size;i++)\n\t{\n\t\tmyForeach(pCurrent->data);\n\t\tpCurrent = pCurrent->next;\n\t}\n}\n\nvoid removeByPos_LinkList(LinkList list, int pos)\n{\n\tif ( list == NULL){return;}\n\n\tstruct LList * mylist = list;\n\n\tif (pos < 0 || pos > mylist->m_size - 1){return;}\n\n\tstruct LinkNode * pCurrent = &mylist->pHeader;\n\tfor (int i = 0; i < pos;i++){pCurrent = pCurrent->next;}\n\n\tstruct LinkNode * pDel = pCurrent->next;\n\n\tpCurrent->next = pDel->next;\n\n\tfree(pDel);\n\tpDel = NULL;\n\n\tmylist->m_size--;\n}\n\n\n```\n","slug":"数据结构（C语言版）","published":1,"updated":"2023-08-15T12:59:46.582Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllcdfgkn0013i7jx9z42c7j2","content":"<h2 id=\"数据结构（C语言版）\"><a href=\"#数据结构（C语言版）\" class=\"headerlink\" title=\"数据结构（C语言版）\"></a>数据结构（C语言版）</h2><h3 id=\"绪论\"><a href=\"#绪论\" class=\"headerlink\" title=\"绪论\"></a>绪论</h3><p>1、在计算机运行过程中，如何合理的组织数据、高效的处理数据，这就是数据结构</p>\n<span id=\"more\"></span>\n<p>2、数据结构包括两个方面的内容：数据的逻辑结构和存储结构<br>① 逻辑结构是从逻辑关系上描述数据，通常有四类：集合、线性、树状和图状<br>② 存储结构是逻辑结构在计算机中的存储表示，有两类：顺序和链式</p>\n<p>3、抽象数据类型（ADT）：提供类型属性和相关操作的抽象描述，下面是链表的抽象数据类型的定义，定义完抽象数据类型就可以进行接口的开发和实现了</p>\n<p>4、算法是为了解决某类问题而规定的操作方法<br>① 算法具有五个特性：有穷性、确定性、可行性、输入和输出。<br>② 算法的优劣应该从以下四方面来评价：正确性、可读性、健壮性和高效性</p>\n<p>5、算法的优劣主要是时间复杂度和空间复杂度</p>\n<h3 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h3><h4 id=\"建立抽象\"><a href=\"#建立抽象\" class=\"headerlink\" title=\"建立抽象\"></a>建立抽象</h4><pre><code>类型名：   简单链表\n类型属性： 可以存储一系列项\n类型操作： 初始化链表为空\n            确定链表为空\n            确定链表已满\n            确定链表中的项数\n            在链表末尾添加项\n          遍历链表，处理链表中的项\n              清空链表\n</code></pre>\n<h4 id=\"建立接口\"><a href=\"#建立接口\" class=\"headerlink\" title=\"建立接口\"></a>建立接口</h4><p>这个链表中主要分为两部分：表示数据的结构和操作数据的函数</p>\n<p>在链表中每个链结叫做节点（_node_），每个节点包含了存储内容的信息和指向下一个节点的指针，首先对节点进行定义</p>\n<pre><code class=\"python\">struct LinkNode\n&#123;\n    void * data;\n    struct LinkNode * next;\n&#125;;\n</code></pre>\n<p>下面对链表结构体进行定义，包括节点信息和链表的长度信息</p>\n<pre><code class=\"python\">struct LList\n&#123;\n    //头节点\n    struct LinkNode pHeader;\n    //链表长度\n    int m_size;\n&#125;;\n//使用typedef定义一个空指针作为链表的返回值\ntypedef void * LinkList;\n</code></pre>\n<p>以上，关于抽象数据类型的属性部分定义完成，接下来对类型的操作方法进行定义</p>\n<pre><code class=\"python\">//初始化链表\nLinkList init_LinkList()\n//插入链表\nvoid insert_LinkList(LinkList list, int pos, void * data)\n//遍历链表\nvoid foreach_LinkList(LinkList list, void(*myForeach)(void *))\n//删除链表  按位置\nvoid removeByPos_LinkList(LinkList list, int pos)\n</code></pre>\n<h4 id=\"实现接口\"><a href=\"#实现接口\" class=\"headerlink\" title=\"实现接口\"></a>实现接口</h4><pre><code class=\"python\">void init_LinkList()\n&#123;\n    struct LList * mylist = malloc(sizeof(strict LList))\n    \n    if(mylist == NULL)&#123;return NULL;&#125;\n    \n    mylist-&gt;pHeader.data = NULL;\n    mylist-&gt;pHeader.next = NULL;\n    mylist-&gt;m_size = 0;\n    \n    return mylist;\n&#125;\n\nvoid insert_LinkList(LinkList list, int pos, void * data)\n&#123;\n    if(list == NULL)&#123;return;&#125;\n    if(data == NULL)&#123;return;&#125;\n    struct LList *mylist = list;\n    if(pos&lt;0 || pos&gt;mylist-&gt;m_size)&#123;pos = mylist-&gt;m_size;&#125;\n    \n    struct LinkNode * pCurrent = &amp;mylist-&gt;pHeader;\n    for(int i=0; i&lt;pos; i++)&#123;pCurrent = pCurrent-&gt;next;&#125;\n    \n    struct LinkNode * newNode = malloc(sizeof(struct LinkNode));\n    neNode-&gt;data = data;\n    neNode-&gt;next = NULL;\n    \n    newNode-&gt;next = pCurrent-&gt;next;\n    pCurrent-&gt;next = pCurrent;\n    \n    mylist-&gt;m_size++;    \n&#125;\n\nvoid foreach_LinkList(LinkList list, void(*myForeach)(void *))\n&#123;\n    if (list ==NULL)&#123;return;&#125;\n\n    struct LList * mylist = list;\n\n    struct LinkNode* pCurrent = mylist-&gt;pHeader.next;\n\n    for (int i = 0; i &lt; mylist-&gt;m_size;i++)\n    &#123;\n        myForeach(pCurrent-&gt;data);\n        pCurrent = pCurrent-&gt;next;\n    &#125;\n&#125;\n\nvoid removeByPos_LinkList(LinkList list, int pos)\n&#123;\n    if ( list == NULL)&#123;return;&#125;\n\n    struct LList * mylist = list;\n\n    if (pos &lt; 0 || pos &gt; mylist-&gt;m_size - 1)&#123;return;&#125;\n\n    struct LinkNode * pCurrent = &amp;mylist-&gt;pHeader;\n    for (int i = 0; i &lt; pos;i++)&#123;pCurrent = pCurrent-&gt;next;&#125;\n\n    struct LinkNode * pDel = pCurrent-&gt;next;\n\n    pCurrent-&gt;next = pDel-&gt;next;\n\n    free(pDel);\n    pDel = NULL;\n\n    mylist-&gt;m_size--;\n&#125;\n\n</code></pre>\n","site":{"data":{}},"excerpt":"<h2 id=\"数据结构（C语言版）\"><a href=\"#数据结构（C语言版）\" class=\"headerlink\" title=\"数据结构（C语言版）\"></a>数据结构（C语言版）</h2><h3 id=\"绪论\"><a href=\"#绪论\" class=\"headerlink\" title=\"绪论\"></a>绪论</h3><p>1、在计算机运行过程中，如何合理的组织数据、高效的处理数据，这就是数据结构</p>","more":"<p>2、数据结构包括两个方面的内容：数据的逻辑结构和存储结构<br>① 逻辑结构是从逻辑关系上描述数据，通常有四类：集合、线性、树状和图状<br>② 存储结构是逻辑结构在计算机中的存储表示，有两类：顺序和链式</p>\n<p>3、抽象数据类型（ADT）：提供类型属性和相关操作的抽象描述，下面是链表的抽象数据类型的定义，定义完抽象数据类型就可以进行接口的开发和实现了</p>\n<p>4、算法是为了解决某类问题而规定的操作方法<br>① 算法具有五个特性：有穷性、确定性、可行性、输入和输出。<br>② 算法的优劣应该从以下四方面来评价：正确性、可读性、健壮性和高效性</p>\n<p>5、算法的优劣主要是时间复杂度和空间复杂度</p>\n<h3 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h3><h4 id=\"建立抽象\"><a href=\"#建立抽象\" class=\"headerlink\" title=\"建立抽象\"></a>建立抽象</h4><pre><code>类型名：   简单链表\n类型属性： 可以存储一系列项\n类型操作： 初始化链表为空\n            确定链表为空\n            确定链表已满\n            确定链表中的项数\n            在链表末尾添加项\n          遍历链表，处理链表中的项\n              清空链表\n</code></pre>\n<h4 id=\"建立接口\"><a href=\"#建立接口\" class=\"headerlink\" title=\"建立接口\"></a>建立接口</h4><p>这个链表中主要分为两部分：表示数据的结构和操作数据的函数</p>\n<p>在链表中每个链结叫做节点（_node_），每个节点包含了存储内容的信息和指向下一个节点的指针，首先对节点进行定义</p>\n<pre><code class=\"python\">struct LinkNode\n&#123;\n    void * data;\n    struct LinkNode * next;\n&#125;;\n</code></pre>\n<p>下面对链表结构体进行定义，包括节点信息和链表的长度信息</p>\n<pre><code class=\"python\">struct LList\n&#123;\n    //头节点\n    struct LinkNode pHeader;\n    //链表长度\n    int m_size;\n&#125;;\n//使用typedef定义一个空指针作为链表的返回值\ntypedef void * LinkList;\n</code></pre>\n<p>以上，关于抽象数据类型的属性部分定义完成，接下来对类型的操作方法进行定义</p>\n<pre><code class=\"python\">//初始化链表\nLinkList init_LinkList()\n//插入链表\nvoid insert_LinkList(LinkList list, int pos, void * data)\n//遍历链表\nvoid foreach_LinkList(LinkList list, void(*myForeach)(void *))\n//删除链表  按位置\nvoid removeByPos_LinkList(LinkList list, int pos)\n</code></pre>\n<h4 id=\"实现接口\"><a href=\"#实现接口\" class=\"headerlink\" title=\"实现接口\"></a>实现接口</h4><pre><code class=\"python\">void init_LinkList()\n&#123;\n    struct LList * mylist = malloc(sizeof(strict LList))\n    \n    if(mylist == NULL)&#123;return NULL;&#125;\n    \n    mylist-&gt;pHeader.data = NULL;\n    mylist-&gt;pHeader.next = NULL;\n    mylist-&gt;m_size = 0;\n    \n    return mylist;\n&#125;\n\nvoid insert_LinkList(LinkList list, int pos, void * data)\n&#123;\n    if(list == NULL)&#123;return;&#125;\n    if(data == NULL)&#123;return;&#125;\n    struct LList *mylist = list;\n    if(pos&lt;0 || pos&gt;mylist-&gt;m_size)&#123;pos = mylist-&gt;m_size;&#125;\n    \n    struct LinkNode * pCurrent = &amp;mylist-&gt;pHeader;\n    for(int i=0; i&lt;pos; i++)&#123;pCurrent = pCurrent-&gt;next;&#125;\n    \n    struct LinkNode * newNode = malloc(sizeof(struct LinkNode));\n    neNode-&gt;data = data;\n    neNode-&gt;next = NULL;\n    \n    newNode-&gt;next = pCurrent-&gt;next;\n    pCurrent-&gt;next = pCurrent;\n    \n    mylist-&gt;m_size++;    \n&#125;\n\nvoid foreach_LinkList(LinkList list, void(*myForeach)(void *))\n&#123;\n    if (list ==NULL)&#123;return;&#125;\n\n    struct LList * mylist = list;\n\n    struct LinkNode* pCurrent = mylist-&gt;pHeader.next;\n\n    for (int i = 0; i &lt; mylist-&gt;m_size;i++)\n    &#123;\n        myForeach(pCurrent-&gt;data);\n        pCurrent = pCurrent-&gt;next;\n    &#125;\n&#125;\n\nvoid removeByPos_LinkList(LinkList list, int pos)\n&#123;\n    if ( list == NULL)&#123;return;&#125;\n\n    struct LList * mylist = list;\n\n    if (pos &lt; 0 || pos &gt; mylist-&gt;m_size - 1)&#123;return;&#125;\n\n    struct LinkNode * pCurrent = &amp;mylist-&gt;pHeader;\n    for (int i = 0; i &lt; pos;i++)&#123;pCurrent = pCurrent-&gt;next;&#125;\n\n    struct LinkNode * pDel = pCurrent-&gt;next;\n\n    pCurrent-&gt;next = pDel-&gt;next;\n\n    free(pDel);\n    pDel = NULL;\n\n    mylist-&gt;m_size--;\n&#125;\n\n</code></pre>"},{"title":"自动驾驶基础-AEB","date":"2021-06-18T01:42:50.000Z","_content":"\n\n### 基本概念\n\n**AEB** 全称自动紧急制动（Automatic Emergency Braking）  \n通过雷达、摄像头共同监测前方车辆以及行人情况，若探测到潜在碰撞风险，系统将采取相应预警及制动措施，从而避免发生碰撞或减轻碰撞损害程度\n\n### 工作过程\n<!--more-->\n\n1.  第一阶段 一级预警，可视化及声音提醒，减震调整，进入预刹车状态\n2.  第二阶段 二级预警，减震装置警示性调整，制动提示\n3.  第三阶段 舒适性制动，双闪亮起\n4.  第四阶段 安全带预紧，全力制动\n\n### 硬件架构\n\n硬件主要由传感器、控制器与执行器三部分组成\n\n#### 传感器\n\n目前AEB主流方案采用的环境感知传感器为**毫米波雷达**和**摄像头**：毫米波雷达通过对目标物发送电磁波并接收回波来获得目标物体的距离、速度和角度；摄像头需要先进行目标识别，然后再根据目标在图像中的像素大小来估算目标距离。\n\n#### 控制器\n\nAEB控制器目前多集成在传感器内部（多为毫米波雷达），随着智能驾驶技术的不断发展，AEB控制功能将逐步由域控制器承担\n\n#### 执行器\n\n目前AEB的执行器均为**电子稳定系统**\\(Electronic Stability Program，简称ESP\\)\n\n该系统由传感器、电子控制单元（ECU）和执行器三大部分组成，通过电子控制单元监控汽车运行状态，对车辆的发动机及制动系统进行干预控制。典型的汽车电子稳定控制系统在传感器上主要包括4个轮速传感器、方向盘转角传感器、侧向加速度传感器、横摆角速度传感器、制动主缸压力传感器等，执行部分则包括传统制动系统\\(真空助力器、管路和制动器\\)、液压调节器等，电子控制单元与发动机管理系统联动，可对发动机动力输出进行干预和调整。\n\n### 算法设计\n\n详情 [AEB算法设计](https://mp.weixin.qq.com/s?src=11&timestamp=1623979825&ver=3137&signature=2gmnbGN0EV1gOIXbR9B0VlycyaD1-roe-vCjXOrhJMvjPagEGavYekQDufXG4*WBosqu3Tn6R4QZDvl*tuGa0UxcPOf3zoj*G5j9JmHZOVs6TNdDzaSI6aC88nth7SdG&new=1)","source":"_posts/自动驾驶基础-AEB.md","raw":"---\ntitle: 自动驾驶基础-AEB\ndate: 2021-06-18 09:42:50\ntags: \ncategories: 汽车电子\n---\n\n\n### 基本概念\n\n**AEB** 全称自动紧急制动（Automatic Emergency Braking）  \n通过雷达、摄像头共同监测前方车辆以及行人情况，若探测到潜在碰撞风险，系统将采取相应预警及制动措施，从而避免发生碰撞或减轻碰撞损害程度\n\n### 工作过程\n<!--more-->\n\n1.  第一阶段 一级预警，可视化及声音提醒，减震调整，进入预刹车状态\n2.  第二阶段 二级预警，减震装置警示性调整，制动提示\n3.  第三阶段 舒适性制动，双闪亮起\n4.  第四阶段 安全带预紧，全力制动\n\n### 硬件架构\n\n硬件主要由传感器、控制器与执行器三部分组成\n\n#### 传感器\n\n目前AEB主流方案采用的环境感知传感器为**毫米波雷达**和**摄像头**：毫米波雷达通过对目标物发送电磁波并接收回波来获得目标物体的距离、速度和角度；摄像头需要先进行目标识别，然后再根据目标在图像中的像素大小来估算目标距离。\n\n#### 控制器\n\nAEB控制器目前多集成在传感器内部（多为毫米波雷达），随着智能驾驶技术的不断发展，AEB控制功能将逐步由域控制器承担\n\n#### 执行器\n\n目前AEB的执行器均为**电子稳定系统**\\(Electronic Stability Program，简称ESP\\)\n\n该系统由传感器、电子控制单元（ECU）和执行器三大部分组成，通过电子控制单元监控汽车运行状态，对车辆的发动机及制动系统进行干预控制。典型的汽车电子稳定控制系统在传感器上主要包括4个轮速传感器、方向盘转角传感器、侧向加速度传感器、横摆角速度传感器、制动主缸压力传感器等，执行部分则包括传统制动系统\\(真空助力器、管路和制动器\\)、液压调节器等，电子控制单元与发动机管理系统联动，可对发动机动力输出进行干预和调整。\n\n### 算法设计\n\n详情 [AEB算法设计](https://mp.weixin.qq.com/s?src=11&timestamp=1623979825&ver=3137&signature=2gmnbGN0EV1gOIXbR9B0VlycyaD1-roe-vCjXOrhJMvjPagEGavYekQDufXG4*WBosqu3Tn6R4QZDvl*tuGa0UxcPOf3zoj*G5j9JmHZOVs6TNdDzaSI6aC88nth7SdG&new=1)","slug":"自动驾驶基础-AEB","published":1,"updated":"2023-08-15T12:59:46.550Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllcdfgko0016i7jx8lza91ge","content":"<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p><strong>AEB</strong> 全称自动紧急制动（Automatic Emergency Braking）<br>通过雷达、摄像头共同监测前方车辆以及行人情况，若探测到潜在碰撞风险，系统将采取相应预警及制动措施，从而避免发生碰撞或减轻碰撞损害程度</p>\n<h3 id=\"工作过程\"><a href=\"#工作过程\" class=\"headerlink\" title=\"工作过程\"></a>工作过程</h3><span id=\"more\"></span>\n\n<ol>\n<li> 第一阶段 一级预警，可视化及声音提醒，减震调整，进入预刹车状态</li>\n<li> 第二阶段 二级预警，减震装置警示性调整，制动提示</li>\n<li> 第三阶段 舒适性制动，双闪亮起</li>\n<li> 第四阶段 安全带预紧，全力制动</li>\n</ol>\n<h3 id=\"硬件架构\"><a href=\"#硬件架构\" class=\"headerlink\" title=\"硬件架构\"></a>硬件架构</h3><p>硬件主要由传感器、控制器与执行器三部分组成</p>\n<h4 id=\"传感器\"><a href=\"#传感器\" class=\"headerlink\" title=\"传感器\"></a>传感器</h4><p>目前AEB主流方案采用的环境感知传感器为<strong>毫米波雷达</strong>和<strong>摄像头</strong>：毫米波雷达通过对目标物发送电磁波并接收回波来获得目标物体的距离、速度和角度；摄像头需要先进行目标识别，然后再根据目标在图像中的像素大小来估算目标距离。</p>\n<h4 id=\"控制器\"><a href=\"#控制器\" class=\"headerlink\" title=\"控制器\"></a>控制器</h4><p>AEB控制器目前多集成在传感器内部（多为毫米波雷达），随着智能驾驶技术的不断发展，AEB控制功能将逐步由域控制器承担</p>\n<h4 id=\"执行器\"><a href=\"#执行器\" class=\"headerlink\" title=\"执行器\"></a>执行器</h4><p>目前AEB的执行器均为<strong>电子稳定系统</strong>(Electronic Stability Program，简称ESP)</p>\n<p>该系统由传感器、电子控制单元（ECU）和执行器三大部分组成，通过电子控制单元监控汽车运行状态，对车辆的发动机及制动系统进行干预控制。典型的汽车电子稳定控制系统在传感器上主要包括4个轮速传感器、方向盘转角传感器、侧向加速度传感器、横摆角速度传感器、制动主缸压力传感器等，执行部分则包括传统制动系统(真空助力器、管路和制动器)、液压调节器等，电子控制单元与发动机管理系统联动，可对发动机动力输出进行干预和调整。</p>\n<h3 id=\"算法设计\"><a href=\"#算法设计\" class=\"headerlink\" title=\"算法设计\"></a>算法设计</h3><p>详情 <a href=\"https://mp.weixin.qq.com/s?src=11&timestamp=1623979825&ver=3137&signature=2gmnbGN0EV1gOIXbR9B0VlycyaD1-roe-vCjXOrhJMvjPagEGavYekQDufXG4*WBosqu3Tn6R4QZDvl*tuGa0UxcPOf3zoj*G5j9JmHZOVs6TNdDzaSI6aC88nth7SdG&new=1\">AEB算法设计</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p><strong>AEB</strong> 全称自动紧急制动（Automatic Emergency Braking）<br>通过雷达、摄像头共同监测前方车辆以及行人情况，若探测到潜在碰撞风险，系统将采取相应预警及制动措施，从而避免发生碰撞或减轻碰撞损害程度</p>\n<h3 id=\"工作过程\"><a href=\"#工作过程\" class=\"headerlink\" title=\"工作过程\"></a>工作过程</h3>","more":"<ol>\n<li> 第一阶段 一级预警，可视化及声音提醒，减震调整，进入预刹车状态</li>\n<li> 第二阶段 二级预警，减震装置警示性调整，制动提示</li>\n<li> 第三阶段 舒适性制动，双闪亮起</li>\n<li> 第四阶段 安全带预紧，全力制动</li>\n</ol>\n<h3 id=\"硬件架构\"><a href=\"#硬件架构\" class=\"headerlink\" title=\"硬件架构\"></a>硬件架构</h3><p>硬件主要由传感器、控制器与执行器三部分组成</p>\n<h4 id=\"传感器\"><a href=\"#传感器\" class=\"headerlink\" title=\"传感器\"></a>传感器</h4><p>目前AEB主流方案采用的环境感知传感器为<strong>毫米波雷达</strong>和<strong>摄像头</strong>：毫米波雷达通过对目标物发送电磁波并接收回波来获得目标物体的距离、速度和角度；摄像头需要先进行目标识别，然后再根据目标在图像中的像素大小来估算目标距离。</p>\n<h4 id=\"控制器\"><a href=\"#控制器\" class=\"headerlink\" title=\"控制器\"></a>控制器</h4><p>AEB控制器目前多集成在传感器内部（多为毫米波雷达），随着智能驾驶技术的不断发展，AEB控制功能将逐步由域控制器承担</p>\n<h4 id=\"执行器\"><a href=\"#执行器\" class=\"headerlink\" title=\"执行器\"></a>执行器</h4><p>目前AEB的执行器均为<strong>电子稳定系统</strong>(Electronic Stability Program，简称ESP)</p>\n<p>该系统由传感器、电子控制单元（ECU）和执行器三大部分组成，通过电子控制单元监控汽车运行状态，对车辆的发动机及制动系统进行干预控制。典型的汽车电子稳定控制系统在传感器上主要包括4个轮速传感器、方向盘转角传感器、侧向加速度传感器、横摆角速度传感器、制动主缸压力传感器等，执行部分则包括传统制动系统(真空助力器、管路和制动器)、液压调节器等，电子控制单元与发动机管理系统联动，可对发动机动力输出进行干预和调整。</p>\n<h3 id=\"算法设计\"><a href=\"#算法设计\" class=\"headerlink\" title=\"算法设计\"></a>算法设计</h3><p>详情 <a href=\"https://mp.weixin.qq.com/s?src=11&timestamp=1623979825&ver=3137&signature=2gmnbGN0EV1gOIXbR9B0VlycyaD1-roe-vCjXOrhJMvjPagEGavYekQDufXG4*WBosqu3Tn6R4QZDvl*tuGa0UxcPOf3zoj*G5j9JmHZOVs6TNdDzaSI6aC88nth7SdG&new=1\">AEB算法设计</a></p>"},{"title":"虚拟机安装Ubuntu，关闭动画精简软件等","date":"2021-04-26T10:45:11.000Z","_content":"\n\n### 虚拟机安装Ubuntu配置记录\n\n- [关闭动画](#_2)\n- [精简软件](#_15)\n- [WIN10+Ubuntu双系统完全删除Ubuntu并删除BOOT引导中的启动项](#WIN10UbuntuUbuntuBOOT_25)\n\n<!--more-->\n# 关闭动画\n\n关闭动画\n\n```powershell\ngsettings set org.gnome.desktop.interface enable-animations false\n```\n\n打开动画\n\n```powershell\ngsettings set org.gnome.desktop.interface enable-animations true\n```\n\n# 精简软件\n\n卸载libreoffice\n\n```powershell\nsudo apt-get remove libreoffice-common\n```\n\n卸载无用软件\n\n```powershell\nsudo apt-get remove thunderbird totem rhythmbox empathy brasero simple-scan gnome-mahjongg aisleriot gnome-mines cheese transmission-common gnome-orca gnome-sudoku\n```\n\n# WIN10+Ubuntu双系统完全删除Ubuntu并删除BOOT引导中的启动项\n\n1、首先进入BIOS将Windows boot manager设为第一启动项  \n2、进入Windows后使用DiskGenius 删除系统EFI分区中的Ubuntu启动项  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210426185515146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)  \n3、最后使用EasyUEFI删除启动项中的Ubuntu即可，大功告成  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021042618584411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210426185853166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)","source":"_posts/虚拟机安装Ubuntu，关闭动画精简软件等.md","raw":"---\ntitle: 虚拟机安装Ubuntu，关闭动画精简软件等\ndate: 2021-04-26 18:45:11\ntags: linux\ncategories: Linux\n---\n\n\n### 虚拟机安装Ubuntu配置记录\n\n- [关闭动画](#_2)\n- [精简软件](#_15)\n- [WIN10+Ubuntu双系统完全删除Ubuntu并删除BOOT引导中的启动项](#WIN10UbuntuUbuntuBOOT_25)\n\n<!--more-->\n# 关闭动画\n\n关闭动画\n\n```powershell\ngsettings set org.gnome.desktop.interface enable-animations false\n```\n\n打开动画\n\n```powershell\ngsettings set org.gnome.desktop.interface enable-animations true\n```\n\n# 精简软件\n\n卸载libreoffice\n\n```powershell\nsudo apt-get remove libreoffice-common\n```\n\n卸载无用软件\n\n```powershell\nsudo apt-get remove thunderbird totem rhythmbox empathy brasero simple-scan gnome-mahjongg aisleriot gnome-mines cheese transmission-common gnome-orca gnome-sudoku\n```\n\n# WIN10+Ubuntu双系统完全删除Ubuntu并删除BOOT引导中的启动项\n\n1、首先进入BIOS将Windows boot manager设为第一启动项  \n2、进入Windows后使用DiskGenius 删除系统EFI分区中的Ubuntu启动项  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210426185515146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)  \n3、最后使用EasyUEFI删除启动项中的Ubuntu即可，大功告成  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021042618584411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210426185853166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70)","slug":"虚拟机安装Ubuntu，关闭动画精简软件等","published":1,"updated":"2023-08-15T12:59:46.534Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllcdfgkp0018i7jxb1r00ahy","content":"<h3 id=\"虚拟机安装Ubuntu配置记录\"><a href=\"#虚拟机安装Ubuntu配置记录\" class=\"headerlink\" title=\"虚拟机安装Ubuntu配置记录\"></a>虚拟机安装Ubuntu配置记录</h3><ul>\n<li><a href=\"#_2\">关闭动画</a></li>\n<li><a href=\"#_15\">精简软件</a></li>\n<li><a href=\"#WIN10UbuntuUbuntuBOOT_25\">WIN10+Ubuntu双系统完全删除Ubuntu并删除BOOT引导中的启动项</a></li>\n</ul>\n<span id=\"more\"></span>\n<h1 id=\"关闭动画\"><a href=\"#关闭动画\" class=\"headerlink\" title=\"关闭动画\"></a>关闭动画</h1><p>关闭动画</p>\n<pre><code class=\"powershell\">gsettings set org.gnome.desktop.interface enable-animations false\n</code></pre>\n<p>打开动画</p>\n<pre><code class=\"powershell\">gsettings set org.gnome.desktop.interface enable-animations true\n</code></pre>\n<h1 id=\"精简软件\"><a href=\"#精简软件\" class=\"headerlink\" title=\"精简软件\"></a>精简软件</h1><p>卸载libreoffice</p>\n<pre><code class=\"powershell\">sudo apt-get remove libreoffice-common\n</code></pre>\n<p>卸载无用软件</p>\n<pre><code class=\"powershell\">sudo apt-get remove thunderbird totem rhythmbox empathy brasero simple-scan gnome-mahjongg aisleriot gnome-mines cheese transmission-common gnome-orca gnome-sudoku\n</code></pre>\n<h1 id=\"WIN10-Ubuntu双系统完全删除Ubuntu并删除BOOT引导中的启动项\"><a href=\"#WIN10-Ubuntu双系统完全删除Ubuntu并删除BOOT引导中的启动项\" class=\"headerlink\" title=\"WIN10+Ubuntu双系统完全删除Ubuntu并删除BOOT引导中的启动项\"></a>WIN10+Ubuntu双系统完全删除Ubuntu并删除BOOT引导中的启动项</h1><p>1、首先进入BIOS将Windows boot manager设为第一启动项<br>2、进入Windows后使用DiskGenius 删除系统EFI分区中的Ubuntu启动项<br><img src=\"https://img-blog.csdnimg.cn/20210426185515146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>3、最后使用EasyUEFI删除启动项中的Ubuntu即可，大功告成<br><img src=\"https://img-blog.csdnimg.cn/2021042618584411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/20210426185853166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"虚拟机安装Ubuntu配置记录\"><a href=\"#虚拟机安装Ubuntu配置记录\" class=\"headerlink\" title=\"虚拟机安装Ubuntu配置记录\"></a>虚拟机安装Ubuntu配置记录</h3><ul>\n<li><a href=\"#_2\">关闭动画</a></li>\n<li><a href=\"#_15\">精简软件</a></li>\n<li><a href=\"#WIN10UbuntuUbuntuBOOT_25\">WIN10+Ubuntu双系统完全删除Ubuntu并删除BOOT引导中的启动项</a></li>\n</ul>","more":"<h1 id=\"关闭动画\"><a href=\"#关闭动画\" class=\"headerlink\" title=\"关闭动画\"></a>关闭动画</h1><p>关闭动画</p>\n<pre><code class=\"powershell\">gsettings set org.gnome.desktop.interface enable-animations false\n</code></pre>\n<p>打开动画</p>\n<pre><code class=\"powershell\">gsettings set org.gnome.desktop.interface enable-animations true\n</code></pre>\n<h1 id=\"精简软件\"><a href=\"#精简软件\" class=\"headerlink\" title=\"精简软件\"></a>精简软件</h1><p>卸载libreoffice</p>\n<pre><code class=\"powershell\">sudo apt-get remove libreoffice-common\n</code></pre>\n<p>卸载无用软件</p>\n<pre><code class=\"powershell\">sudo apt-get remove thunderbird totem rhythmbox empathy brasero simple-scan gnome-mahjongg aisleriot gnome-mines cheese transmission-common gnome-orca gnome-sudoku\n</code></pre>\n<h1 id=\"WIN10-Ubuntu双系统完全删除Ubuntu并删除BOOT引导中的启动项\"><a href=\"#WIN10-Ubuntu双系统完全删除Ubuntu并删除BOOT引导中的启动项\" class=\"headerlink\" title=\"WIN10+Ubuntu双系统完全删除Ubuntu并删除BOOT引导中的启动项\"></a>WIN10+Ubuntu双系统完全删除Ubuntu并删除BOOT引导中的启动项</h1><p>1、首先进入BIOS将Windows boot manager设为第一启动项<br>2、进入Windows后使用DiskGenius 删除系统EFI分区中的Ubuntu启动项<br><img src=\"https://img-blog.csdnimg.cn/20210426185515146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>3、最后使用EasyUEFI删除启动项中的Ubuntu即可，大功告成<br><img src=\"https://img-blog.csdnimg.cn/2021042618584411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/20210426185853166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhb190b3A=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>"},{"title":"新安装Ubuntu配置过程","date":"2021-04-26T13:19:18.000Z","_content":"\n\n## 2021.5.3 Update\n\n## Linux-Setting\n\n#### 介绍\n\n<!--more-->\nLinux安装后自动配置脚本\n\n#### 说明\n\n1.  更换自带源为阿里源\n2.  卸载自带无用软件如libreoffice、thunderbird等\n3.  安装常用软件如git、curl、vim等\n4.  git设置\n5.  zsh\\&oh-my-zsh\n\n#### 使用说明\n\n首先安装git，curl，zsh\n\n```\nsudo apt install git curl\n```\n\n然后安装zsh\n\n```\nsudo apt install -y zsh\n\nsh -c \"$(curl -fsSL https://gitee.com/pocmon/ohmyzsh/raw/master/tools/install.sh)\"\n```\n\n 1.     克隆本仓库至本地\n\n```\ngit clone https://gitee.com/xiaolinzinvshen/linux-setting.git\n```\n\n 2.     cd到相应文件夹中\n 3.     对相应的脚本增加执行权限后执行脚本\n\n```\nchmod +x ./init-ubuntu.sh\n\n./init-ubuntu.sh\n```\n\n---\n---\n---\n\n## Old\n\n## 更换清华镜像源\n\nUbuntu 的软件源配置文件是 /etc/apt/sources.list。将系统自带的该文件做个备份\n\n```powershell\nsudo cp /etc/apt/sources.list /etc/apt/sources_backup.list\n```\n\n使用gedit将源中内容替换\n\n```bash\nsudo gedit /etc/apt/sources.list\n```\n\n链接: [清华镜像源](https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/).  \n升级自带包\n\n```powershell\nsudo apt update\n```\n\n安装常用基本软件\n\n```powershell\nsudo apt install curl git openssh-server net-tools\n```\n\n## 自动脚本配置\n\n搜索marswang42 找到My-Vim-Conf  \n安装第三方shell-zsh，并替换自带的bash\n\n```powershell\nsudo apt install -y zsh\n```\n\n```powershell\nsh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"\n```\n\nclone博主的源\n\n```powershell\ngit clone https://github.com/MarsWang42/My-Vim-Conf.git\n```\n\n```powershell\ncd My-Vim-Conf\n```\n\n脚本自动安装\n\n```powershell\nchmod +x ./setup.sh ./tmux.sh\n```\n\n```powershell\n./setup.sh\n```\n\n最后刷新应用最新的设置\n\n```powershell\nsource ~/.zshrc\n```\n\n## Ubuntu助手：一键安装软件、进行系统配置\n\n```xml\nhttps://github.com/borninfreedom/linux-assistant\n```","source":"_posts/新安装Ubuntu配置过程.md","raw":"---\ntitle: 新安装Ubuntu配置过程\ndate: 2021-04-26 21:19:18\ntags: linux\ncategories: Linux\n---\n\n\n## 2021.5.3 Update\n\n## Linux-Setting\n\n#### 介绍\n\n<!--more-->\nLinux安装后自动配置脚本\n\n#### 说明\n\n1.  更换自带源为阿里源\n2.  卸载自带无用软件如libreoffice、thunderbird等\n3.  安装常用软件如git、curl、vim等\n4.  git设置\n5.  zsh\\&oh-my-zsh\n\n#### 使用说明\n\n首先安装git，curl，zsh\n\n```\nsudo apt install git curl\n```\n\n然后安装zsh\n\n```\nsudo apt install -y zsh\n\nsh -c \"$(curl -fsSL https://gitee.com/pocmon/ohmyzsh/raw/master/tools/install.sh)\"\n```\n\n 1.     克隆本仓库至本地\n\n```\ngit clone https://gitee.com/xiaolinzinvshen/linux-setting.git\n```\n\n 2.     cd到相应文件夹中\n 3.     对相应的脚本增加执行权限后执行脚本\n\n```\nchmod +x ./init-ubuntu.sh\n\n./init-ubuntu.sh\n```\n\n---\n---\n---\n\n## Old\n\n## 更换清华镜像源\n\nUbuntu 的软件源配置文件是 /etc/apt/sources.list。将系统自带的该文件做个备份\n\n```powershell\nsudo cp /etc/apt/sources.list /etc/apt/sources_backup.list\n```\n\n使用gedit将源中内容替换\n\n```bash\nsudo gedit /etc/apt/sources.list\n```\n\n链接: [清华镜像源](https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/).  \n升级自带包\n\n```powershell\nsudo apt update\n```\n\n安装常用基本软件\n\n```powershell\nsudo apt install curl git openssh-server net-tools\n```\n\n## 自动脚本配置\n\n搜索marswang42 找到My-Vim-Conf  \n安装第三方shell-zsh，并替换自带的bash\n\n```powershell\nsudo apt install -y zsh\n```\n\n```powershell\nsh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"\n```\n\nclone博主的源\n\n```powershell\ngit clone https://github.com/MarsWang42/My-Vim-Conf.git\n```\n\n```powershell\ncd My-Vim-Conf\n```\n\n脚本自动安装\n\n```powershell\nchmod +x ./setup.sh ./tmux.sh\n```\n\n```powershell\n./setup.sh\n```\n\n最后刷新应用最新的设置\n\n```powershell\nsource ~/.zshrc\n```\n\n## Ubuntu助手：一键安装软件、进行系统配置\n\n```xml\nhttps://github.com/borninfreedom/linux-assistant\n```","slug":"新安装Ubuntu配置过程","published":1,"updated":"2023-08-15T12:59:46.566Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllcdfgkq001ci7jx4hg9hwjc","content":"<h2 id=\"2021-5-3-Update\"><a href=\"#2021-5-3-Update\" class=\"headerlink\" title=\"2021.5.3 Update\"></a>2021.5.3 Update</h2><h2 id=\"Linux-Setting\"><a href=\"#Linux-Setting\" class=\"headerlink\" title=\"Linux-Setting\"></a>Linux-Setting</h2><h4 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><span id=\"more\"></span>\n<p>Linux安装后自动配置脚本</p>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h4><ol>\n<li> 更换自带源为阿里源</li>\n<li> 卸载自带无用软件如libreoffice、thunderbird等</li>\n<li> 安装常用软件如git、curl、vim等</li>\n<li> git设置</li>\n<li> zsh&amp;oh-my-zsh</li>\n</ol>\n<h4 id=\"使用说明\"><a href=\"#使用说明\" class=\"headerlink\" title=\"使用说明\"></a>使用说明</h4><p>首先安装git，curl，zsh</p>\n<pre><code>sudo apt install git curl\n</code></pre>\n<p>然后安装zsh</p>\n<pre><code>sudo apt install -y zsh\n\nsh -c &quot;$(curl -fsSL https://gitee.com/pocmon/ohmyzsh/raw/master/tools/install.sh)&quot;\n</code></pre>\n<ol>\n<li><pre><code>克隆本仓库至本地\n</code></pre>\n</li>\n</ol>\n<pre><code>git clone https://gitee.com/xiaolinzinvshen/linux-setting.git\n</code></pre>\n<ol start=\"2\">\n<li><pre><code>cd到相应文件夹中\n</code></pre>\n</li>\n<li><pre><code>对相应的脚本增加执行权限后执行脚本\n</code></pre>\n</li>\n</ol>\n<pre><code>chmod +x ./init-ubuntu.sh\n\n./init-ubuntu.sh\n</code></pre>\n<hr>\n<hr>\n<hr>\n<h2 id=\"Old\"><a href=\"#Old\" class=\"headerlink\" title=\"Old\"></a>Old</h2><h2 id=\"更换清华镜像源\"><a href=\"#更换清华镜像源\" class=\"headerlink\" title=\"更换清华镜像源\"></a>更换清华镜像源</h2><p>Ubuntu 的软件源配置文件是 /etc/apt/sources.list。将系统自带的该文件做个备份</p>\n<pre><code class=\"powershell\">sudo cp /etc/apt/sources.list /etc/apt/sources_backup.list\n</code></pre>\n<p>使用gedit将源中内容替换</p>\n<pre><code class=\"bash\">sudo gedit /etc/apt/sources.list\n</code></pre>\n<p>链接: <a href=\"https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/\">清华镜像源</a>.<br>升级自带包</p>\n<pre><code class=\"powershell\">sudo apt update\n</code></pre>\n<p>安装常用基本软件</p>\n<pre><code class=\"powershell\">sudo apt install curl git openssh-server net-tools\n</code></pre>\n<h2 id=\"自动脚本配置\"><a href=\"#自动脚本配置\" class=\"headerlink\" title=\"自动脚本配置\"></a>自动脚本配置</h2><p>搜索marswang42 找到My-Vim-Conf<br>安装第三方shell-zsh，并替换自带的bash</p>\n<pre><code class=\"powershell\">sudo apt install -y zsh\n</code></pre>\n<pre><code class=\"powershell\">sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;\n</code></pre>\n<p>clone博主的源</p>\n<pre><code class=\"powershell\">git clone https://github.com/MarsWang42/My-Vim-Conf.git\n</code></pre>\n<pre><code class=\"powershell\">cd My-Vim-Conf\n</code></pre>\n<p>脚本自动安装</p>\n<pre><code class=\"powershell\">chmod +x ./setup.sh ./tmux.sh\n</code></pre>\n<pre><code class=\"powershell\">./setup.sh\n</code></pre>\n<p>最后刷新应用最新的设置</p>\n<pre><code class=\"powershell\">source ~/.zshrc\n</code></pre>\n<h2 id=\"Ubuntu助手：一键安装软件、进行系统配置\"><a href=\"#Ubuntu助手：一键安装软件、进行系统配置\" class=\"headerlink\" title=\"Ubuntu助手：一键安装软件、进行系统配置\"></a>Ubuntu助手：一键安装软件、进行系统配置</h2><pre><code class=\"xml\">https://github.com/borninfreedom/linux-assistant\n</code></pre>\n","site":{"data":{}},"excerpt":"<h2 id=\"2021-5-3-Update\"><a href=\"#2021-5-3-Update\" class=\"headerlink\" title=\"2021.5.3 Update\"></a>2021.5.3 Update</h2><h2 id=\"Linux-Setting\"><a href=\"#Linux-Setting\" class=\"headerlink\" title=\"Linux-Setting\"></a>Linux-Setting</h2><h4 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4>","more":"<p>Linux安装后自动配置脚本</p>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h4><ol>\n<li> 更换自带源为阿里源</li>\n<li> 卸载自带无用软件如libreoffice、thunderbird等</li>\n<li> 安装常用软件如git、curl、vim等</li>\n<li> git设置</li>\n<li> zsh&amp;oh-my-zsh</li>\n</ol>\n<h4 id=\"使用说明\"><a href=\"#使用说明\" class=\"headerlink\" title=\"使用说明\"></a>使用说明</h4><p>首先安装git，curl，zsh</p>\n<pre><code>sudo apt install git curl\n</code></pre>\n<p>然后安装zsh</p>\n<pre><code>sudo apt install -y zsh\n\nsh -c &quot;$(curl -fsSL https://gitee.com/pocmon/ohmyzsh/raw/master/tools/install.sh)&quot;\n</code></pre>\n<ol>\n<li><pre><code>克隆本仓库至本地\n</code></pre>\n</li>\n</ol>\n<pre><code>git clone https://gitee.com/xiaolinzinvshen/linux-setting.git\n</code></pre>\n<ol start=\"2\">\n<li><pre><code>cd到相应文件夹中\n</code></pre>\n</li>\n<li><pre><code>对相应的脚本增加执行权限后执行脚本\n</code></pre>\n</li>\n</ol>\n<pre><code>chmod +x ./init-ubuntu.sh\n\n./init-ubuntu.sh\n</code></pre>\n<hr>\n<hr>\n<hr>\n<h2 id=\"Old\"><a href=\"#Old\" class=\"headerlink\" title=\"Old\"></a>Old</h2><h2 id=\"更换清华镜像源\"><a href=\"#更换清华镜像源\" class=\"headerlink\" title=\"更换清华镜像源\"></a>更换清华镜像源</h2><p>Ubuntu 的软件源配置文件是 /etc/apt/sources.list。将系统自带的该文件做个备份</p>\n<pre><code class=\"powershell\">sudo cp /etc/apt/sources.list /etc/apt/sources_backup.list\n</code></pre>\n<p>使用gedit将源中内容替换</p>\n<pre><code class=\"bash\">sudo gedit /etc/apt/sources.list\n</code></pre>\n<p>链接: <a href=\"https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/\">清华镜像源</a>.<br>升级自带包</p>\n<pre><code class=\"powershell\">sudo apt update\n</code></pre>\n<p>安装常用基本软件</p>\n<pre><code class=\"powershell\">sudo apt install curl git openssh-server net-tools\n</code></pre>\n<h2 id=\"自动脚本配置\"><a href=\"#自动脚本配置\" class=\"headerlink\" title=\"自动脚本配置\"></a>自动脚本配置</h2><p>搜索marswang42 找到My-Vim-Conf<br>安装第三方shell-zsh，并替换自带的bash</p>\n<pre><code class=\"powershell\">sudo apt install -y zsh\n</code></pre>\n<pre><code class=\"powershell\">sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;\n</code></pre>\n<p>clone博主的源</p>\n<pre><code class=\"powershell\">git clone https://github.com/MarsWang42/My-Vim-Conf.git\n</code></pre>\n<pre><code class=\"powershell\">cd My-Vim-Conf\n</code></pre>\n<p>脚本自动安装</p>\n<pre><code class=\"powershell\">chmod +x ./setup.sh ./tmux.sh\n</code></pre>\n<pre><code class=\"powershell\">./setup.sh\n</code></pre>\n<p>最后刷新应用最新的设置</p>\n<pre><code class=\"powershell\">source ~/.zshrc\n</code></pre>\n<h2 id=\"Ubuntu助手：一键安装软件、进行系统配置\"><a href=\"#Ubuntu助手：一键安装软件、进行系统配置\" class=\"headerlink\" title=\"Ubuntu助手：一键安装软件、进行系统配置\"></a>Ubuntu助手：一键安装软件、进行系统配置</h2><pre><code class=\"xml\">https://github.com/borninfreedom/linux-assistant\n</code></pre>"}],"PostAsset":[],"PostCategory":[{"post_id":"cllcdfgk60006i7jxfdisgu72","category_id":"cllcdfgk30004i7jxdk7m4uod","_id":"cllcdfgka000bi7jxcgsc780b"},{"post_id":"cllcdfgjz0001i7jx1szg280h","category_id":"cllcdfgk30004i7jxdk7m4uod","_id":"cllcdfgkc000ei7jx3v517j64"},{"post_id":"cllcdfgk70007i7jx9a5o8eiv","category_id":"cllcdfgk30004i7jxdk7m4uod","_id":"cllcdfgkc000gi7jx2qv1a7zv"},{"post_id":"cllcdfgk90009i7jxauhig77j","category_id":"cllcdfgk30004i7jxdk7m4uod","_id":"cllcdfgke000ji7jx0s6ag0qc"},{"post_id":"cllcdfgk20003i7jx4mf87130","category_id":"cllcdfgk30004i7jxdk7m4uod","_id":"cllcdfgkf000li7jx2s3r40hs"},{"post_id":"cllcdfgk50005i7jx892cetzv","category_id":"cllcdfgk30004i7jxdk7m4uod","_id":"cllcdfgkg000oi7jx95uth4s7"},{"post_id":"cllcdfgka000ai7jxhddqbn7y","category_id":"cllcdfgkd000hi7jx1lxi84qx","_id":"cllcdfgki000qi7jxeaow393q"},{"post_id":"cllcdfgkg000ni7jxcxhvcrrp","category_id":"cllcdfgkf000mi7jx007u59c1","_id":"cllcdfgkk000ui7jx9wkvfm3z"},{"post_id":"cllcdfgkc000fi7jxhcvkgrkf","category_id":"cllcdfgkf000mi7jx007u59c1","_id":"cllcdfgkl000xi7jx6ayudjdv"},{"post_id":"cllcdfgkd000ii7jx44iq7zcl","category_id":"cllcdfgkf000mi7jx007u59c1","_id":"cllcdfgkm0010i7jx6sog6iez"},{"post_id":"cllcdfgke000ki7jx0pwp66c6","category_id":"cllcdfgkf000mi7jx007u59c1","_id":"cllcdfgko0014i7jx26mp3sg0"},{"post_id":"cllcdfgkl000yi7jx52ba4b2c","category_id":"cllcdfgkf000mi7jx007u59c1","_id":"cllcdfgkp0017i7jx0s0u1l04"},{"post_id":"cllcdfgkm0011i7jx15ej8xup","category_id":"cllcdfgkf000mi7jx007u59c1","_id":"cllcdfgkq0019i7jxh5z89nqx"},{"post_id":"cllcdfgkh000pi7jxfpay5tsd","category_id":"cllcdfgkm000zi7jx0hvz0qlg","_id":"cllcdfgkr001di7jx7h8igtsc"},{"post_id":"cllcdfgko0016i7jx8lza91ge","category_id":"cllcdfgk30004i7jxdk7m4uod","_id":"cllcdfgkr001fi7jx0g241b9i"},{"post_id":"cllcdfgki000si7jxcgyo6ujw","category_id":"cllcdfgkm000zi7jx0hvz0qlg","_id":"cllcdfgkr001hi7jx5t1thh7s"},{"post_id":"cllcdfgkp0018i7jxb1r00ahy","category_id":"cllcdfgkf000mi7jx007u59c1","_id":"cllcdfgks001ji7jx1747bkf1"},{"post_id":"cllcdfgkq001ci7jx4hg9hwjc","category_id":"cllcdfgkf000mi7jx007u59c1","_id":"cllcdfgks001mi7jxhdcxcbag"},{"post_id":"cllcdfgkj000ti7jx537s1s89","category_id":"cllcdfgkm000zi7jx0hvz0qlg","_id":"cllcdfgks001ni7jxfe1s69cq"},{"post_id":"cllcdfgkl000wi7jx5i3q1izj","category_id":"cllcdfgkm000zi7jx0hvz0qlg","_id":"cllcdfgks001pi7jx1tmify9f"},{"post_id":"cllcdfgkn0013i7jx9z42c7j2","category_id":"cllcdfgks001li7jx8cif4d66","_id":"cllcdfgkt001qi7jx7x69h51n"}],"PostTag":[{"post_id":"cllcdfgkl000yi7jx52ba4b2c","tag_id":"cllcdfgkn0012i7jx834s4dby","_id":"cllcdfgkq001ai7jxcnp8djv3"},{"post_id":"cllcdfgkp0018i7jxb1r00ahy","tag_id":"cllcdfgkr001ei7jx1zqo6rvr","_id":"cllcdfgks001ki7jx23d67xwo"},{"post_id":"cllcdfgkq001ci7jx4hg9hwjc","tag_id":"cllcdfgkr001ei7jx1zqo6rvr","_id":"cllcdfgks001oi7jx6qpg0qkg"}],"Tag":[{"name":"git linux","_id":"cllcdfgkn0012i7jx834s4dby"},{"name":"linux","_id":"cllcdfgkr001ei7jx1zqo6rvr"}]}}